//
//  TextResource.swift
//  WebSocketDemo
//
//  Created by hq on 2023/2/22.
//

import Foundation

let sendMessage = """
//
//  SweeperMainViewController.swift
//  Pods
//
//  Created by 爱迪生 on 2021/8/2.
//

import UIKit
import SurveillanceHomeBase
import Promises
import SwiftyJSON
import SharedResource
import TPFoundation
import SimplePlayer
import DeviceDetailModule
import SnapKit
import NetService
import ThemeTool

enum CaptureImageLoadingStatus: Equatable {
    case loadSuccess
    case failure
    case loading
    case loadNoImage
    case model(SweeperBarrierType)
}

enum MainMapLoadingState {
    case loading
    case failure
    case noMap
    case hasMap
}

class SweeperMainViewController: SweeperGlobalConfigurationViewController {
    var needShowFastMapGuide: Bool = false
    // MARK: subviews
    private var previewButton: SweeperButton?
    weak var inputPasswordVC: UIViewController?
    var inputPassword: String?
    private var editButton: SweeperButton?
    private var baseStationButton: SweeperButton?
    private var moreButton: SweeperButton?
    private var parameterButton = SweeperButton()
    private var navigationTitleView = SweeperTitleBatteryView()
    private var chargeButton = SweeperButton()
    private var createMapContainer: SweeperCreateMapView?
    private var sweepAreaPopView: SweeperClearAreaPopView?
    private var sweeperAlarmViewController: (UIViewController & SweeperAlarmWindowSuitable)?
    private var startCleanAnimationView: SweeperStartCleanAnimationView?
    private var mapView = SweeperHomeMapView(frame: .zero, mapSize: .init(width: 1200, height: 1200))
    private var loadingView = SweeperMainMapLoadingView(frame: .zero)
    private var buttonContainerStackView = UIStackView()
    private var environmentView = UIView(frame: .zero)
    private var temperatureView = UILabel(frame: .zero)
    private var humidityView = UILabel(frame: .zero)
    private var equipmentOfflineView: SweeperRobotOfflineView?

    private var sweepControlView = SweeperControlView()
    private var sweepCaptureView = SweeperCaptureBubbleView()
    private var sweeperBaseUpgradingView = SweeperBaseStationUpgradingView()
    private var sweeperMechanicalOffView = SweeperMechanicalOffView()

    private var sweepControlViewHeightConstraint: NSLayoutConstraint?
    private var heightForControlView: CGFloat {
        switch status {
        case .stop:
            return 88 + bottomSafeAreaInset
        case .fastMap, .fastMapPause:
            return 69 + bottomSafeAreaInset
        case .sweepingPause, .sweeping:
            return 143 + bottomSafeAreaInset
        }
    }

    enum AlarmButtonClickMode {
        case exit
        case more
        case none
    }
    private var alarmButtonClickMode: AlarmButtonClickMode = .exit

    // 快速建图引导view
    private var fastMapImageView: UIImageView?
    private var fastMapGuideView: GuidePresentationView?


    // 地图已自动保存通知
    private var savedMapNoticeView: UIImageView?
    private var saveMapGuideView: GuidePresentationView?
    // 存储设备详细信息
    private var deviceDetail: DeviceDetail?
    private var isSharedDevice: Bool {
        return deviceDetail?.isSharedDevice ?? false
    }

    private var robotOffline = false
    private var hadStartWaveAnimation = false

    /// 首次载入
    /// 第一帧地图帧/路径帧到来时刷新所有界面
    private var needRefreshMapViewInMediaPlayer = true
    private var needEntrySaveMapLogic = true
    private var needShowCleaningLog = true

    /// 该属性用于，当前保存地图弹窗弹出时，扫地机正在清扫。保存该弹出状态，在清扫结束后再进入一遍保存地图逻辑。
    private var needEntrySaveMapLogicAfterBasicStateChanged = false


    /// 在地图变化时，将下列是否需要展示“地图保存”弹窗标识为true
    /// 在dataloading成功时，进行展示
    private var needShowSaveMapMultiFloor = false
    private var needShowSaveMapSingleFloor = false
    private var needShowMapHasSavedTip = false

    /// 基站升级与关机页面展示
    private var isShowingUpgradingView: Bool {
        get {
            return !sweeperBaseUpgradingView.isHidden
        }
        set {
            sweeperBaseUpgradingView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var isShowingMechanicalView: Bool {
        get {
            return !sweeperMechanicalOffView.isHidden
        }
        set {
            sweeperMechanicalOffView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var shouldShowChargeButton: Bool {
        get {
            guard let state = state else {
                return false
            }
            // 清扫完成并且不在基站上
            return state.cleanFinished && !state.onboard
        }
    }

    private var firstTimeUpdateNavigationTitle: Bool = true

    private var cleaningMode: SweeperCleaningMode {
        get {
            return sweeperControl?.cleaningMode ?? SweeperCleaningMode.init(type: .autoClean)
        }
        set {
            sweeperControl?.cleaningMode = newValue
            updateCleaningModeUI()
        }
    }

    private var cleaningModeType: CleaningModeType {
        get {
            return cleaningMode.type
        }
        set {
            cleaningMode.type = newValue
        }
    }

    override var sweeperCustomOrAutoMode: SweeperCustomOrAutoMode {
        get {
            return (sweeperControl?.customCleanEnabled ?? false) ? .custom : .auto
        }
        set { }
    }

    private var map: SweeperMap? {
        get {
            return sweeperControl?.map
        }
        set {
            let preMap = map
            sweeperControl?.map = newValue
            currentMapDidChanged(preMap: preMap)
        }
    }

    private var status: SweeperProcedure = .stop

    private var state: SweeperState? {
        get {
            return sweeperControl?.basicState
        }

        set {
            sweeperControl?.basicState = newValue
            basicStateChangeAction(showToast: true)
        }
    }

    private var temperatureText: String {
        get {
            var text = "环境温度："
            if let temperature = state?.temperature {
                let temperatureValue = Int(temperature)
                if temperatureValue == 127 || temperatureValue < -40 {
                    text += "--"
                } else {
                    text += "(Int(temperature))℃"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var humidityText: String {
        get {
            var text = "环境湿度："
            if let humidity = state?.humidity {
                let humidityValue = Int(humidity)
                if humidityValue < 0 || humidityValue > 100 {
                    text += "--"
                } else {
                    text += "(Int(humidity))%"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var cleaningState: SweeperCleaningState? {
        get {
            return sweeperControl?.cleaningState
        }

        set {
            sweeperControl?.cleaningState = newValue
            updateCleaningStateUI()
        }
    }

    private var isRecharging: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .recharge
    }

    private var forbiddenRechargeAndClean: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .assignLocation || state.mainState == .remoteControl
    }

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = SharedResource.sharedImage(named: "shared_setting_icon_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(settingBarButtonItemDidClick))
    }()

    // selected layerID backup
    private var selectedLayerID = [Int]()

    // 当前展示的障碍物ID
    private var obstacleID: Int?

    override var navigationBarTraits: [NavigationBarTrait] {
        return [.hidden(on: false), .style(style: .default), .translucent(on: false), .barTint(color: .init(hexString: lightGray10Color)), .separatorStyle(color: .clear, height: 0.0), .backgroundImage(image: UIImage())]
    }

    // MARK: - Constants
    private let chargeButtonPadding = 8.0
    private let defaultButtonPadding = 12.0
    private let defaultButtonInterval = 59.0
    private let battreyThreshold = 20
    private let bottomSafeAreaInset = TPUIUtils.safeAreaInsets().bottom

    override init(deviceID: TPSSDeviceIdentifier, listType: TPSSDeviceListType) {
        super.init(deviceID: deviceID, listType: listType)

        SweeperModule.shared.registerControlListener(listener: self, deviceID: deviceID, listType: listType)
        SweeperModule.shared.registerMapListener(mapListener: self)
        NotificationCenter.default.addObserver(self, selector: #selector(willEnterForeground), name: UIApplication.willEnterForegroundNotification, object: nil)
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        view.backgroundColor = .init(hexString: lightGray10Color)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        setupNavigation()
        setupControlView()
        setupMapView()
        setupSweeperAlarmView()
        setupButtons()
        setupOfflineView()
        setupEnvironmentView()
        setupLoadingView()
        setupUpgradingView()
        setupMechanicalOffView()
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true

        // 离开当前页面时，会使动画失效，若正在展示动画，再重新进入时，需要重新开始动画
        if hadStartWaveAnimation {
            startWaveAnimation()
        }

        if let loadingState = sweeperControl?.dataLoadingState {
            dataLoadingStateChangeAction(loadingState: loadingState)
        } else {
            updateViewShowState(state: .failed)
        }
        captureBubbleViewDismiss()
        // 横幅始终展示在最前方
        if let alarmView = sweeperAlarmViewController?.view {
            view.bringSubviewToFront(alarmView)
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        if needShowFastMapGuide {
            showFastMapGuideView()
            needShowFastMapGuide = false
        }
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        savedMapNoticeView?.removeFromSuperview()
    }

    deinit {
        SweeperModule.shared.removeControlListener(listener: self)
        SweeperModule.shared.removeMapListener(mapListener: self)
        NotificationCenter.default.removeObserver(self)
    }

    // 将从后台切换到前台，看作视图willAppear，方法作相同处理
    @objc func willEnterForeground() {
        cleanAllFlag()

        // 若当前的载入状态为loading时，对UI进行loading状态的刷新。
        // 否则等待dataLoadingStateDidChanged方法回调(从 loading -> 其他状态)。
        // 注：dataLoadingStateDidChanged方法在 loading -> loading 时不会被调用。
        if sweeperControl?.dataLoadingState == .loading {
            dataLoadingStateChanged(loadingState: .loading)
        }
    }

    /// 根据载入状态更新主页面View的展示情况
    /// -主页面加载状态 -
    /// 需要管理的控件：创建地图按钮、主页面地图、载入（载入失败）页面、编辑地图按钮、边扫边拖（定制清扫）悬浮按钮
    private func updateViewShowState(state: SweeperDataLoadingState) {
        switch state {
            case .loading:
                loadingView.isHidden = false
                loadingView.isLoadingFailure = false
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
            case .failed:
                loadingView.isLoadingFailure = true
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
                // 若扫地机离线，则展示离线页面，否则展示加载失败页面
                loadingView.isHidden = robotOffline
                equipmentOfflineView?.isHidden = !robotOffline
            case .noMap:
                createMapContainer?.isHidden = false
                loadingView.isHidden = true
                mapView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                parameterButton.isHidden = false
                moreButton?.isHidden = false
                editButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
            case .success:
                loadingView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                mapView.isHidden = false
                createMapContainer?.isHidden = true
                parameterButton.isHidden = false
                editButton?.isHidden = false
                moreButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
        }
    }

    override func willUpdateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode, showAlert: Bool) -> Bool {
        /// 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            if showAlert {
                showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap)
            }
            return false
        }
        return super.willUpdateSweeperCustomOrAutoMode(newMode: newMode, showAlert: showAlert)
    }

    override func updateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode) {
        /// 1. 若切换时当前清扫模式与newMode相同，则无需进入后续逻辑
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap,
              let sweeperControl = sweeperControl,
              let mapID = sweeperControl.map?.currentMapID,
              newMode != sweeperCustomOrAutoMode else {
            return
        }

        /// 2. 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap) { [weak self] (_) in
                self?.configurationView?.selectSegment(type: .auto)
            }
            return
        }

        /// 3. 切换为定制清扫时，无设置清扫顺序与清扫偏好，则不向设备发送请求（并在退出弹窗时（configurationFinished）切换回变扫边拖）
        if newMode == .custom && !isSetPreference() && !isSetSweepSeq() {
            return
        }

        /// 4. 发送切换清扫模式的接口，并修改主页面UI
        let customCleanEnabled = newMode == .custom
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestSetCleaningParam(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: mapID, customEnabled: customCleanEnabled).always {
            ToastView.dismissLoadingToast()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }

    override func configurationFinished() {
        /// 若configurationView当前处于定制清扫页面（“1”状态），则判断是否已设置定制清扫，若否切回边扫边拖。
        if !isSetPreference() && !isSetSweepSeq() && !settingButtonDidClickFlag && configurationView?.segmentedControl.selectedSegmentIndex == 1 {
            ToastView.showWarningToast(title: "未设置定制清扫，只能使用普通清扫", existTime: nil, centerY: .low)
            // 0 - means auto cleaning
            configurationView?.selectSegment(type: .auto)
        }
    }

    override func preferenceButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.preferenceButtonClickOperation()
    }

    override func sweepOrderButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.sweepOrderButtonClickOperation()
    }

    private func refreshMediaPlayerAndSweeperControl() {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.refreshSweeperControl()
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
    }

    private func updateConfigurationView() {
        configurationView?.selectSegment(type: sweeperCustomOrAutoMode)
        if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
            cleanMethodMode = mode
        }
    }

    private func updateClearingAreaButton() {
        var text = "全屋"
        var imagePath = "sweep_home"
        var title = text
        switch cleaningModeType {
        case .pointClean:
            text = "选框"
            title = text
            imagePath = "sweep_frame"
        case .areaClean:
            text = "区域"
            title = text
            imagePath = "sweep_region"
        case .autoClean:
            text = "全屋"
            title = text
            imagePath = "sweep_home"
        case .partClean:
            // 仅在sweepControlView的RangeTitle中修改
            updateData(with: .autoClean)
            title = "局部"
        case .fastMap:
            // DO NOTHING
            return
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
        sweepControlView.clearAreaButton?.titleLabel.text = text
        sweepControlView.clearAreaButton?.titleImageView.image = UIImage.image(named: imagePath)
        sweepControlView.rangeTitleLabel.text = title
        sweepControlView.clearAreaButton?.selectedAreaNumber = cleaningModeType == .areaClean ? selectedLayerID.count : 0
    }

    private func updateSweeperHomeMapViewCleanMode() {
        switch cleaningModeType {
        case .pointClean:
            mapView.cleaningModeType = .pointClean
        case .areaClean:
            mapView.cleaningModeType = .areaClean
        case .autoClean:
            mapView.cleaningModeType = .autoClean
        case .partClean:
            mapView.cleaningModeType = .partClean
        case .fastMap:
            mapView.cleaningModeType = .fastMap
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
    }

    private func updateSelectedLayerID() {
        if let seq = sweeperControl?.cleaningMode.areaIDs {
            selectedLayerID = seq
        }
    }

    private func updateParamUI() {
        var text = ""
        var imagePath = ""
        switch sweeperCustomOrAutoMode {
        case .auto:
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                switch mode {
                case .sweep:
                    text = LocalizedString(key: sweeperCleanOnlySweep)
                    imagePath = "mode_sweep"
                case .mop:
                    text = LocalizedString(key: sweeperCleanOnlyMop)
                    imagePath = "mode_mop"
                case .both:
                    text = LocalizedString(key: sweeperCleanSweepAndMop)
                    imagePath = "mode_sweep_mop"
                }
            }
        case .custom:
            text = LocalizedString(key: sweeperCustomClean)
            imagePath = "mode_diy"
        }
        let image = UIImage.image(named: imagePath)
        // 控制栏的参数按钮
        sweepControlView.parameterButton?.titleLabel.text = text
        sweepControlView.parameterButton?.titleImageView.image = image

        // 悬浮的参数按钮
        parameterButton.titleLabel.text = text
        parameterButton.titleImageView.image = image
    }

    private func updateSweeperHomeMapViewCustomOrAutoMode() {
        switch sweeperCustomOrAutoMode {
        case .auto:
            mapView.sweeperCustomOrAutoMode = .auto
        case .custom:
            mapView.sweeperCustomOrAutoMode = .custom
        }
    }

    private func dataLoadingStateChangeAction(loadingState: SweeperDataLoadingState) {
        // 1. 判断设备是否离线（deviceDetail.online）
        if loadingState == .failed {
            robotOffline = !(deviceDetail?.online ?? false)
        }

        // 2. 判断基站是否升级，若是，则不展示所有UI（除了导航栏）
        if state?.chargeBaseUpgrading == true {
            isShowingUpgradingView = true
            updateNavigation()
            return
        }

        if let switchOn = state?.mechanicalSwitchOn {
            showMechanicalOffView(switchOn: switchOn)
        }

        // 3. 刷新UI状态(是否hidden)
        updateViewShowState(state: loadingState)

        // 4. 载入成功（success or nomap）按照其他状态展示UI
        if loadingState == .success {
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            mapView.updateCleanningModeAndSweepingState()
            mapView.updateCustomOrAutoMode()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            sweeperAlarmViewController?.showAlarm()
            sweeperAlarmViewController?.showNotify()
            if needShowCleaningLog {
                sweeperAlarmViewController?.showCleaningLog()
                needShowCleaningLog = false
            }
            if needEntrySaveMapLogic {
                currentMapDidChanged(preMap: nil)
                needEntrySaveMapLogic = false
            }
            saveMapLogic()
        } else if loadingState == .noMap {
            // 尽管当前map id 为-2，但当设备发送地图帧过来时，仍然需要展示地图，故仍然需要刷新mapView
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            sweeperAlarmViewController?.showCleaningLog()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            // 用户未进入引导页，且当前不在清扫、建图中，需要进入快速建图引导页
            if UserDefaults.standard.shouldShowGuideForFastMap(for: deviceID) && (state?.cleanFinished ?? true) {
                let vc = SweeperFastMapGuideViewController(deviceID: deviceID, listType: listType)
                navigationController?.pushViewController(vc, animated: true)
            }
        }
    }

    private func saveMapLogic() {
        // 若需要展示弹窗，但当前在清扫中，则将弹窗状态保存起来，待扫地机状态变化时重新进入。
        if state?.cleanFinished == false && (needShowSaveMapSingleFloor || needShowSaveMapMultiFloor) {
            needEntrySaveMapLogicAfterBasicStateChanged = true
            return
        }
        if needShowMapHasSavedTip {
            showMapHasSavedTip()
            needShowMapHasSavedTip = false
        }
        if needShowSaveMapSingleFloor {
            saveMapSingleFloor()
            needShowSaveMapSingleFloor = false
        }
        if needShowSaveMapMultiFloor {
            saveMapMultiFloor()
            needShowSaveMapMultiFloor = false
        }
    }

    private func basicStateChangeAction(showToast: Bool) {
        // 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 展示波纹动画: 1. 当前地图ID为-2；
        //             2. 当前在清扫中；
        //             3. 未展示过动画
        //             4. 无地图帧
        if map?.currentMapID == noMapID
            && state?.cleanFinished == false && !hadStartWaveAnimation && sweeperControl?.hadFrame == false {
            startWaveAnimation()
        }
        if (state?.cleanFinished == true) {
            stopWaveAnimation()
        }
        // 特殊情况处理，当扫地机进入清扫状态时
        // 且当前处于无地图时，需要显示地图（而非等到map更改的信令进行变化）
        // 再次变为非清扫状态，且无地图时，需要展示无地图Image
        if map?.currentMapID == noMapID && state?.cleanFinished == false {
            updateViewShowState(state: .success)
        } else if map?.currentMapID == noMapID && state?.cleanFinished == true {
            updateViewShowState(state: .noMap)
        }

        // 扫地机关机状态更新
        showMechanicalOffView(switchOn: state?.mechanicalSwitchOn ?? false)

        if showToast {
            updateBasicStateToastView()
        }
        // 更新扫地机当前的清扫状态（将扫地机状态分为清扫中、暂停中、未清扫，后续根据该status更新清扫UI）
        updateSweepProduce()

        updateUI()
    }

    /// 使用Clean Finished，fast Map  字段与 basic state字段联合判断当前清扫是否结束
    private func updateSweepProduce() {
        guard let state = state else {
            status = .stop
            return
        }
        if state.cleanFinished && state.mainState != .paused && state.mainState != .cleaning {
            // 若设备清扫完成且设备主状态不在清扫、暂停时
            status = .stop
        } else {
            if state.fastMap {
                // 若为快速建图
                if state.mainState == .cleaning {
                    status = .fastMap
                } else {
                    status = .fastMapPause
                }
            } else {
                // 若不为快速建图，则展示正常清扫UI
                if state.mainState == .cleaning {
                   status = .sweeping
                } else {
                   status = .sweepingPause
                }
            }
        }
    }

    // 根据信令展示ToastView
    private func updateBasicStateToastView() {
        guard let state = state else {
            return
        }
        // 主状态为回充，遥控，清扫时候，主页均需展示loading
        if ((state.mainState == .cleaning || state.mainState == .recharge || state.mainState == .remoteControl) && state.subState == .relocate) {
            ToastView.showLoadingToast(cirleWithMessage: "定位中...", existTime: 60, existMessage: nil)
        } else {
            ToastView.dismissLoadingToast()
        }
    }

    /// 根据status更新：清扫面板、清扫参数、导航栏里扫地机的状态、回充按钮、提示栏的位置；
    /// status:     sweeping：当cleanFinished为false，且mainState为Cleaning，subState为Sweeping；
    ///        pause：当cleanFinished为false，
    private func updateUI() {
        // 只当地图数据载入完成之后，更新信令收到后的UI
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 每次收到信令后，获取设备状态，更新设备状态同时更新界面UI

        // 控制面板
        sweepControlView.status = status
        sweepControlViewHeightConstraint?.constant = heightForControlView
        if status == .stop {
            // 清扫参数按钮
            parameterButton.isHidden = true
            // 地图控件
            mapView.isSweeping = false
        } else if status == .fastMap || status == .fastMapPause {
            mapView.isSweeping = true
            parameterButton.isHidden = true
        } else {
            parameterButton.isHidden = false
            mapView.isSweeping = true
        }
        // 导航栏的状态和电量
        updateNavigation()
        // 温度湿度更新
        updateEnvironmentView()
        // 充电按钮
        updateChargeButton()
        refreshBubbleView()
    }

    private func updateCleaningStateUI() {
        guard let state = cleaningState else {
            return
        }
        sweepControlView.areaTitleLabel.text = "(state.cleaningArea)㎡"
        sweepControlView.timeTitleLabel.text = "(state.cleaningTime)min"
    }

    private func updateCleaningModeUI() {
        /// 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        /// 修改设置清扫模式（cleaningMode）按钮的样式
        updateClearingAreaButton()
        /// 修改地图的清扫模式
        updateSweeperHomeMapViewCleanMode()
        /// 根据获取到的cleaningMode中区域清扫的ID，更新地图区域的清扫顺序数组
        updateSelectedLayerID()
        /// 修改定制清扫/边扫边拖属性 - 通过回调去更新该属性更新后主页后续的UI。回调中调用的方法 - updateSweeperCustomOrAutoMode()
        updateConfigurationView()
        /// 修改定制清扫/边扫边拖按钮的样式
        updateParamUI()
        /// 修改定制清扫/边扫边拖地图的样式
        updateSweeperHomeMapViewCustomOrAutoMode()
    }

    private func showAlertWithWholeHouseClean() {
        showAlertWith(title: "进行一次全屋清扫", message: "清扫完成后，将建立家居地图。", messageTextAlignment: .center, defaultButtonTitle: "进行全屋清扫", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonHandler: nil) { [weak self] (_) in
            self?.showSweepTipsAlert()
        }
    }

    private func startFastMap() {
        if sweeperControl?.basicState?.mainState == .remoteControl {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFastMapDuringRemoteControl))
            return
        }
        if sweeperControl?.basicState?.mainState == .assignLocation {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFAstMapDuringAssignLocation))
            return
        }
        // 强制扫地机进入新建快速地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .fastMap)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: self.deviceID, channel: self.channel, listType: self.listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func startFastMapAlert() {
        let alert = SweeperTipsAlert(type: .fastMap) { [weak self] () in
            guard let self = self else { return }
            self.startFastMap()
        }
        alert.show()
    }

    private func showAlertWithFastMapEnd() {
        showAlertWith(title: "尚未得到完整地图，确定要结束吗？", message: nil, messageTextAlignment: .center, defaultButtonTitle: "结束建图", defaultButtonColor: .theme1, cancelButtonTitle: "继续", cancelButtonHandler: nil) { [weak self] (_) in
            self?.setCleaningMode(type: .stop)
        }
    }

    private func showSweepTipsAlert() {
        let alert = SweeperTipsAlert(type: .clean) { [weak self] () in
            self?.setCleaningMode(type: .sweeping)
        }
        alert.show()
    }

    private func setCleaningMode(type: SweeperProcedure) {
        switch type {
        case .sweeping:
            if sweeperControl?.basicState?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringRemoteControl))
                return
            }
            if sweeperControl?.basicState?.mainState == .assignLocation {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringAssignLocation))
                return
            }
            // 若扫地机当前无地图，则所有“清扫”操作为全屋清扫。
            if map?.currentMapID == noMapID {
                self.cleaningMode = SweeperCleaningMode.init(type: .autoClean)
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: SweeperCleaningMode.init(type: .autoClean)).catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
                return
            }

            if cleaningModeType == .areaClean {
                if selectedLayerID.count == 0 {
                    ToastView.showWarningToast(title: "请选择需要清扫的区域", existTime: nil, centerY: .low)
                    return
                }
                sweeperControl?.cleaningMode.areaIDs = selectedLayerID
            } else if cleaningModeType == .pointClean,
                      let partArea = mapView.getSelectionRect() {
                // 若能够从SelectionRect获取到数据，则修改cleaningMode的PointRect
                sweeperControl?.cleaningMode.leftTopPoint = partArea.leftTopPoint
                sweeperControl?.cleaningMode.rightBottomPoint = partArea.rightBottomPoint
            } else {
                sweeperControl?.cleaningMode = .init(type: .autoClean)
            }

            ToastView.showLoadingToast(cirleWithMessage: nil)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: sweeperControl?.cleaningMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .sweepingPause, .fastMapPause:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .pause)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .stop:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .stop)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .fastMap:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .fastMap)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func saveMapSingleFloor() {
        let deleteMapID = map?.allMapNames.keys.first(where: { (mapID) -> Bool in
                  return mapID != temporaryMapID
              })
        guard let sweeperControl = sweeperControl,
              let deleteMapID = deleteMapID,
              let deleteMapName = map?.allMapNames[deleteMapID] else {
            return
        }
        showAlert(title: "是否保存新地图?", buttons: [
            .init(style: .default, text: "更新“(deleteMapName)”", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                ToastView.showLoadingToast(cirleWithMessage: "正在更新")
                SweeperService.deleteMap(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: deleteMapID).then { (_) in
                    ToastView.showWarningToast(title: "更新成功", existTime: nil, centerY: .low)
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
            }),
            .init(style: .default, text: "另存为新地图", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let alert = SweeperSelectionAlert(title: "相同环境请勿保存多张地图，有可能影响机器人的定位。", message: "我家为多楼层户型") {
                    guard self?.isCurrentMapSaved() == true else {
                        ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                        return
                    }
                    ToastView.showLoadingToast(cirleWithMessage: "正在保存")
                    SweeperService.setMultiFloorEnabled(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, enabled: true, mapID: nil).always {
                        ToastView.dismissLoadingToast()
                    }.then { _ in
                        ToastView.showWarningToast(title: "保存成功", existTime: nil, centerY: .low)
                    }.catch { (error) in
                        ToastView.showWarningToast(warningMessage: error.localizedDescription)
                    }
                } cancelHandler: { [weak self] () in
                    self?.saveMapSingleFloor()
                }
                alert.show()
            }, isPreferred: true),
            .init(style: .default, text: LocalizedString(key: notSaveMap))
        ])
    }

    private func saveMapMultiFloor() {
        showAlert(title: "地图数量已达上限，是否保存新地图？", message: "如点击“保存”，请选择新地图要覆盖哪张旧地图。", messageTextAlignment: .center, buttons: [
            .init(style: .default, text: LocalizedString(key: notSaveMap), color: .theme1),
            .init(style: .default, text: "保存", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let vc = SweeperCoverOldMapController()
                vc.sweeperControl = self?.sweeperControl
                self?.navigationController?.pushViewController(vc, animated: true)
            }, isPreferred: true)
        ])
    }

    private func isCurrentMapSaved() -> Bool {
        return map?.currentMapID == temporaryMapID
    }

    /// preMapID 为 nil，表示为第一次赋值
    private func currentMapDidChanged(preMap: SweeperMap?) {
        guard let map = map else {
            return
        }
        // 展示波纹动画条件： 1. 当前地图id为-2
        //                 2. 当前主状态为清扫中
        //                 3. 第一次进入主页面
        //                 4. 当前无地图I帧
        let needShowRobotWave = map.currentMapID == noMapID && sweeperControl?.basicState?.mainState == .cleaning && (preMap == nil || !hadStartWaveAnimation) && sweeperControl?.hadFrame == false
        if needShowRobotWave {
            startWaveAnimation()
        }
        /// preMapID 从 nil -> 0，未处理后退出主页重新进入
        /// 或 从 “-1” -> 0  表示成功创建，但还未自动保存新地图
        let preMapID = preMap?.currentMapID
        if (preMapID == nil || preMapID == isCreatingMapID) && map.currentMapID == temporaryMapID {
            ///  生成临时地图： 需要判断是多楼层还是单楼层来决定保存方式；
            guard let multiFloorEnabled = sweeperControl?.multiFloorEnabled, let maxMapNumber = sweeperControl?.capability?.maxMapNumber else {
                return
            }
            if multiFloorEnabled {
                if map.mapNumber > maxMapNumber && maxMapNumber > 0 && map.currentMapID == temporaryMapID {
                    // 地图已达上限且能力集中多楼层地图上限不为0，且当前地图是临时地图时，展示多楼层地图上限弹窗
                    needShowSaveMapMultiFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            } else {
                if map.mapNumber > 1 && map.currentMapID == temporaryMapID {
                    // 已经有一张地图且当前地图时临时地图时，展示单楼层地图上限弹窗。
                    needShowSaveMapSingleFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            }
            return
        }

        /// 成功创建，mapID 从 “-1” -> 大于0
        if preMapID == isCreatingMapID && map.currentMapID != noMapID && map.currentMapID != temporaryMapID && map.allMapNames.count == (preMap?.allMapNames.count ?? 0) + 1 {
            ///  生成完整地图：直接进入“已自动保存逻辑”
            needShowMapHasSavedTip = true
        }
    }

    private func showMapNotCompletedAlert(alertMessage: String, cancelHandler: ((UIAlertAction) -> Void)? = nil, defaultHandler: (() -> Void)? = nil) {
        showAlertWith(title: alertMessage, message: nil, messageTextAlignment: nil, defaultButtonTitle: "查看帮助", defaultButtonColor: .theme1, cancelButtonTitle: "关闭", cancelButtonColor: .theme1, cancelButtonHandler: cancelHandler, defaultButtonHandler: { [weak self] (_) in
            let vc = SweeperMapHelpViewController(type: .incomplete)
            self?.navigationController?.pushViewController(vc, animated: true)
            defaultHandler?()
        })
    }

    private func showCanNotCustomCleanAlert(isCreatingMap: Bool, defaultButtonhandler: ((UIAlertAction) -> Void)? = nil) {
        if isCreatingMap {
            showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持定制清扫", defaultHandler: { [weak self] () in
                self?.configurationView?.dismiss()
            })
        } else {
            showAlertWith(title: "请创建地图后再设置定制清扫", defaultButtonTitle: SharedResource.sharedFormatString(key: commonSure), defaultButtonColor: UIColor.black, cancelButtonTitle: nil, defaultButtonHandler: defaultButtonhandler)
        }
    }

    func showFastMapGuideView() {
        if fastMapImageView == nil {
            fastMapImageView = UIImageView()
            fastMapImageView?.image = UIImage.image(named: "quick_build_map")
            fastMapImageView?.sizeToFit()
        }
        guard let imageView = fastMapImageView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            fastMapGuideView?.dismiss()
            var offset: CGFloat = defaultButtonInterval
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            fastMapGuideView = presentGuideWith(viewToPresent: imageView, size: imageView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    func showMapHasSavedTip() {
        if savedMapNoticeView == nil {
            savedMapNoticeView = UIImageView()
            savedMapNoticeView?.image = UIImage.image(named: "edit_map")
            savedMapNoticeView?.sizeToFit()
        }
        guard let noticeView = savedMapNoticeView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            saveMapGuideView?.dismiss()
            var offset: CGFloat = 0
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            saveMapGuideView = presentGuideWith(viewToPresent: noticeView, size: noticeView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    override func collectionViewCell(_ cell: SweeperGlobalCleaningConfigurationCollectionViewCell, didSelectItemAt indexPath: IndexPath) {
        super.collectionViewCell(cell, didSelectItemAt: indexPath)

        let itemIndex = indexPath.section
        let row = indexPath.row
        let parameter = settingItems[itemIndex].paramters[row].type
        if parameter == .suctionForce(.none) {
            showAlertWith(title: "静音模式下吸尘能力将暂时降低，仅本次清扫任务生效。", message: nil, messageTextAlignment: nil, defaultButtonTitle: "确定", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonColor: .black, cancelButtonHandler: nil) { [weak self] (_) in
                self?.setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
            }
        } else {
            setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
        }
    }

    func setGlobalConfig(parameter: SweeperGlobalConfigurationType, itemIndex: Int) {
        var pendingConfig = sweeperControl?.globalCleaningConfig

        switch parameter {
        case .suctionForce(_):
            pendingConfig?.suction = parameter
        case .waterYield(_):
            pendingConfig?.waterYield = parameter
        case .sweepTimes(_):
            pendingConfig?.cleanTimes = parameter
        case .cleanMethod(_):
            pendingConfig?.cleanMethod = parameter
        case .mopMode(_):
            pendingConfig?.mopMode = parameter
        }


        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setGlobalCleaningConfig(device: deviceID, channel: channel, listType: listType, config: pendingConfig).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.then { [weak self] (_) in
            self?.sweeperControl?.globalCleaningConfig = pendingConfig
            self?.configurationView?.collectionView.reloadData()
            self?.updateParamUI()
        }
    }

    func startWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        let animationView = SweeperStartCleanAnimationView(frame: .zero)
        view.addSubview(animationView)

        animationView.snp.makeConstraints { make in
            make.centerX.equalToSuperview().offset(28)
            make.centerY.equalToSuperview().multipliedBy(0.764).offset(28)
            make.width.height.equalTo(56)
        }
        self.startCleanAnimationView = animationView
        animationView.startAnimation()
        hadStartWaveAnimation = true
    }

    func stopWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        startCleanAnimationView = nil
        hadStartWaveAnimation = false
    }

    private func cleanAllFlag() {
        needEntrySaveMapLogic = true
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true
        needShowMapHasSavedTip = false
        needShowSaveMapMultiFloor = false
        needShowSaveMapSingleFloor = false
        needEntrySaveMapLogicAfterBasicStateChanged = false
    }
}

// MARK: Button Action
private extension SweeperMainViewController {
    @objc func paramterButtonDidClick() {
        configurationView?.isSetSeq = isSetSweepSeq()
        configurationView?.isSetPreference = isSetPreference()
        configurationView?.show(view: self.navigationController?.view)
    }

    @objc func clearAreaButtonDidClick() {
        sweepAreaPopView = SweeperClearAreaPopView(type: cleaningModeType)
        sweepAreaPopView?.delegate = self
        sweepAreaPopView?.show()
    }

    @objc func startButtonDidClick() {
        guard (map?.currentMapID) != nil  else {
            return
        }
        if sweeperControl?.dataLoadingState == .success {
            setCleaningMode(type: .sweeping)
        } else {
            showAlertWithWholeHouseClean()
        }
    }

    @objc func stopButtonDidClick() {
        if status == .fastMapPause || status == .fastMap {
            showAlertWithFastMapEnd()
        } else {
            setCleaningMode(type: .stop)
        }
    }

    @objc func pasueButtonDidClick() {
        if status == .sweepingPause {
            setCleaningMode(type: .sweeping)
        } else if status == .fastMapPause {
            setCleaningMode(type: .fastMap)
        } else {
            setCleaningMode(type: .sweepingPause)
        }
    }

    @objc func previewButtonDidClick() {
        guard let mediaState = sweeperControl?.mediaState, checkEntryCondition() else {
            return
        }
        checkMediaStateAndJump(state: mediaState)
    }

    func checkMediaStateAndJump(state: SweeperMediaState) {
        // 若为被分享端，则不判断，直接进入人工驾驶页面
        if isSharedDevice {
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            vc.needShowSettingButton = false
            navigationController?.pushViewController(vc, animated: true)
            return
        }

        switch state {
        case .closed, .open:
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        case .openWithPermission:
            if sweeperControl?.mediaEncryptEnabled == true {
                // 视频加密开启，直接验证密码
                checkUnAuthenticated()
                return
            }
            // 视频加密关闭，需要检测设备空密码
            ToastView.showLoadingToast(cirleWithMessage: nil)
            requestCheckEmptyPassword {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func checkEntryCondition() -> Bool {
        if state?.collectDust == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterCollectionDust))
            return false
        }
        if state?.mopWashState == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterWashingMop))
            return false
        }
        return true
    }

    @objc func baseStationButtonDidClick() {
        if sweeperControl?.basicState?.cleanSinkState != .stop {
            let vc = SweeperBaseStationCleanSinkViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        } else {
            let vc = SweeperBaseStationMainViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func moreButtonDidClick() {
        let vc = SweeperMoreActionViewController(deviceID: deviceID, listType: listType)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    @objc func editButtonDidClick() {
        // 大于0的地图数量为0时(无已保存地图)并且没有地图，不允许进入，若mapID为“-1”允许进入
        if sweeperControl?.mapWithoutZero?.count == 0 && sweeperControl?.map?.currentMapID == noMapID {
            // 若扫地机在清扫、建图时，展示暂无地图
            if (state?.cleanFinished ?? true) {
                let fastMapGuideSheet = SweeperFastMapSheet()
                fastMapGuideSheet.delegate = self
                fastMapGuideSheet.show()
            } else {
                ToastView.showWarningToast(title: "暂无地图", existTime: nil, centerY: .low)
            }
            return
        }

        let alertActionSheet = TPActionSheet.init(title: nil)
        let setRigionAction = TPActionSheetAction.init(title: "设置禁区/虚拟墙", detail: "设置不允许扫地机器人进入的区域", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }

            // 清扫过程中进入编辑禁区页面需要暂停扫地机
            if self.status == .sweeping || self.status == .fastMap {
                self.setCleaningMode(type: .sweepingPause)
            }
            // 回充过程中进入编辑进去页面需要设置为待机
            if self.state?.mainState == .recharge {
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setStandBy(deviceID: self.deviceID, listType: self.listType).always {
                    ToastView.dismissLoadingToast()
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }
            }
            // 指哪到哪和遥控时不允许进入禁区页面
            if self.state?.mainState == .assignLocation || self.state?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterMission))
                return
            }
            let vc = SweeperForbiddenAreaVirtualWallViewController(sweeperControl: self.sweeperControl)
            self.navigationController?.pushViewController(vc, animated: true)
        }

        let editMapAreaAction = TPActionSheetAction.init(title: "编辑地图区域", detail: "划分地图区域并进行标记", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }
            /// 清扫、快速建图中不允许进入编辑区域页面
            if self.status != .stop {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterCleaning))
                return
            }
            /// 正在创建地图中不允许进入编辑区域页面
            guard self.map?.currentMapID != isCreatingMapID else {
                self.showMapNotCompletedAlert(alertMessage: LocalizedString(key: sweeperMapIsNotCompleteForEditingArea))
                return
            }
            let vc = SweeperEditMapAreaViewController(sweeperControl: self.sweeperControl)
            vc.isSetPreferenceOrOrder = self.isSetPreference() || self.isSetSweepSeq()
            self.navigationController?.pushViewController(vc, animated: true)
        }


        let manageMapAction = TPActionSheetAction.init(title: "管理地图", style: .leftTitle) { [weak self] (_) in
            guard let self = self else {
                return
            }
            let vc = SweeperMapManagerViewController()
            vc.delegate = self
            vc.deviceID = self.deviceID
            vc.listType = self.listType
            self.navigationController?.pushViewController(vc, animated: true)
        }

        var editActionArray: [TPActionSheetAction] = []
        editActionArray = map?.currentMapID == noMapID ? [manageMapAction] : [setRigionAction, editMapAreaAction, manageMapAction]

        editActionArray.forEach { (action) in
            action.font = .projectFont(ofSize: 16)
            action.detailFont = .projectFont(ofSize: 12)
            alertActionSheet.addAction(action)
        }
        alertActionSheet.separatorColor = .cellSeparatorGray

        alertActionSheet.show()
    }

    @objc func settingBarButtonItemDidClick() {
        if let vc = SweeperSettingViewController.create() {
            vc.deviceID = deviceID
            vc.listType = listType
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func rechargeButtonDidClick() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setRechargeState(device: deviceID, channel: channel, listType: listType, enabled: !isRecharging).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperRobotOfflineViewDelegate {
    func offlineHelpButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.requiredService?.goToOfflineHelp(deviceID: sweeperControl.deviceID, cloudID: sweeperControl.cloudID, listType: sweeperControl.listType, navigator: self.navigationController)
    }

    func offlineRefreshButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
        SweeperModule.shared.refreshSweeperControl()
    }
}

extension SweeperMainViewController: SweeperClearAreaPopViewDelegate {
    func updateData(with type: CleaningModeType) {
        if map?.currentMapID == isCreatingMapID {
            switch type {
            case .areaClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持区域清扫")
            case .pointClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持选框清扫")
            case .autoClean:
                // DO NOTHING
                break
            case .partClean:
                // DO NOTHING
                break
            case .pause:
                // DO NOTHING
                break
            case .stop:
                // DO NOTHING
                break
            case .fastMap:
                // DO NOTHING
                break
            }
            sweepAreaPopView?.dismiss()
            return
        } else {
            if type == .areaClean {
                if map?.currentMapID != noMapID {
                    ToastView.showWarningToast(title: "请选择区域", existTime: nil, centerY: .low)
                }
            }
        }
        self.cleaningModeType = type
        sweepAreaPopView?.dismiss()
    }
}

// MARK: setup UI
private extension SweeperMainViewController {
    func setupNavigation() {

        navigationItem.title = deviceDetail?.alias ?? "扫地机器人"

        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
        addCustomNavigationLeftBarButtonItem(title: nil, image: SharedResource.sharedImage(named: "common_light_back_nor"))
    }

    func setupButtons() {
        var title: String
        var imageName: String
        if isSharedDevice {
            title = "遥控"
            imageName = "ptz"
        } else {
            title = "视频遥控"
            imageName = "preview_light_nor"
        }
        previewButton = SweeperButton(title: title, fontSize: 9, image: UIImage.image(named: imageName))
        let previewTap = UITapGestureRecognizer.init(target: self, action: #selector(previewButtonDidClick))
        previewButton?.addGestureRecognizer(previewTap)
        if let button = previewButton {
            self.view.bringSubviewToFront(button)
        }
        if let previewButton = previewButton {
            buttonContainerStackView.addArrangedSubview(previewButton)
        }

        editButton = SweeperButton(title: "编辑地图", fontSize: 9, image: UIImage.image(named: "map_black_nor"))

        let editTap = UITapGestureRecognizer.init(target: self, action: #selector(editButtonDidClick))
        editButton?.addGestureRecognizer(editTap)
        if let editButton = editButton {
            buttonContainerStackView.addArrangedSubview(editButton)
        }

        baseStationButton = SweeperButton(title: "基站", fontSize: 9, image: UIImage.image(named: "sweeper_home"))

        let stationTap = UITapGestureRecognizer.init(target: self, action: #selector(baseStationButtonDidClick))
        baseStationButton?.addGestureRecognizer(stationTap)
        if let baseStationButton = baseStationButton {
            buttonContainerStackView.addArrangedSubview(baseStationButton)
        }

        moreButton = SweeperButton(title: "更多", fontSize: 9, image: UIImage.image(named: "star"))

        let moreButtonTap = UITapGestureRecognizer.init(target: self, action: #selector(moreButtonDidClick))
        moreButton?.addGestureRecognizer(moreButtonTap)
        if let moreButton = moreButton {
            buttonContainerStackView.addArrangedSubview(moreButton)
        }

        [previewButton, editButton, baseStationButton, moreButton].forEach { button in
            button?.snp.makeConstraints { make in
                make.width.equalTo(44)
                make.height.equalTo(47)
            }
        }

        /* buttonContainerStackView */
        view.addSubview(buttonContainerStackView)
        buttonContainerStackView.axis = .vertical
        buttonContainerStackView.alignment = .center
        buttonContainerStackView.spacing = 12
        buttonContainerStackView.snp.makeConstraints { make in
            make.width.equalTo(44)
            make.top.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }

        /* createMapButton */
        createMapContainer = SweeperCreateMapView()
        if let createMapContainer = createMapContainer {
            view.addSubview(createMapContainer)

            let goldenRatio: CGFloat = 0.382
            createMapContainer.snp.makeConstraints { make in
                make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2).offset(-(88 * goldenRatio))
                make.centerX.equalToSuperview()
                make.width.equalTo(230)
            }
        }
        createMapContainer?.isHidden = true

        /* chargeButton */
        chargeButton = SweeperButton(title: "返回基站", fontSize: 9, image: UIImage.image(named: "robot_charger"), offsetToTop: 5)
        addContraint(for: chargeButton, trailingToSuperView: -defaultButtonPadding)
        chargeButton.isHidden = true
        chargeButton.snp.makeConstraints { make in
            if let sweeperAlarmView = sweeperAlarmViewController {
                make.bottom.equalTo(sweeperAlarmView.view.snp.top).offset(-defaultButtonPadding / 2)
            } else {
                make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding)
            }
        }
        let chargeTap = UITapGestureRecognizer.init(target: self, action: #selector(rechargeButtonDidClick))
        chargeButton.addGestureRecognizer(chargeTap)

        parameterButton = SweeperButton(title: LocalizedString(key: sweeperCleanSweepAndMop), fontSize: 9, image: UIImage.image(named: "mode_general"), offsetToTop: 5)
        addContraint(for: parameterButton, trailingToSuperView: -defaultButtonPadding, bottomToSuperView: nil)
        parameterButton.snp.makeConstraints { (make) in
            make.bottom.equalTo(chargeButton.snp.bottom)
        }

        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        parameterButton.addGestureRecognizer(paramTap)

    }

    func setupOfflineView() {
        let offlineView = SweeperRobotOfflineView(frame: .zero)
        offlineView.delegate = self
        self.view.addSubview(offlineView)

        let goldenRatio: CGFloat = 0.382
        offlineView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2)
        }
        equipmentOfflineView = offlineView
        equipmentOfflineView?.isHidden = true
    }

    func updateNavigation() {
        if firstTimeUpdateNavigationTitle {
            navigationTitleView = SweeperTitleBatteryView(title: deviceDetail?.alias ?? "扫地机器人", stateText: "", power: 0, charge: false)
            navigationTitleView.snp.remakeConstraints { make in
                make.height.equalTo(44)
                make.width.equalTo(screenWidth - 150)
            }
            navigationItem.titleView = navigationTitleView
            firstTimeUpdateNavigationTitle = false
        }

        let stateText = state?.stateDescription ?? "故障中"
        let battery = state?.battery ?? 0
        let isCharging = state?.mainState == .charging
        navigationTitleView.setState(stateText: stateText, power: battery, charge: isCharging)
    }

    func updateEnvironmentView() {
        temperatureView.text = temperatureText
        humidityView.text = humidityText
    }

    func updateChargeButton() {
        chargeButton.isHidden = !shouldShowChargeButton
        if isRecharging {
            chargeButton.setTitle(title: "停止回充", buttonImage: UIImage.image(named: "robot_charge_stop"))
        } else {
            chargeButton.setTitle(title: "返回基站", buttonImage: UIImage.image(named: "robot_charger"))
        }
        if forbiddenRechargeAndClean {
            chargeButton.titleLabel.textColor = .lightGray3Color.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = false
        } else {
            chargeButton.titleLabel.textColor = .black.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = true
        }
    }

    func setupLoadingView() {
        view.addSubview(loadingView)
        loadingView.delegate = self
        loadingView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(0.764)
        }
    }

    func setupMapView() {
        let mapSize = sweeperControl?.mapSize ?? CGSize(width: defaultMapWidth, height: defaultMapHeight)
        mapView = SweeperHomeMapView(frame: .zero, mapSize: mapSize)
        mapView.backgroundColor = UIColor.clear
        view.addSubview(mapView)
        mapView.delegate = self
        mapView.sweeperIconMapView.delegate = self
        mapView.datasource = self
        mapView.isHidden = true

        mapView.snp.makeConstraints { make in
            make.top.trailing.leading.equalToSuperview()
            make.bottom.equalTo(sweepControlView.snp.top)
        }
        setupTapGesture()
    }

    func setupTapGesture() {
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(didTaped(recognizer:)))
        self.mapView.addGestureRecognizer(tapGesture)
    }

    func setupSweeperAlarmView() {
        let sweeperAlarmViewController = SweeperAlarmBannerViewController()
        sweeperAlarmViewController.window(from: .mainPage)
        sweeperAlarmViewController.sweeperControl = self.sweeperControl

        self.addChild(sweeperAlarmViewController)
        view.addSubview(sweeperAlarmViewController.view)
        sweeperAlarmViewController.view.snp.makeConstraints { make in
            make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding / 2)
            make.leading.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }
        self.sweeperAlarmViewController = sweeperAlarmViewController
    }

    @objc func didTaped(recognizer: UITapGestureRecognizer) {
        captureBubbleViewDismiss()
    }

    func setupEnvironmentView() {
        view.addSubview(environmentView)

        environmentView.snp.makeConstraints { make in
            make.height.equalTo(36)
            make.leading.top.equalToSuperview().offset(12)
        }
        environmentView.backgroundColor = .lightGray3Color.withAlphaComponent(0.1964)
        environmentView.layer.cornerRadius = 5

        [temperatureView, humidityView].forEach { label in
            environmentView.addSubview(label)

            label.backgroundColor = .clear
            label.textColor = .black.withAlphaComponent(0.6)
            label.textAlignment = .left
            label.font = .projectFont(ofSize: 10)
            label.snp.makeConstraints { make in
                make.height.equalTo(14)
                make.trailing.equalToSuperview().offset(-8)
                make.leading.equalToSuperview().offset(8)
            }
        }

        temperatureView.snp.makeConstraints { make in
            make.top.equalToSuperview().offset(4)
        }
        temperatureView.text = temperatureText

        humidityView.snp.makeConstraints { make in
            make.top.equalTo(temperatureView.snp.bottom)
        }
        humidityView.text = humidityText
    }

    func setupControlView() {
        addConstraint(forBottomView: sweepControlView, height: nil)
        sweepControlView.isHidden = true
        sweepControlViewHeightConstraint = NSLayoutConstraint(item: sweepControlView,
                                                             attribute: .height,
                                                             relatedBy: .equal,
                                                             toItem: nil,
                                                             attribute: .notAnAttribute,
                                                             multiplier: 1.0,
                                                             constant: 0)
        sweepControlViewHeightConstraint?.isActive = true

        // button clicked
        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        sweepControlView.parameterButton?.addGestureRecognizer(paramTap)

        let clearTap = UITapGestureRecognizer.init(target: self, action: #selector(clearAreaButtonDidClick))
        sweepControlView.clearAreaButton?.addGestureRecognizer(clearTap)

        let startTap = UITapGestureRecognizer.init(target: self, action: #selector(startButtonDidClick))
        sweepControlView.startButton.addGestureRecognizer(startTap)

        let stopTap = UITapGestureRecognizer.init(target: self, action: #selector(stopButtonDidClick))
        sweepControlView.stopButton.addGestureRecognizer(stopTap)

        let pauseTap = UITapGestureRecognizer.init(target: self, action: #selector(pasueButtonDidClick))
        sweepControlView.pauseButton.addGestureRecognizer(pauseTap)

    }

    func setupUpgradingView() {
        view.addSubview(sweeperBaseUpgradingView)
        sweeperBaseUpgradingView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingUpgradingView = false
    }

    func setupMechanicalOffView() {
        view.addSubview(sweeperMechanicalOffView)
        sweeperMechanicalOffView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingMechanicalView = false
        sweeperMechanicalOffView.delegate = self
    }

    func addConstraint(forBottomView bottomView: UIView?, height: CGFloat?) {
        guard let bottomView = bottomView else {
            return
        }
        bottomView.translatesAutoresizingMaskIntoConstraints = false

        view.addSubview(bottomView)

        // UI中设置的阴影radius为12，此处设置为8，才能与UI的效果一致。
        let shadowRadius: CGFloat = 8
        bottomView.layer.shadowOffset = .init(width: 0, height: 2)
        bottomView.layer.shadowRadius = shadowRadius
        bottomView.layer.shadowColor = UIColor.black.cgColor
        bottomView.layer.shadowOpacity = 0.16

        NSLayoutConstraint(item: bottomView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .width,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        if let height = height {
            NSLayoutConstraint(item: bottomView,
                               attribute: .height,
                               relatedBy: .equal,
                               toItem: nil,
                               attribute: .notAnAttribute,
                               multiplier: 1.0,
                               constant: height).isActive = true
        }

        NSLayoutConstraint(item: bottomView,
                           attribute: .bottom,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .bottom,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        NSLayoutConstraint(item: bottomView,
                           attribute: .centerX,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .centerX,
                           multiplier: 1.0,
                           constant: 0).isActive = true
    }

    func addContraint(for subView: UIView?, trailingToSuperView: CGFloat, topToSuperView: CGFloat? = nil, bottomToSuperView: CGFloat? = nil) {
        guard let subView = subView else {
            return
        }

        view.addSubview(subView)
        subView.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint(item: subView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 44).isActive = true
        NSLayoutConstraint(item: subView,
                           attribute: .height,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 47).isActive = true
        if let topToSuperView = topToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .top,
                               relatedBy: .equal,
                               toItem: view,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: topToSuperView).isActive = true
        }

        if let bottomToSuperView = bottomToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .bottom,
                               relatedBy: .equal,
                               toItem: bottomLayoutGuide,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: bottomToSuperView).isActive = true
        }

        NSLayoutConstraint(item: subView,
                           attribute: .trailing,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .trailing,
                           multiplier: 1.0,
                           constant: trailingToSuperView).isActive = true
    }
}

/// receive bitmap data
extension SweeperMainViewController: SweeperMapMediaPlayerListener {
    func mediaPlayerConnected(connectedSuccess: Bool) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if !connectedSuccess {
            dataLoadingStateChangeAction(loadingState: .failed)
        }
    }

    func dataLoadingStateChanged(loadingState: SweeperDataLoadingState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        dataLoadingStateChangeAction(loadingState: loadingState)
    }

    func mediaPlayerBitmapDataUpdate(dataType: MapMediaPlayerFrameFormat) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        /// 对扫地机地图正处于拖动或缩放时地图的刷新进行限制，避免卡顿的情况。
        guard !mapView.isOperation else {
            return
        }
        if dataType == .map {
            // 第一次收到I帧
            if sweeperControl?.hadFrame == true {
                stopWaveAnimation()
            }
            mapView.sweeperBitmapView.refreshBitmapImage()
            mapView.sweeperAreaView.refreshAreaView()
            if needRefreshMapViewInMediaPlayer {
                needRefreshMapViewInMediaPlayer = false
                mapView.refreshView()
            }
        }

        if sweeperControl?.hadFrame == true && dataType == .path {
            mapView.sweeperRouteView.refreshRouteView()
            // refresh equipment icon and charger pile location.
            mapView.sweeperIconMapView.refreshIconView()
        }
    }

    func mediaPlayerSignalling(mapID: String, type: SweeperConfigUpdateType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if type == .cleaningState {
            updateCleaningStateUI()
        } else if type == .cleaningMode || type == .cleanParam {
            updateCleaningModeUI()
        } else if type == .areaCleaning {
            mapView.updateCustomOrAutoMode()
            mapView.refreshAreaAndLabelView()
        } else if type == .globalCleaningConfig {
            // 修改全局清扫配置
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                cleanMethodMode = mode
                configurationView?.collectionView.reloadData()
            }
        } else {
            mapView.refreshView()
            mapView.refreshAreaAndLabelView()
        }
    }

    func mediaPlayerBasicStateDidChanged(preState: SweeperState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        basicStateChangeAction(showToast: true)
        sweeperAlarmViewController?.showAlarm()
        sweeperAlarmViewController?.showNotify()

        // 当前扫地机清扫结束时，若需要进入地图保存逻辑，则重新进入
        if !preState.cleanFinished && state?.cleanFinished == true && needEntrySaveMapLogicAfterBasicStateChanged {
            currentMapDidChanged(preMap: nil)
            saveMapLogic()
            needEntrySaveMapLogicAfterBasicStateChanged = false
        }
    }

    func mediaPlayerMapIDDidChanged(preMap: SweeperMap) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        currentMapDidChanged(preMap: preMap)

        /// 每次修改current map id 后， 地图的大小都会发生变化，故需要刷新初始地图的大小以适应屏幕
        mapView.restoreInitalMapView()
        mapView.shouldRefreshSize = true
        mapView.refreshView()
        mapView.updateCleanningModeAndSweepingState()
        mapView.updateCustomOrAutoMode()
        mapView.refreshAreaAndLabelView()
    }

    func mediaPlayerAlarm(type: SweeperAlarmType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        let alarm = SweeperAlarm(type: type)

        // 当前alarm需要在主页面显示、当基站升级、开关断开时不展示
        guard alarm.window.contains(.mainPage) && sweeperMechanicalOffView.isHidden && sweeperBaseUpgradingView.isHidden else {
            return
        }

        // 展示Toast
        if alarm.rank.contains(.toast),
           let message = alarm.toastTitle {
            ToastView.showWarningToast(title: message, existTime: nil, centerY: .low)
            return
        }

        // 展示Dialog，不展示只在基站展示的dialog
        if alarm.rank.contains(.dialog),
           !SweeperAlarm.baseDialogTypes.contains(type),
           let title = alarm.toastTitle {
            showAlertWith(title: title, message: alarm.toastContent, messageTextAlignment: .center, defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil, cancelButtonHandler: nil, defaultButtonHandler: nil)
            return
        }
    }
}

extension SweeperMainViewController: SweeperMapViewDataSource {
    func area(_ view: UIView, customCleanConfigurationIn areaID: Int) -> SweeperGlobalCleaningConfiguration? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaCleaningConfiguration
    }

    func area(_ view: UIView, infomationLayerMarkIn areaID: Int) -> String? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaLabel
    }

    func areaIDSet(_ in: UIView) -> [Int]? {
        return sweeperControl?.mapModel?.areaModel.areaIDs
    }

    func areaLabelLocation(_ view: UIView, areaID: Int) -> CGPoint? {
        return sweeperControl?.mapModel?.areaModel.areaLabelLocation[areaID]
    }

    func bitmapImage(_ view: UIView) -> CGImage? {
        return sweeperControl?.mapModel?.bitmapImage()
    }

    func bitmapOffset(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.offset
    }

    func bitmapSize(_ view: UIView) -> CGSize? {
        return sweeperControl?.mapModel?.bitmapSize
    }

    func areaData(_ view: UIView) -> [UInt8]? {
        return sweeperControl?.mapModel?.areaModel.areaData
    }

    func routeAllPointArray(_ view: UIView) -> [RoutePoint]? {
        return sweeperControl?.routeModel?.routePoints
    }

    func virtualWallIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.virtualWallModel?.wallIDs
    }

    func virutalWall(_ view: UIView, wallID: Int, isInEditMap: Bool) -> (CGPoint, CGPoint)? {
        return sweeperControl?.virtualWallModel?.couplePiontDictionary[wallID]
    }

    func forbiddenAreaIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.forbiddenAreaModel?.areaIDs
    }

    func forbiddenArea(_ view: UIView, areaID: Int, isInEditMap: Bool) -> RectangleArea? {
        return sweeperControl?.forbiddenAreaModel?.couplePiontDictionary[areaID]
    }

    func equipmentLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.routeModel?.equipmenLocation
    }

    func equipmentAngle(_ view: UIView) -> CGFloat? {
        return sweeperControl?.routeModel?.equipmenOritention
    }

    func chargePileLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.chargePileLocation
    }

    func barrierIDSet(_ view: UIView) -> [Int]? {
        if let keys = sweeperControl?.barriersModel?.barrierDictionary.keys {
            return Array(keys)
        } else {
            return nil
        }
    }

    func barrier(_ view: UIView, barrierModelIn barrierID: Int) -> SweeperBarrier? {
        return sweeperControl?.barriersModel?.barrierDictionary[barrierID]
    }

    func rectClean(_ view: UIView) -> (leftTopPoint: CGPoint, rightBottomPoint: CGPoint)? {
        if cleaningMode.leftTopPoint != .zero && cleaningMode.rightBottomPoint != .zero {
            return (cleaningMode.leftTopPoint, cleaningMode.rightBottomPoint)
        } else {
            return nil
        }
    }

    func mapScale(_ view: UIView) -> CGFloat? {
        return sweeperControl?.capability?.mapScale
    }
}

extension SweeperMainViewController: SweeperHomeMapViewDelegate {
    func hadMapFrame(_ view: SweeperHomeMapView) -> Bool? {
        return sweeperControl?.hadFrame
    }

    func areaSelected(_ view: SweeperHomeMapView) -> [Int]? {
        if cleaningModeType == .areaClean {
            return selectedLayerID
        } else {
            return nil
        }
    }

    func homeMapViewIsSetPreference(_ view: SweeperHomeMapView) -> Bool {
        return isSetPreference()
    }

    func homeMapViewIsSetSeq(_ view: SweeperHomeMapView) -> Bool {
        return isSetSweepSeq()
    }

    func layer(_ view: SweeperHomeMapView, layerSelectedSequence layerID: Int) -> Int? {
        if cleaningModeType == .areaClean, let orderID = selectedLayerID.firstIndex(of: layerID) {
            return orderID
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, layerCleaningOrder layerID: Int) -> Int? {
        if let order = sweeperControl?.mapModel?.areaModel.areaCleaningOrder,
           let orderID = order.firstIndex(of: layerID) {
            return orderID + 1
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, selectedLayer layerID: Int) {
        if let index = selectedLayerID.firstIndex(of: layerID) {
            selectedLayerID.remove(at: index)
        } else {
            selectedLayerID.append(layerID)
        }
        if cleaningModeType == .areaClean && !selectedLayerID.isEmpty {
            ToastView.showWarningToast(title: "已选择(selectedLayerID.count)个区域", existTime: nil, centerY: .low)
        }
        updateClearingAreaButton()
        mapView.refreshAreaAndLabelView()
    }
}

extension SweeperMainViewController {

    // 物体抓拍气泡展示
    private func captureBubbleViewShow(captureView: UIImageView, titleText: String, iconImage: UIImage, status: CaptureImageLoadingStatus, obstacleID: Int, thumbnail: UIImage? = nil) {
        sweepCaptureView.removeFromSuperview()
        captureBubbleViewLayout(captureView: captureView)
        sweepCaptureView.delegate = self

        // 更新障碍物抓拍气泡的展示
        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: thumbnail, obstacleID: obstacleID)

        // 更新障碍物抓拍是否有缩略图以及缩略图状态
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl?.barrierRecognitionEnabled ?? false, captureImageStatus: status)

        self.view.layoutIfNeeded()
        self.autoSuitPosition()
    }

    private func captureBubbleViewLayout(captureView: UIImageView) {
        self.mapView.addSubview(sweepCaptureView)
        sweepCaptureView.snp.remakeConstraints { make in
            make.centerX.equalTo(captureView.snp.centerX)
            make.bottom.equalTo(captureView.snp.top).offset(-12)
            make.width.equalTo(159)
            if sweeperControl?.barrierRecognitionEnabled ?? false {
                make.height.equalTo(128)
            } else {
                make.height.equalTo(40)
            }
        }
    }

    // 物体抓拍气泡隐藏
    private func captureBubbleViewDismiss() {
        sweepCaptureView.dismiss()
    }

    private func autoSuitPosition() {
        var offsetX: CGFloat = 0
        var offsetY: CGFloat = 0
        let maxXCoordinate = mapView.frame.width - sweepCaptureView.frame.width - 16
        if sweepCaptureView.frame.origin.x < 16 {
            offsetX = 16 - sweepCaptureView.frame.origin.x
        } else if sweepCaptureView.frame.origin.x > maxXCoordinate {
            offsetX = maxXCoordinate - sweepCaptureView.frame.origin.x
        }

        if sweepCaptureView.frame.origin.y < 16 {
            offsetY = 16 - sweepCaptureView.frame.origin.y
        }
        // 不用考虑底部超出边界，因为弹窗从顶部出现

        mapView.moveBy(x: offsetX, y: offsetY)
    }

    /// 刷新当前正在展示的气泡及其内容
    private func refreshBubbleView() {
        guard let sweeperControl = sweeperControl,
              let obstacleID = obstacleID,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              let iconImage = barrier.type.bigImage,
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            captureBubbleViewDismiss()
            return
        }
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
            return
        }

        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: .loading)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { [weak self] (status, image) in
            self?.sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: image, obstacleID: obstacleID)
            self?.sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: status)
        }
    }

}

extension SweeperMainViewController: SweeperMapManagerViewControllerDelegate {
    func mapManagerBeginSweep(_ controller: SweeperMapManagerViewController) {
        // 强制扫地机进入新建地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .autoClean)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    func mapManagerFastMap(_ controller: SweeperMapManagerViewController) {
        // 开始快速建图
        startFastMapAlert()
    }
}

extension SweeperMainViewController: SweeperCaptureBubbleViewDelegate {
    func captureNextButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.titleLabel.textColor = UIColor.black.withAlphaComponent(0.5)
        // 获取全部障碍物的详情页
        let sweepCaptureNextPageViewController = SweeperCaptureNextPageViewController(deviceID: deviceID, listType: listType)
        sweepCaptureNextPageViewController.delegate = self

        // 更新详情页跳转到具体哪个页面
        sweepCaptureNextPageViewController.obstacleID = captureView.obstacleID
        self.navigationController?.pushViewController(sweepCaptureNextPageViewController, animated: true)
    }

    func reloadButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.imageStatus = .loading
        let barrierID = captureView.obstacleID
        guard let fileID = sweeperControl?.barriersModel?.barrierDictionary[barrierID]?.fileID else {
            return captureView.imageStatus = .loadNoImage
        }

        SweeperDownloader.downloadObstacleImage(forDevice: deviceID, listType: listType, fileID: fileID) { status, image in
            captureView.imageStatus = status
            captureView.titleImageView.image = image
        }
    }

    func handleGestures(enable: Bool) {
        mapView.isGestureEnable = enable
    }
}

extension SweeperMainViewController: SweeperMainMapLoadingViewDelegate {
    func reloadButtonDidClick(_ UIView: SweeperMainMapLoadingView) {
        refreshMediaPlayerAndSweeperControl()
    }
}

extension SweeperMainViewController: SweeperIconMapViewDelegate {
    func didTapBaseStation(in view: SweeperIconMapView) {
        baseStationButtonDidClick()
    }

    func iconMap(_ view: SweeperIconMapView, transforToScreenPointFrom realPoint: CGPoint) -> CGPoint? {
        // 之前未调用
        return nil
    }

    func didTapObstacle(in view: UIImageView, obstacleID: Int) {

        guard let sweeperControl = sweeperControl,
              let iconImage = sweeperControl.barriersModel?.barrierDictionary[obstacleID]?.type.bigImage,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            return
        }
        self.obstacleID = obstacleID
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loadNoImage, obstacleID: obstacleID)
            return
        }

        self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loading, obstacleID: obstacleID)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { status, image in
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: status, obstacleID: obstacleID, thumbnail: image)
        }
    }
}

extension SweeperMainViewController: SweeperNewPasswordProtocol {
    func checkUnAuthenticated() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperModule.shared.requiredService?.checkUserInfo(deviceID: deviceID, listType: listType, completion: { [weak self] (success, errorCode) in
            ToastView.dismissLoadingToast()
            guard let self = self else {
                return
            }
            if success {
                self.goToPreview()
                return
            }

            if errorCode == TPSS_ASYNC_EC_TIMEOUT || errorCode == TPSS_COMM_EC_SYSTEM {
                /* 请求超时 */
                ToastView.showWarningToast(warningMessage: "网络错误")
                return
            }

            /* 设备锁定 */
            if errorCode == TPSS_COMM_EC_PREVIEW_LOCKED {
                self.showAlertWith(title: SharedResource.sharedString(key: sweeperPreviewLockedAlertTitle), defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil)
                return
            }

            /* 鉴权失败,弹出密码输入框 */
            self.presentInputPasswordVC(deviceID: self.deviceID, listType: self.listType)

        })
    }
}

extension SweeperMainViewController: SweeperVerifyPasswordProtocol {
    func verifySuccessHandler() {
        goToPreview()
    }
}

extension SweeperMainViewController: SweeperCaptureNextPageViewControllerDelegate {
    func ignoreButtonDidClick(sweeperCaptureNextPageViewController: SweeperCaptureNextPageViewController, barrierID: Int) {
        // 点击障碍物抓拍详情页的“忽略”所对应的障碍物Id
        guard let mapID = map?.currentMapID else {
             return
        }
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestIgnoreBarrier(device: deviceID, channel: channel, listType: listType, barrierID: "(barrierID)", mapID: mapID).always {
            ToastView.dismissLoadingToast()
        }.then { [weak self] (_) in
            ToastView.showWarningToast(warningMessage: "已忽略该物体")
            self?.sweepCaptureView.dismiss()
            self?.goBackToSweeperMainViewController()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperMechanicalOffViewDelegate {
    func refreshButtonDidClick(in: SweeperMechanicalOffView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        sweeperMechanicalOffView.refreshLoadingUI(connectedState: .loading)
        view.bringSubviewToFront(sweeperMechanicalOffView)
        SweeperService.getSweeperState(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType).then { [weak self] (state) in
            guard let state = state else {
                return
            }
            self?.showMechanicalOffView(switchOn: state.mechanicalSwitchOn)
        }
    }

    func showMechanicalOffView(switchOn: Bool) {
        // 若开关关闭
        if !switchOn {
            isShowingMechanicalView = true
            sweeperMechanicalOffView.refreshLoadingUI(connectedState: .off)
        } else {
            isShowingMechanicalView = false
        }
    }
}

extension SweeperMainViewController: SweeperMoreActionViewControllerDelegate {
    func cleanWholeHouse(in vc: SweeperMoreActionViewController) {
        showSweepTipsAlert()
    }
}

extension SweeperMainViewController: SweeperFastMapSheetDelegate {
    func startFastMap(view: SweeperFastMapSheet) {
        startFastMapAlert()
    }
}

extension String {
    func separatedBySemiColon(isAutoFill: Bool = true) -> (String, String?) {
        let seperator = self.contains(":") ? ":" : "："
        let separatedTexts: [String] = self.components(separatedBy: seperator)
        if !isAutoFill && separatedTexts.count == 1 {
            return (separatedTexts[0], nil)
        } else {
            return (separatedTexts.count >= 1 ? separatedTexts[0] : "", separatedTexts.count >= 2 ? separatedTexts[1] : "")
        }
    }
}
//
//  OnlineDeviceListMasterViewController.swift
//  SurveillanceHome
//
//  Created by Li Linfeng on 2019/12/9.
//  Copyright © 2019 tplink. All rights reserved.
//

import UIKit
import SurveillanceHomeBase
import SharedResource
import TPFoundation
import DeviceDetailModule
import NetService

private var pageIndexAssociatedObjectHandle: UInt8 = 0

final class OnlineDeviceListMasterViewController: BaseViewController {
    @IBOutlet private weak var groupCollectionView: UICollectionView!
    @IBOutlet private weak var groupToolbarShadowView: UIView!
    @IBOutlet private weak var groupToolbarContainer: UIView!
    @IBOutlet private weak var groupToolbarDropMenuButton: UIButton!
    @IBOutlet private weak var recentPreviewView: RecentPreviewView!
    @IBOutlet private weak var containerViewBottom2SuperViewBottomConstraint: NSLayoutConstraint!
    @IBOutlet private weak var containerViewTop2TopLayoutGuideBottomConstraint: NSLayoutConstraint!

    override var navigationBarTraits: [NavigationBarTrait] {
        return NavigationBarTrait.noSeparator
    }

    private var deviceGroups: [TPSSDeviceGroup] = []
    private var currentGroupIndex: Int = 0

    private var newCreateGroupName = ""

    private var pageController: UIPageViewController!
    private var deviceListVCCacheDictionary = [TPSSDeviceGroupID: OnlineDeviceListViewController]()
    private var transitionVCForPageController = UIViewController()
    lazy private var loginCacheVC = DeviceListLoginViewController.create()

    private var firstAppear = true
    private var shouldRecreate: Bool = false

    /// for routers' entry
    private var isLoginBefore = false

    var sdCardStatusShowed: SDCardStatusShowed = .none
    var diskStatusShowed: SDCardStatusShowed = .none

    // camera display
    private var shouldShowCameraDisplayNoActiveChannelAlert = false
    private var addChannelCameraDisplay: TPSSDeviceForDeviceList?

    // navigation
    private lazy var moreToolBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(moreToolsButtonClicked(_:)))
    }()

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_add_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(addDeviceButtonClicked(_:)))
    }()

    // MARK: guides and overlays
    private weak var addDeviceGuideView: GuidePresentationView?
    private weak var moreToolsPopoverView: GuidePresentationView?

    private lazy var groupPresenter = GroupListPresentationManager()
    private var presentedGroupList: GroupListViewController? {
        return presentedViewController as? GroupListViewController
    }

    private var currentList: OnlineDeviceListViewController {
        if let viewControllers = pageController.viewControllers, let firstViewController = viewControllers.first as? OnlineDeviceListViewController {
            return firstViewController
        }
        return OnlineDeviceListViewController()
    }

    private var isCloudLogin: Bool {
        return DeviceListModule.shared.requiredService?.isCloudLogin ?? false
    }

    private var isReordering = false                // 是否正在处于排序模式
    private var shouldToggleGroupModeAfterGetList = false   // 是否需要在获取列表结束后切换防护模式，仅在列表还未获取完时触发防护模式切换使用

    private var isShowing: Bool {
        return isShowing(ignorePresentedClasses: [UIAlertController.classForCoder()])
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        setupView()

        NotificationCenter.default.addObserver(self, selector: #selector(handleShowCameraDisplayNoActiveChannelAlertNotification(_:)), name: .ShowCameraDisplayNoActiveChannelAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleShowStorageDetectAlertNotification(_:)), name: .ShowStorageDetectAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListInvalidated), name: .DeviceListInvalidated, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListUpdated), name: .DeviceListUpdated, object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderBegined(_:)),
                                               name: .DeviceListReorderBegined,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderEnded(_:)),
                                               name: .DeviceListReorderEnded,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupAndDeviceList(_:)),
                                               name: .UpdateGroupAndDeviceListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: DeviceListNetworkObserver.localDeviceRefreshed,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupList(_:)),
                                               name: .UpdateGroupListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: .unbindDiscoveryFinished,
                                               object: nil)

        _ = DeviceListModule.shared.requiredService?.addEntrustObserver(observeTypes: [.entrustmentStop, .entrustmentExitByTrustee], { (_, _) in
            DeviceListManager.shared.updateDeviceList(of: DeviceListManager.shared.defaultGroupID).always {
                self.currentList.reload()
            }
        })
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        showGroupAndNavigationButton(true)
        if !isCloudLogin {
            showEmpty()
        } else if firstAppear {
            firstAppear = false
            restore()
        } else if shouldRecreate {
            shouldRecreate = false
            reload()
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        checkUpdateIfNeeded()

        if isCloudLogin {
            showPopoverGuideIfNeeded()
        }

        if shouldShowCameraDisplayNoActiveChannelAlert {
            shouldShowCameraDisplayNoActiveChannelAlert = false
            showCameraDisplayNoActiveChannelAlert()
        }
        updateGroupShadow()
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)

        dismissPresentedViews()
    }

    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let vc = segue.destination as? UIPageViewController {
            pageController = vc
            pageController.dataSource = self
            pageController.delegate = self
        }
    }

    private func refreshAfterGroupUpdated() {
        guard !isReordering else {
            return
        }

        guard isShowing else {
            // 如果分组刷新完，此时页面不是正在显示，则不进行页面刷新，仅记录状态，等回到本页面才统一进行刷新。
            // 需要注意通过记录状态后续回到页面才处理的逻辑，要与本方法后续处理逻辑要保持一致
            shouldRecreate = true
            return
        }

        reload()
    }

    private func showEmpty() {
        deviceGroups = []
        currentGroupIndex = -1

        showGroupAndNavigationButton(false)

        let emptyVC: UIViewController?
        // 有发现出来的/已绑定到局域网的设备时显示带登陆按钮的设备列表；没有则显示普通的登陆提示页
        if DeviceListManager.shared.unbindDetailDeviceList().count > 0 {
            emptyVC = createUnloginPage()
        } else {
            emptyVC = loginCacheVC
        }
        if let emptyVC = emptyVC {
            pageController.setViewControllers([emptyVC], direction: .forward, animated: false, completion: nil)
        }
        groupCollectionView.reloadData()
    }

    private func showGroupAndNavigationButton(_ shouldShow: Bool) {
        if shouldShow {
            navigationItem.leftBarButtonItem = moreToolBarButtonItem
            groupToolbarDropMenuButton.isHidden = false
        } else {
            navigationItem.leftBarButtonItem = nil
            groupToolbarDropMenuButton.isHidden = true
        }
    }

    private func restore() {
        deviceGroups = DeviceListManager.shared.groupList

        loadGroup(with: DeviceListManager.shared.lastSelectedGroupID)
    }

    private func reload(with preferredGroupID: String? = nil) {
        let oldGroupID = preferredGroupID ?? DeviceListManager.shared.lastSelectedGroupID
        deviceGroups = DeviceListManager.shared.groupList
        presentedGroupList?.groups = deviceGroups

        loadGroup(with: oldGroupID)
    }

    private func loadGroup(with groupID: String) {
        let currentGroup = DeviceListManager.shared.group(of: groupID) ?? DeviceListManager.shared.defaultGroup

        guard let groupIndex = deviceGroups.firstIndex(where: { $0.groupID == currentGroup.groupID }) else {
            return
        }

        currentGroupIndex = groupIndex

        presentedGroupList?.currentGroupID = currentGroup.groupID
        presentedGroupList?.reload()

        commonLoad()
    }

    private func commonLoad(animated: Bool = false, recreate: Bool = true) {
        groupCollectionView.reloadData()

        guard currentGroupIndex >= 0 else {
            return
        }

        groupCollectionView.scrollToItem(at: IndexPath(item: currentGroupIndex, section: 0), at: .right, animated: false)
        updateGroupShadow()

        if recreate, let vc = createPage(for: currentGroupIndex) {
            pageController.setViewControllers([vc], direction: .forward, animated: false, completion: nil)
        }

        storeGroupParameter()
    }

    private func updateGroupShadow() {
        groupToolbarShadowView.isHidden = groupCollectionView.bounds.maxX >= (groupCollectionView.contentSize.width - 1)
    }

    private func refreshAllDeviceLists() {
        if let viewController = pageController.viewControllers {
            viewController.forEach {
                if let vc = $0 as? OnlineDeviceListViewController {
                    vc.reload()
                }
            }
        }
    }

    private func createPage(for index: Int) -> OnlineDeviceListViewController? {
        let group = deviceGroups[index]
        guard let vc = createPage(for: group.groupID as TPSSDeviceGroupID) else {
            return nil
        }
        objc_setAssociatedObject(vc, &pageIndexAssociatedObjectHandle, index, .OBJC_ASSOCIATION_COPY_NONATOMIC)
        vc.realGroup = deviceGroups[index]
        return vc
    }

    private func createUnloginPage() -> OnlineDeviceListViewController? {
        return createPage(for: "unlogin page")
    }

    private func createPage(for key: TPSSDeviceGroupID) -> OnlineDeviceListViewController? {
        let vc: OnlineDeviceListViewController?
        if let item = deviceListVCCacheDictionary[key] {
            vc = item
        } else {
            vc = OnlineDeviceListViewController.create()
            deviceListVCCacheDictionary[key] = vc
        }
        return vc
    }
}

extension OnlineDeviceListMasterViewController: DeviceListUnwindDestination {}

// MARK: Popover handler
extension OnlineDeviceListMasterViewController {
    private func updateMenu() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let networkAvailable = NetworkManager.shared.isConnected
        let isInHomeMode = deviceGroups[currentGroupIndex].activeMode != .goOut
        let isBigCardMode = deviceGroups[currentGroupIndex].displayMode != .smallCard
        let homeModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_home_active") : DeviceListModule.image(named: "devicelist_home_disabled")
        let outModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_out_active") : DeviceListModule.image(named: "devicelist_out_disabled")
        DeviceGroupMenuItem.alarmMode.image = (isInHomeMode ? homeModeImage : outModeImage)?.withRenderingMode(.alwaysOriginal)
        DeviceGroupMenuItem.alarmMode.enabled = networkAvailable
        DeviceGroupMenuItem.alarmMode.title = isInHomeMode ? LocalizedString(key: deviceListModeHome) : LocalizedString(key: deviceListModeOut)
        DeviceGroupMenuItem.alarmMode.subtitle = isInHomeMode ? LocalizedString(key: deviceListSwitchModeToOut) : LocalizedString(key: deviceListSwitchModeToHome)
        DeviceGroupMenuItem.viewMode.title = isBigCardMode ? LocalizedString(key: deviceListViewGrid) : LocalizedString(key: deviceListViewList)
        DeviceGroupMenuItem.viewMode.subtitle = isBigCardMode ? LocalizedString(key: deviceListSwitchViewToList) : LocalizedString(key: deviceListSwitchViewToGrid)
        DeviceGroupMenuItem.viewMode.image = isBigCardMode ?  DeviceListModule.image(named: "devicelist_grid")?.withRenderingMode(.alwaysOriginal) : DeviceListModule.image(named: "devicelist_list")?.withRenderingMode(.alwaysOriginal)
    }

    private func handleDeviceGroupMenu(item: DeviceGroupMenuView.Item) {
        switch item {
        case .alarmMode:
            toggleGroupMode()
        case .search:
            navigateToSearch()
        case .viewMode:
            toggleDisplayMode()
        }
    }

    private func toggleGroupMode() {
        dismissPresentedViews()

        let deviceListUpdateStatus = DeviceListManager.shared.deviceListUpdateStatus
        if !deviceListUpdateStatus.cloudUpdateNecessaryInfoFinished {
            // 列表必要信息没获取到，此时若需要改变防护模式，就先请求获取数据并且loading，等所有信息获取完处理，避免数据不完整导致处理出错
            if !deviceListUpdateStatus.isUpdatingList {
                DeviceListManager.shared.updateGroupAndDeviceList()
            }
            shouldToggleGroupModeAfterGetList = true
            ToastView.showLoadingToast(cirleWithMessage: nil)
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.activeMode
        let newMode = group.activeMode == .goOut ? TPSSDeviceGroupMode.atHome : .goOut
        group.activeMode = newMode
        ToastView.showLoadingToast(cirleWithMessage: nil)
        DeviceListManager.shared.changeActiveMode(with: deviceGroups[currentGroupIndex]).then { () in
            self.currentList.reload()
            self.currentList.showToastForActiveMode(newMode)
        }.catch { (_) in
            group.activeMode = originalMode
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func toggleDisplayMode() {
        dismissPresentedViews()

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.displayMode
        let newMode = originalMode == .bigCard ? DeviceUIDisplayType.smallCard : .bigCard

        DeviceListManager.shared.changeDisplayMode(for: group.groupID, with: newMode)

        for section in 0..<currentList.collectionView.numberOfSections {
            for item in 0..<currentList.collectionView.numberOfItems(inSection: section) {
                if newMode == .smallCard {
                    currentList.fold(at: IndexPath(row: item, section: section))
                } else {
                    currentList.unfold(at: IndexPath(row: item, section: section))
                }
            }
        }

        currentList.reload()
    }

    private func navigateToSearch() {
        dismissPresentedViews()
        let allDevices = DeviceListManager.shared.allDetailDevices
        let allGroups = DeviceListManager.shared.groupList
        let vc = RemoteDeviceListSearchViewController(devices: allDevices, groups: allGroups)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }
}

extension OnlineDeviceListMasterViewController {
    // MARK: Popover
    private func showPopoverGuideIfNeeded() {
        // add device popover
        if UserDefaults.standard.object(forKey: deviceListLaunchKey) == nil {
            showAddDevicePopover()
            UserDefaults.standard.set(true, forKey: deviceListLaunchKey)
        }
    }

    private func showAddDevicePopover() {
        if !isShowing() {
            /* 如果界面切换了不要加载 */
            return
        }
        if let source = (navigationItem.rightBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            navigationController?.navigationBar.layoutIfNeeded()
            dismissPresentedViews()
            addDeviceGuideView = presentGuideWith(viewToPresent: TutorialGuideView.addDevice, size: TutorialGuideView.addDevice.frame.size, source: source, clickThrough: true)
            addDeviceGuideView?.delegate = self
        }
    }
}

extension OnlineDeviceListMasterViewController: GuidePresentationViewDelegate {
    func guidePresentationViewDidDismiss(_ view: GuidePresentationView) {
        if view == moreToolsPopoverView {
            navigationItem.leftBarButtonItem?.tintColor = UIColor(white: 0, alpha: 0.8)
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        }
    }
}

// MARK: - util
extension OnlineDeviceListMasterViewController {
    private func storeGroupParameter() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        DeviceListManager.shared.updateLastSelectGroupID(deviceGroups[currentGroupIndex].groupID)
    }
}

extension OnlineDeviceListMasterViewController {

    private func presentUpgradeInfo(appVersionInfo: AppUpgradeModuleBaseUpgradeInfo) {
        let alertViewController = DeviceListUpgradeAlertController(versionInfo: appVersionInfo)
        present(alertViewController, animated: true, completion: nil)
    }

    private func checkUpdateIfNeeded() {
        let requiredService = DeviceListModule.shared.requiredService
        guard requiredService?.shouldShowNewAppVersion() ?? false else {
            return
        }

        // 仅跳转至需要更新的包中（若对应版本的升级包needNotify为false，而另外版本的needNotify为true，会跳转至另一版本）
        if TPAppUtils.isTestFlightBeta() {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, appVersionInfo.needNotify, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        } else {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo, appVersionInfo.needNotify {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        }

    }
}

extension OnlineDeviceListMasterViewController: DeviceListSearchViewControllerDelegate {
    func navigateToGroup(group: TPSSDeviceGroup) {
        navigationController?.popViewController(animated: true)
        DispatchQueue.main.async {
            self.loadGroup(with: group.groupID)
        }
    }

    func navigateToSyncPreviewViewController(device: DeviceDetail) {
        goToSyncPreview(ipc: device, listType: device.listType)
    }

    func navigateToPreviewViewController(device: DeviceDetail, channel: TPSSChannelInfo?) {
        if device.deviceType == .smartLock {
            DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
            return
        }
        goToPreview(device: device, channel: channel)
    }

    func navigateToBatteryDoorbellViewController(device: DeviceDetail, fromNVR nvr: (deviceID: TPSSDeviceIdentifier, channel: UInt)?) {
        DeviceListModule.shared.requiredService?.navigateToBatteryDoorbellViewController(for: device.identifier, group: DeviceListManager.shared.defaultGroupID, listType: device.listType, navigator: navigationController, from: nvr?.deviceID, channelInNVR: nvr?.channel.intValue)
    }

    func navigateToNVRViewController(nvr: DeviceDetail) {
        var groupId = DeviceListManager.shared.defaultGroup.groupID
        if currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex {
            groupId  = deviceGroups[currentGroupIndex].groupID
        }
        goToNVR(nvr: nvr, groupID: groupId)
    }

    func navigateToSolarControllerManagerViewController(device: DeviceDetail) {
        goToSolarController(solarController: device)
    }

    func navigateToRouterManagerViewController(device: DeviceDetail) {
        goToRouter(device: device)
    }

    func navigateToSmartLockViewController(device: DeviceDetail) {
        DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
    }
}

// MARK: Navigation
extension OnlineDeviceListMasterViewController: PreviewControllerEntrance {
    func goToPreview(device: DeviceDetail, channel: TPSSChannelInfo?) {
        goToPreview(deviceID: device.identifier, channelID: channel?.channelId.intValue ?? -1, listType: device.listType)
    }

    func goToNVR(nvr: DeviceDetail, groupID: String? = nil) {
        let vc = NVRTabViewController()
        vc.cloudIdentifier = nvr.cloudDeviceID
        vc.deviceIdentifier = nvr.identifier
        vc.listType = nvr.listType
        vc.groupId = groupID
        navigationController?.pushViewController(vc, animated: true)
    }

    func goToSolarController(solarController: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToSolarControllerManagerViewController(deviceID: solarController.identifier, listType: solarController.listType, navigator: navigationController)
    }

    func goToRouter(device: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToRouterDefault(mac: device.mac, listType: device.listType, isOnline: device.online, navigator: navigationController)
    }
}

// MARK: Actions
extension OnlineDeviceListMasterViewController {
    private func dismissPresentedViews() {
        addDeviceGuideView?.dismiss()
        moreToolsPopoverView?.dismiss()

        presentedGroupList?.dismiss(animated: true, completion: nil)

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }

    @IBAction private func addDeviceButtonClicked(_ sender: Any) {
        guard isCloudLogin else {
            showAlertWith(title: LocalizedString(key: deviceListNotLogin), defaultButtonTitle: LocalizedString(key: deviceListLogin), defaultButtonHandler: { (_) in
                DeviceListModule.shared.requiredService?.navigateToLoginViewController(navigator: self.navigationController)
            })
            return
        }
        dismissPresentedViews()

        DeviceListModule.shared.requiredService?.presentDeviceAddViewController(viewController: self, listType: listType)
    }

    @IBAction private func moreToolsButtonClicked(_ sender: Any) {
        guard isCloudLogin else { return }

        if moreToolsPopoverView != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let size = CGSize(width: 212, height: 16 + DeviceGroupMenuView.Item.allCases.count * 44)
        let menuView = DeviceGroupMenuView(frame: CGRect(origin: .zero, size: size))
        menuView.action = handleDeviceGroupMenu

        dismissPresentedViews()

        updateMenu()

        if let source = (navigationItem.leftBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
            menuView.configurePopoverShadow(cornerRadius: 8)
            moreToolsPopoverView = presentGuideWith(viewToPresent: menuView, size: size, backgroundColor: .clear, source: source, offset: CGPoint(x: -12, y: 4))
            moreToolsPopoverView?.delegate = self
        }
        navigationItem.leftBarButtonItem?.tintColor = .theme1
    }

    @IBAction private func groupMenuToggled(_ sender: UIButton) {
        guard isCloudLogin else { return }

        if presentedViewController != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_up_small_normal"), for: .normal)

        let groups = DeviceListManager.shared.groupList
        guard let vc = GroupListViewController.create() else {
            return
        }
        let height = CGFloat(groups.count) * 52 + 72
        vc.preferredContentSize = CGSize(width: UIScreen.main.bounds.width, height: height)
        vc.modalPresentationStyle = .custom
        vc.transitioningDelegate = groupPresenter
        vc.groups = groups
        vc.currentGroupID = deviceGroups[currentGroupIndex].groupID
        vc.delegate = self
        present(vc, animated: true, completion: nil)
    }

    @IBAction private func recentPreviewClicked(_ sender: Any) {
        // 不会用到此按钮，但暂时保留
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDataSource {
    private func groupInformation(at index: Int) -> (String, Bool) {
        if deviceGroups.isEmpty { return (LocalizedString(key: deviceListMyDevice), true) }
        return (deviceGroups[index].groupName, index == currentGroupIndex)
    }

    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }

    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return max(1, deviceGroups.count)
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        return collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)
    }
}

extension OnlineDeviceListMasterViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        updateGroupShadow()
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDelegate {
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        if deviceGroups.isEmpty { return }
        dismissPresentedViews()
        loadGroup(with: deviceGroups[indexPath.item].groupID)
    }
}

extension OnlineDeviceListMasterViewController: DeviceGroupNameLayoutDelegate {
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, groupForItemAt indexPath: IndexPath) -> (name: String, selected: Bool) {
        return groupInformation(at: indexPath.item)
    }
}

// MARK: Page Management
extension OnlineDeviceListMasterViewController: UIPageViewControllerDataSource {
    func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex > 0 && currentGroupIndex < deviceGroups.count else { return nil }
        return createPage(for: currentGroupIndex - 1)
    }

    func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex >= 0 && currentGroupIndex < deviceGroups.count - 1 else { return nil }
        return createPage(for: currentGroupIndex + 1)
    }
}

extension OnlineDeviceListMasterViewController: UIPageViewControllerDelegate {
    func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
        if completed {
            if let viewControllers = pageViewController.viewControllers, let firtViewController = viewControllers.first {
                if let currentGroupIndex = objc_getAssociatedObject(firtViewController, &pageIndexAssociatedObjectHandle) as? Int {
                    self.currentGroupIndex = currentGroupIndex
                    commonLoad(animated: true, recreate: false)
                }
            }
        }
    }
}

// MARK: Group Management
extension OnlineDeviceListMasterViewController: GroupListViewControllerDelegate {
    func groupListViewController(_ groupListViewController: GroupListViewController, canMoveGroupTo destinationIndex: Int) -> Bool {
        guard deviceGroups.count > destinationIndex else {
            return false
        }
        let group = deviceGroups[destinationIndex]
        return !group.isDefaultGroup
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didMoveGroupAt sourceIndex: Int, to destinationIndex: Int) {
        // check if current group index has changed
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let originalGroup = deviceGroups[currentGroupIndex]
        deviceGroups.swapAt(sourceIndex, destinationIndex)
        if let newIndex = deviceGroups.firstIndex(of: originalGroup), currentGroupIndex != newIndex {
            currentGroupIndex = newIndex
        }
        // always invalidate page controller cache
        pageController.setViewControllers([currentList], direction: .forward, animated: false, completion: nil)
        groupCollectionView.moveItem(at: IndexPath(item: sourceIndex, section: 0), to: IndexPath(item: destinationIndex, section: 0))
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didSelectGroupAt index: Int) {
        dismissPresentedViews()
        loadGroup(with: deviceGroups[index].groupID)
    }

    func groupListViewControllerDidSelectCreatingNewGroup(_ groupListViewController: GroupListViewController) {
        dismissPresentedViews()
        guard let vc = CommonNameInputViewController.create() else {
            return
        }
        vc.navigationTitle = LocalizedString(key: deviceListSetGroupNameTitle)
        vc.doneButtonTitle = LocalizedString(key: commonNextStep)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didRequestEditingGroupAt index: Int) {
        dismissPresentedViews()
        guard let vc = GroupSettingViewController.create() else {
            return
        }
        vc.group = deviceGroups[index]
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewControllerDidDismiss(_ groupListViewController: GroupListViewController) {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
        _ = DeviceListManager.shared.updateGroupOrder(newGroup: deviceGroups)
    }
}

extension OnlineDeviceListMasterViewController: CommonNameInputViewControllerDelegate {
    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didCancelWith text: String) {
        navigationController?.popViewController(animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didFinishWith text: String) {
        guard deviceGroups.count > 0 else {
            navigationController?.popToViewController(self, animated: true)
            return
        }
        newCreateGroupName = text
        let vc = DeviceSelectionViewController(entry: .groupAddIndependent, group: DeviceListManager.shared.defaultGroupID, canProceedWithNoSelection: true)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, errorMessageFor text: String) -> (allowed: Bool, message: String?) {
        let error = TPSSDeviceListValidate.validateDeviceGroupName(text)
        if error != nil {
            return (true, error?.message)
        }

        if DeviceListManager.shared.groupList.contains(where: { $0.groupName == text }) {
            return (true, LocalizedString(key: deviceListNameExists))
        }
        return (true, nil)
    }

    func placeholderForNameInputViewController(_ nameInputViewController: CommonNameInputViewController) -> String? {
        return SharedResource.sharedString(key: shareStringLengthConstraint)
    }
}

extension OnlineDeviceListMasterViewController {
    @objc func handleShowCameraDisplayNoActiveChannelAlertNotification(_ noti: NSNotification) {
        if let (device, listType) = noti.object as? (DeviceDetail, TPSSDeviceListType), listType == .remote {
            shouldShowCameraDisplayNoActiveChannelAlert = true
            addChannelCameraDisplay = DeviceListManager.shared.device(with: device.identifier)
        }
    }

    @objc func handleShowStorageDetectAlertNotification(_ noti: NSNotification) {
        diskStatusShowed = .none
        sdCardStatusShowed = .none
    }

    private func showCameraDisplayNoActiveChannelAlert() {
        showAlertWith(title: LocalizedString(key: deviceAddCameraDisplayNoActiveChannelsTitle), defaultButtonTitle: LocalizedString(key: deviceAddAddNext), cancelButtonTitle: LocalizedString(key: commonNotNow), cancelButtonHandler: nil) { (_) in
            if let cameraDisplay = self.addChannelCameraDisplay {
                DeviceListModule.shared.requiredService?.navigateToCameraDisplayDiscoverViewController(deviceID: cameraDisplay.identifier, discoverType: .cameraDisplay, listType: self.listType, navigator: self.navigationController)
                // 需要在中间插一个ViewController
                let vc = NVRTabViewController()
                vc.cloudIdentifier = cameraDisplay.cloudDeviceId
                vc.deviceIdentifier = cameraDisplay.identifier
                vc.listType = .remote
                vc.hidesBottomBarWhenPushed = true
                if var tmpViewControllers = self.tpNavigationController?.viewControllers {
                    tmpViewControllers.insert(vc, at: tmpViewControllers.count - 1)
                    self.tpNavigationController?.setViewControllers(tmpViewControllers, animated: true)
                }
            }
        }
    }
}

extension OnlineDeviceListMasterViewController: DeviceSDCardStatusChecker {
    var listType: TPSSDeviceListType { return .remote }

    func formatProcessDidFinish() {
        currentList.reload()
    }
}

extension OnlineDeviceListMasterViewController: DeviceSelectionViewControllerDelegate {
    func deviceSelectionViewController(_ deviceSelectionViewController: DeviceSelectionViewController, didPressRightBarButtonItemWithDeviceChannels selectedDeviceChannels: [DeviceDetail: [ChannelId]]) {
        switch deviceSelectionViewController.entryType {
        case .groupAddIndependent:
            ToastView.showLoadingToast(cirleWithMessage: nil)

            let targetDeviceChannels = DeviceSelectionViewController.covertDeviceChannel(selectedDeviceChannels)
            DeviceListManager.shared.createGroup(name: newCreateGroupName, deviceChannelMap: targetDeviceChannels).always {
                ToastView.dismissLoadingToast()
            }.then { (groupID) in
                self.navigationController?.popToViewController(self, animated: true)
                self.reload(with: groupID)
            }.catch { (error) in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }
        default:
            break
        }
    }
}

// MARK: - notification
extension OnlineDeviceListMasterViewController {
    @objc private func handleDeviceListInvalidated() {
        shouldRecreate = true
        deviceListVCCacheDictionary.removeAll()
    }

    @objc private func handleDeviceListUpdated() {
        showUpdateAlertIfAny()
    }

    @objc private func handleReorderBegined(_ notification: Notification) {
        enterReorderMode()
    }

    @objc private func handleReorderEnded(_ notification: Notification) {
        exitReorderMode()
    }

    @objc private func handleUpdateGroupAndDeviceList(_ notification: Notification) {
        if isCloudLogin {
            handleGroupModeToggleAfterGetList(notification)
        } else if isShowing {
            // 处理非登录场景

            // 仅页面正在显示才处理数据获取结果更新页面状态，否则等viewWillAppear再处理。避免正在获取列表
            // 时切换到其它页面，列表获取有结果后触发本逻辑使得子VC触发viewWillAppear，后续真正展示页面时
            // 就不再触发viewWillAppear导致数据异常
            showEmpty()
        }
    }

    @objc private func handleLocalDeviceRefreshed(_ notification: Notification) {
        if !isCloudLogin && isShowing {
            // 非登录且页面正在显示时才需要处理因网络状态变化重新发现完的通知，因为此时可能需要在有/无设备的页面之间切换。
            // 如果页面没有在显示则不需要处理，因为viewWillAppear会触发该逻辑
            showEmpty()
        }
    }

    @objc private func handleUpdateGroupList(_ notification: Notification) {
        if let dic = notification.object as? [String: Any],
           let error = dic[DeviceListManager.notificationKeyError] as? Error {
            ToastView.showWarningToast(title: error.localizedDescription, existTime: nil, centerY: .lowest)
            return
        }
        // 失败也更新，此时显示默认分组
        refreshAfterGroupUpdated()
    }

    private func handleGroupModeToggleAfterGetList(_ notification: Notification) {
        let finishHandler: (() -> Void) = {
            if self.shouldToggleGroupModeAfterGetList {
                ToastView.dismissLoadingToast()
                self.shouldToggleGroupModeAfterGetList = false
                self.toggleGroupMode()
            }
        }

        guard let dic = notification.object as? [String: Any],
              let status = dic[DeviceListManager.notificationKeyListUpdateStatus] as? DeviceListUpdateStatus else {
            finishHandler()
            return
        }

        if status.cloudUpdateNecessaryInfoFinished {
            finishHandler()
        }
    }
}

extension OnlineDeviceListMasterViewController: Storyboarded {
    static var storyboardName: String { return "DeviceList" }
    static var storyboardBundle: Bundle? { return Bundle.deviceListModuelBundle }
}

extension Notification.Name {
    static var DeviceListUpdated: Notification.Name { return Notification.Name("DeviceListUpdated") }
}

// MARK: - setup
extension OnlineDeviceListMasterViewController {
    private func setupView() {
        setupBarButtonItems()
        setupButtons()
    }

    private func setupBarButtonItems() {
        navigationItem.leftBarButtonItem = moreToolBarButtonItem
        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
    }

    private func setupButtons() {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }
}

// MARK: - reorder
extension OnlineDeviceListMasterViewController {
    // 本vc不会主动进入排序模式，而是依赖于OnlineDeviceListViewController的通知
    private func enterReorderMode() {
        isReordering = true
        tabBarController?.tabBar.isUserInteractionEnabled = false
        groupToolbarContainer.isUserInteractionEnabled = false

        pageController.scrollEnable = false

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
    }

    private func showUpdateAlertIfAny() {
        if DeviceListManager.shared.allDetailDevices.contains(where: {(DeviceListModule.shared.requiredService?.onboardingTypeFromQRCode(qrCode: $0.qrCode) ?? 0) == TPSS_EC_GENERAL} ) || DeviceListManager.shared.hasUnsupportedDevice {
            // 二维码获取不支持的设备或者读取设备列表中有不支持的设备时，弹出升级提示
            let lastVersion: (isShow: Bool, versionCode: Int) = DeviceListModule.shared.requiredService?.checkShowUpdateAlert() ?? (false, 0)
            if lastVersion.isShow {
                showAlertWith(title: LocalizedString(key: commonNoticeUpdateAPP), message: nil, messageTextAlignment: nil,
                              defaultButtonTitle: LocalizedString(key: commonUpdateNow), defaultButtonColor: .theme1,
                              cancelButtonTitle: LocalizedString(key: commonIgnoreNotice), cancelButtonColor: .black.withAlphaComponent(0.8),
                              cancelButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.updateUserNoMoreNotify(version: lastVersion.versionCode)
                    self.showDiskAlertIfAny()
                }, defaultButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.jumpAndCheckAppVersion()
                    self.showDiskAlertIfAny()
                })
            } else {
                showDiskAlertIfAny()
            }
        } else {
            showDiskAlertIfAny()
        }
    }

    private func exitReorderMode() {
        tabBarController?.tabBar.isUserInteractionEnabled = true
        groupToolbarContainer.isUserInteractionEnabled = true

        pageController.scrollEnable = true

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }

        isReordering = false
    }
}

//
//  SweeperMainViewController.swift
//  Pods
//
//  Created by 爱迪生 on 2021/8/2.
//

import UIKit
import SurveillanceHomeBase
import Promises
import SwiftyJSON
import SharedResource
import TPFoundation
import SimplePlayer
import DeviceDetailModule
import SnapKit
import NetService
import ThemeTool

enum CaptureImageLoadingStatus: Equatable {
    case loadSuccess
    case failure
    case loading
    case loadNoImage
    case model(SweeperBarrierType)
}

enum MainMapLoadingState {
    case loading
    case failure
    case noMap
    case hasMap
}

class SweeperMainViewController: SweeperGlobalConfigurationViewController {
    var needShowFastMapGuide: Bool = false
    // MARK: subviews
    private var previewButton: SweeperButton?
    weak var inputPasswordVC: UIViewController?
    var inputPassword: String?
    private var editButton: SweeperButton?
    private var baseStationButton: SweeperButton?
    private var moreButton: SweeperButton?
    private var parameterButton = SweeperButton()
    private var navigationTitleView = SweeperTitleBatteryView()
    private var chargeButton = SweeperButton()
    private var createMapContainer: SweeperCreateMapView?
    private var sweepAreaPopView: SweeperClearAreaPopView?
    private var sweeperAlarmViewController: (UIViewController & SweeperAlarmWindowSuitable)?
    private var startCleanAnimationView: SweeperStartCleanAnimationView?
    private var mapView = SweeperHomeMapView(frame: .zero, mapSize: .init(width: 1200, height: 1200))
    private var loadingView = SweeperMainMapLoadingView(frame: .zero)
    private var buttonContainerStackView = UIStackView()
    private var environmentView = UIView(frame: .zero)
    private var temperatureView = UILabel(frame: .zero)
    private var humidityView = UILabel(frame: .zero)
    private var equipmentOfflineView: SweeperRobotOfflineView?

    private var sweepControlView = SweeperControlView()
    private var sweepCaptureView = SweeperCaptureBubbleView()
    private var sweeperBaseUpgradingView = SweeperBaseStationUpgradingView()
    private var sweeperMechanicalOffView = SweeperMechanicalOffView()

    private var sweepControlViewHeightConstraint: NSLayoutConstraint?
    private var heightForControlView: CGFloat {
        switch status {
        case .stop:
            return 88 + bottomSafeAreaInset
        case .fastMap, .fastMapPause:
            return 69 + bottomSafeAreaInset
        case .sweepingPause, .sweeping:
            return 143 + bottomSafeAreaInset
        }
    }

    enum AlarmButtonClickMode {
        case exit
        case more
        case none
    }
    private var alarmButtonClickMode: AlarmButtonClickMode = .exit

    // 快速建图引导view
    private var fastMapImageView: UIImageView?
    private var fastMapGuideView: GuidePresentationView?


    // 地图已自动保存通知
    private var savedMapNoticeView: UIImageView?
    private var saveMapGuideView: GuidePresentationView?
    // 存储设备详细信息
    private var deviceDetail: DeviceDetail?
    private var isSharedDevice: Bool {
        return deviceDetail?.isSharedDevice ?? false
    }

    private var robotOffline = false
    private var hadStartWaveAnimation = false

    /// 首次载入
    /// 第一帧地图帧/路径帧到来时刷新所有界面
    private var needRefreshMapViewInMediaPlayer = true
    private var needEntrySaveMapLogic = true
    private var needShowCleaningLog = true

    /// 该属性用于，当前保存地图弹窗弹出时，扫地机正在清扫。保存该弹出状态，在清扫结束后再进入一遍保存地图逻辑。
    private var needEntrySaveMapLogicAfterBasicStateChanged = false


    /// 在地图变化时，将下列是否需要展示“地图保存”弹窗标识为true
    /// 在dataloading成功时，进行展示
    private var needShowSaveMapMultiFloor = false
    private var needShowSaveMapSingleFloor = false
    private var needShowMapHasSavedTip = false

    /// 基站升级与关机页面展示
    private var isShowingUpgradingView: Bool {
        get {
            return !sweeperBaseUpgradingView.isHidden
        }
        set {
            sweeperBaseUpgradingView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var isShowingMechanicalView: Bool {
        get {
            return !sweeperMechanicalOffView.isHidden
        }
        set {
            sweeperMechanicalOffView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var shouldShowChargeButton: Bool {
        get {
            guard let state = state else {
                return false
            }
            // 清扫完成并且不在基站上
            return state.cleanFinished && !state.onboard
        }
    }

    private var firstTimeUpdateNavigationTitle: Bool = true

    private var cleaningMode: SweeperCleaningMode {
        get {
            return sweeperControl?.cleaningMode ?? SweeperCleaningMode.init(type: .autoClean)
        }
        set {
            sweeperControl?.cleaningMode = newValue
            updateCleaningModeUI()
        }
    }

    private var cleaningModeType: CleaningModeType {
        get {
            return cleaningMode.type
        }
        set {
            cleaningMode.type = newValue
        }
    }

    override var sweeperCustomOrAutoMode: SweeperCustomOrAutoMode {
        get {
            return (sweeperControl?.customCleanEnabled ?? false) ? .custom : .auto
        }
        set { }
    }

    private var map: SweeperMap? {
        get {
            return sweeperControl?.map
        }
        set {
            let preMap = map
            sweeperControl?.map = newValue
            currentMapDidChanged(preMap: preMap)
        }
    }

    private var status: SweeperProcedure = .stop

    private var state: SweeperState? {
        get {
            return sweeperControl?.basicState
        }

        set {
            sweeperControl?.basicState = newValue
            basicStateChangeAction(showToast: true)
        }
    }

    private var temperatureText: String {
        get {
            var text = "环境温度："
            if let temperature = state?.temperature {
                let temperatureValue = Int(temperature)
                if temperatureValue == 127 || temperatureValue < -40 {
                    text += "--"
                } else {
                    text += "(Int(temperature))℃"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var humidityText: String {
        get {
            var text = "环境湿度："
            if let humidity = state?.humidity {
                let humidityValue = Int(humidity)
                if humidityValue < 0 || humidityValue > 100 {
                    text += "--"
                } else {
                    text += "(Int(humidity))%"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var cleaningState: SweeperCleaningState? {
        get {
            return sweeperControl?.cleaningState
        }

        set {
            sweeperControl?.cleaningState = newValue
            updateCleaningStateUI()
        }
    }

    private var isRecharging: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .recharge
    }

    private var forbiddenRechargeAndClean: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .assignLocation || state.mainState == .remoteControl
    }

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = SharedResource.sharedImage(named: "shared_setting_icon_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(settingBarButtonItemDidClick))
    }()

    // selected layerID backup
    private var selectedLayerID = [Int]()

    // 当前展示的障碍物ID
    private var obstacleID: Int?

    override var navigationBarTraits: [NavigationBarTrait] {
        return [.hidden(on: false), .style(style: .default), .translucent(on: false), .barTint(color: .init(hexString: lightGray10Color)), .separatorStyle(color: .clear, height: 0.0), .backgroundImage(image: UIImage())]
    }

    // MARK: - Constants
    private let chargeButtonPadding = 8.0
    private let defaultButtonPadding = 12.0
    private let defaultButtonInterval = 59.0
    private let battreyThreshold = 20
    private let bottomSafeAreaInset = TPUIUtils.safeAreaInsets().bottom

    override init(deviceID: TPSSDeviceIdentifier, listType: TPSSDeviceListType) {
        super.init(deviceID: deviceID, listType: listType)

        SweeperModule.shared.registerControlListener(listener: self, deviceID: deviceID, listType: listType)
        SweeperModule.shared.registerMapListener(mapListener: self)
        NotificationCenter.default.addObserver(self, selector: #selector(willEnterForeground), name: UIApplication.willEnterForegroundNotification, object: nil)
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        view.backgroundColor = .init(hexString: lightGray10Color)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        setupNavigation()
        setupControlView()
        setupMapView()
        setupSweeperAlarmView()
        setupButtons()
        setupOfflineView()
        setupEnvironmentView()
        setupLoadingView()
        setupUpgradingView()
        setupMechanicalOffView()
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true

        // 离开当前页面时，会使动画失效，若正在展示动画，再重新进入时，需要重新开始动画
        if hadStartWaveAnimation {
            startWaveAnimation()
        }

        if let loadingState = sweeperControl?.dataLoadingState {
            dataLoadingStateChangeAction(loadingState: loadingState)
        } else {
            updateViewShowState(state: .failed)
        }
        captureBubbleViewDismiss()
        // 横幅始终展示在最前方
        if let alarmView = sweeperAlarmViewController?.view {
            view.bringSubviewToFront(alarmView)
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        if needShowFastMapGuide {
            showFastMapGuideView()
            needShowFastMapGuide = false
        }
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        savedMapNoticeView?.removeFromSuperview()
    }

    deinit {
        SweeperModule.shared.removeControlListener(listener: self)
        SweeperModule.shared.removeMapListener(mapListener: self)
        NotificationCenter.default.removeObserver(self)
    }

    // 将从后台切换到前台，看作视图willAppear，方法作相同处理
    @objc func willEnterForeground() {
        cleanAllFlag()

        // 若当前的载入状态为loading时，对UI进行loading状态的刷新。
        // 否则等待dataLoadingStateDidChanged方法回调(从 loading -> 其他状态)。
        // 注：dataLoadingStateDidChanged方法在 loading -> loading 时不会被调用。
        if sweeperControl?.dataLoadingState == .loading {
            dataLoadingStateChanged(loadingState: .loading)
        }
    }

    /// 根据载入状态更新主页面View的展示情况
    /// -主页面加载状态 -
    /// 需要管理的控件：创建地图按钮、主页面地图、载入（载入失败）页面、编辑地图按钮、边扫边拖（定制清扫）悬浮按钮
    private func updateViewShowState(state: SweeperDataLoadingState) {
        switch state {
            case .loading:
                loadingView.isHidden = false
                loadingView.isLoadingFailure = false
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
            case .failed:
                loadingView.isLoadingFailure = true
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
                // 若扫地机离线，则展示离线页面，否则展示加载失败页面
                loadingView.isHidden = robotOffline
                equipmentOfflineView?.isHidden = !robotOffline
            case .noMap:
                createMapContainer?.isHidden = false
                loadingView.isHidden = true
                mapView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                parameterButton.isHidden = false
                moreButton?.isHidden = false
                editButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
            case .success:
                loadingView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                mapView.isHidden = false
                createMapContainer?.isHidden = true
                parameterButton.isHidden = false
                editButton?.isHidden = false
                moreButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
        }
    }

    override func willUpdateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode, showAlert: Bool) -> Bool {
        /// 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            if showAlert {
                showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap)
            }
            return false
        }
        return super.willUpdateSweeperCustomOrAutoMode(newMode: newMode, showAlert: showAlert)
    }

    override func updateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode) {
        /// 1. 若切换时当前清扫模式与newMode相同，则无需进入后续逻辑
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap,
              let sweeperControl = sweeperControl,
              let mapID = sweeperControl.map?.currentMapID,
              newMode != sweeperCustomOrAutoMode else {
            return
        }

        /// 2. 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap) { [weak self] (_) in
                self?.configurationView?.selectSegment(type: .auto)
            }
            return
        }

        /// 3. 切换为定制清扫时，无设置清扫顺序与清扫偏好，则不向设备发送请求（并在退出弹窗时（configurationFinished）切换回变扫边拖）
        if newMode == .custom && !isSetPreference() && !isSetSweepSeq() {
            return
        }

        /// 4. 发送切换清扫模式的接口，并修改主页面UI
        let customCleanEnabled = newMode == .custom
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestSetCleaningParam(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: mapID, customEnabled: customCleanEnabled).always {
            ToastView.dismissLoadingToast()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }

    override func configurationFinished() {
        /// 若configurationView当前处于定制清扫页面（“1”状态），则判断是否已设置定制清扫，若否切回边扫边拖。
        if !isSetPreference() && !isSetSweepSeq() && !settingButtonDidClickFlag && configurationView?.segmentedControl.selectedSegmentIndex == 1 {
            ToastView.showWarningToast(title: "未设置定制清扫，只能使用普通清扫", existTime: nil, centerY: .low)
            // 0 - means auto cleaning
            configurationView?.selectSegment(type: .auto)
        }
    }

    override func preferenceButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.preferenceButtonClickOperation()
    }

    override func sweepOrderButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.sweepOrderButtonClickOperation()
    }

    private func refreshMediaPlayerAndSweeperControl() {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.refreshSweeperControl()
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
    }

    private func updateConfigurationView() {
        configurationView?.selectSegment(type: sweeperCustomOrAutoMode)
        if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
            cleanMethodMode = mode
        }
    }

    private func updateClearingAreaButton() {
        var text = "全屋"
        var imagePath = "sweep_home"
        var title = text
        switch cleaningModeType {
        case .pointClean:
            text = "选框"
            title = text
            imagePath = "sweep_frame"
        case .areaClean:
            text = "区域"
            title = text
            imagePath = "sweep_region"
        case .autoClean:
            text = "全屋"
            title = text
            imagePath = "sweep_home"
        case .partClean:
            // 仅在sweepControlView的RangeTitle中修改
            updateData(with: .autoClean)
            title = "局部"
        case .fastMap:
            // DO NOTHING
            return
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
        sweepControlView.clearAreaButton?.titleLabel.text = text
        sweepControlView.clearAreaButton?.titleImageView.image = UIImage.image(named: imagePath)
        sweepControlView.rangeTitleLabel.text = title
        sweepControlView.clearAreaButton?.selectedAreaNumber = cleaningModeType == .areaClean ? selectedLayerID.count : 0
    }

    private func updateSweeperHomeMapViewCleanMode() {
        switch cleaningModeType {
        case .pointClean:
            mapView.cleaningModeType = .pointClean
        case .areaClean:
            mapView.cleaningModeType = .areaClean
        case .autoClean:
            mapView.cleaningModeType = .autoClean
        case .partClean:
            mapView.cleaningModeType = .partClean
        case .fastMap:
            mapView.cleaningModeType = .fastMap
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
    }

    private func updateSelectedLayerID() {
        if let seq = sweeperControl?.cleaningMode.areaIDs {
            selectedLayerID = seq
        }
    }

    private func updateParamUI() {
        var text = ""
        var imagePath = ""
        switch sweeperCustomOrAutoMode {
        case .auto:
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                switch mode {
                case .sweep:
                    text = LocalizedString(key: sweeperCleanOnlySweep)
                    imagePath = "mode_sweep"
                case .mop:
                    text = LocalizedString(key: sweeperCleanOnlyMop)
                    imagePath = "mode_mop"
                case .both:
                    text = LocalizedString(key: sweeperCleanSweepAndMop)
                    imagePath = "mode_sweep_mop"
                }
            }
        case .custom:
            text = LocalizedString(key: sweeperCustomClean)
            imagePath = "mode_diy"
        }
        let image = UIImage.image(named: imagePath)
        // 控制栏的参数按钮
        sweepControlView.parameterButton?.titleLabel.text = text
        sweepControlView.parameterButton?.titleImageView.image = image

        // 悬浮的参数按钮
        parameterButton.titleLabel.text = text
        parameterButton.titleImageView.image = image
    }

    private func updateSweeperHomeMapViewCustomOrAutoMode() {
        switch sweeperCustomOrAutoMode {
        case .auto:
            mapView.sweeperCustomOrAutoMode = .auto
        case .custom:
            mapView.sweeperCustomOrAutoMode = .custom
        }
    }

    private func dataLoadingStateChangeAction(loadingState: SweeperDataLoadingState) {
        // 1. 判断设备是否离线（deviceDetail.online）
        if loadingState == .failed {
            robotOffline = !(deviceDetail?.online ?? false)
        }

        // 2. 判断基站是否升级，若是，则不展示所有UI（除了导航栏）
        if state?.chargeBaseUpgrading == true {
            isShowingUpgradingView = true
            updateNavigation()
            return
        }

        if let switchOn = state?.mechanicalSwitchOn {
            showMechanicalOffView(switchOn: switchOn)
        }

        // 3. 刷新UI状态(是否hidden)
        updateViewShowState(state: loadingState)

        // 4. 载入成功（success or nomap）按照其他状态展示UI
        if loadingState == .success {
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            mapView.updateCleanningModeAndSweepingState()
            mapView.updateCustomOrAutoMode()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            sweeperAlarmViewController?.showAlarm()
            sweeperAlarmViewController?.showNotify()
            if needShowCleaningLog {
                sweeperAlarmViewController?.showCleaningLog()
                needShowCleaningLog = false
            }
            if needEntrySaveMapLogic {
                currentMapDidChanged(preMap: nil)
                needEntrySaveMapLogic = false
            }
            saveMapLogic()
        } else if loadingState == .noMap {
            // 尽管当前map id 为-2，但当设备发送地图帧过来时，仍然需要展示地图，故仍然需要刷新mapView
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            sweeperAlarmViewController?.showCleaningLog()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            // 用户未进入引导页，且当前不在清扫、建图中，需要进入快速建图引导页
            if UserDefaults.standard.shouldShowGuideForFastMap(for: deviceID) && (state?.cleanFinished ?? true) {
                let vc = SweeperFastMapGuideViewController(deviceID: deviceID, listType: listType)
                navigationController?.pushViewController(vc, animated: true)
            }
        }
    }

    private func saveMapLogic() {
        // 若需要展示弹窗，但当前在清扫中，则将弹窗状态保存起来，待扫地机状态变化时重新进入。
        if state?.cleanFinished == false && (needShowSaveMapSingleFloor || needShowSaveMapMultiFloor) {
            needEntrySaveMapLogicAfterBasicStateChanged = true
            return
        }
        if needShowMapHasSavedTip {
            showMapHasSavedTip()
            needShowMapHasSavedTip = false
        }
        if needShowSaveMapSingleFloor {
            saveMapSingleFloor()
            needShowSaveMapSingleFloor = false
        }
        if needShowSaveMapMultiFloor {
            saveMapMultiFloor()
            needShowSaveMapMultiFloor = false
        }
    }

    private func basicStateChangeAction(showToast: Bool) {
        // 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 展示波纹动画: 1. 当前地图ID为-2；
        //             2. 当前在清扫中；
        //             3. 未展示过动画
        //             4. 无地图帧
        if map?.currentMapID == noMapID
            && state?.cleanFinished == false && !hadStartWaveAnimation && sweeperControl?.hadFrame == false {
            startWaveAnimation()
        }
        if (state?.cleanFinished == true) {
            stopWaveAnimation()
        }
        // 特殊情况处理，当扫地机进入清扫状态时
        // 且当前处于无地图时，需要显示地图（而非等到map更改的信令进行变化）
        // 再次变为非清扫状态，且无地图时，需要展示无地图Image
        if map?.currentMapID == noMapID && state?.cleanFinished == false {
            updateViewShowState(state: .success)
        } else if map?.currentMapID == noMapID && state?.cleanFinished == true {
            updateViewShowState(state: .noMap)
        }

        // 扫地机关机状态更新
        showMechanicalOffView(switchOn: state?.mechanicalSwitchOn ?? false)

        if showToast {
            updateBasicStateToastView()
        }
        // 更新扫地机当前的清扫状态（将扫地机状态分为清扫中、暂停中、未清扫，后续根据该status更新清扫UI）
        updateSweepProduce()

        updateUI()
    }

    /// 使用Clean Finished，fast Map  字段与 basic state字段联合判断当前清扫是否结束
    private func updateSweepProduce() {
        guard let state = state else {
            status = .stop
            return
        }
        if state.cleanFinished && state.mainState != .paused && state.mainState != .cleaning {
            // 若设备清扫完成且设备主状态不在清扫、暂停时
            status = .stop
        } else {
            if state.fastMap {
                // 若为快速建图
                if state.mainState == .cleaning {
                    status = .fastMap
                } else {
                    status = .fastMapPause
                }
            } else {
                // 若不为快速建图，则展示正常清扫UI
                if state.mainState == .cleaning {
                   status = .sweeping
                } else {
                   status = .sweepingPause
                }
            }
        }
    }

    // 根据信令展示ToastView
    private func updateBasicStateToastView() {
        guard let state = state else {
            return
        }
        // 主状态为回充，遥控，清扫时候，主页均需展示loading
        if ((state.mainState == .cleaning || state.mainState == .recharge || state.mainState == .remoteControl) && state.subState == .relocate) {
            ToastView.showLoadingToast(cirleWithMessage: "定位中...", existTime: 60, existMessage: nil)
        } else {
            ToastView.dismissLoadingToast()
        }
    }

    /// 根据status更新：清扫面板、清扫参数、导航栏里扫地机的状态、回充按钮、提示栏的位置；
    /// status:     sweeping：当cleanFinished为false，且mainState为Cleaning，subState为Sweeping；
    ///        pause：当cleanFinished为false，
    private func updateUI() {
        // 只当地图数据载入完成之后，更新信令收到后的UI
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 每次收到信令后，获取设备状态，更新设备状态同时更新界面UI

        // 控制面板
        sweepControlView.status = status
        sweepControlViewHeightConstraint?.constant = heightForControlView
        if status == .stop {
            // 清扫参数按钮
            parameterButton.isHidden = true
            // 地图控件
            mapView.isSweeping = false
        } else if status == .fastMap || status == .fastMapPause {
            mapView.isSweeping = true
            parameterButton.isHidden = true
        } else {
            parameterButton.isHidden = false
            mapView.isSweeping = true
        }
        // 导航栏的状态和电量
        updateNavigation()
        // 温度湿度更新
        updateEnvironmentView()
        // 充电按钮
        updateChargeButton()
        refreshBubbleView()
    }

    private func updateCleaningStateUI() {
        guard let state = cleaningState else {
            return
        }
        sweepControlView.areaTitleLabel.text = "(state.cleaningArea)㎡"
        sweepControlView.timeTitleLabel.text = "(state.cleaningTime)min"
    }

    private func updateCleaningModeUI() {
        /// 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        /// 修改设置清扫模式（cleaningMode）按钮的样式
        updateClearingAreaButton()
        /// 修改地图的清扫模式
        updateSweeperHomeMapViewCleanMode()
        /// 根据获取到的cleaningMode中区域清扫的ID，更新地图区域的清扫顺序数组
        updateSelectedLayerID()
        /// 修改定制清扫/边扫边拖属性 - 通过回调去更新该属性更新后主页后续的UI。回调中调用的方法 - updateSweeperCustomOrAutoMode()
        updateConfigurationView()
        /// 修改定制清扫/边扫边拖按钮的样式
        updateParamUI()
        /// 修改定制清扫/边扫边拖地图的样式
        updateSweeperHomeMapViewCustomOrAutoMode()
    }

    private func showAlertWithWholeHouseClean() {
        showAlertWith(title: "进行一次全屋清扫", message: "清扫完成后，将建立家居地图。", messageTextAlignment: .center, defaultButtonTitle: "进行全屋清扫", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonHandler: nil) { [weak self] (_) in
            self?.showSweepTipsAlert()
        }
    }

    private func startFastMap() {
        if sweeperControl?.basicState?.mainState == .remoteControl {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFastMapDuringRemoteControl))
            return
        }
        if sweeperControl?.basicState?.mainState == .assignLocation {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFAstMapDuringAssignLocation))
            return
        }
        // 强制扫地机进入新建快速地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .fastMap)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: self.deviceID, channel: self.channel, listType: self.listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func startFastMapAlert() {
        let alert = SweeperTipsAlert(type: .fastMap) { [weak self] () in
            guard let self = self else { return }
            self.startFastMap()
        }
        alert.show()
    }

    private func showAlertWithFastMapEnd() {
        showAlertWith(title: "尚未得到完整地图，确定要结束吗？", message: nil, messageTextAlignment: .center, defaultButtonTitle: "结束建图", defaultButtonColor: .theme1, cancelButtonTitle: "继续", cancelButtonHandler: nil) { [weak self] (_) in
            self?.setCleaningMode(type: .stop)
        }
    }

    private func showSweepTipsAlert() {
        let alert = SweeperTipsAlert(type: .clean) { [weak self] () in
            self?.setCleaningMode(type: .sweeping)
        }
        alert.show()
    }

    private func setCleaningMode(type: SweeperProcedure) {
        switch type {
        case .sweeping:
            if sweeperControl?.basicState?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringRemoteControl))
                return
            }
            if sweeperControl?.basicState?.mainState == .assignLocation {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringAssignLocation))
                return
            }
            // 若扫地机当前无地图，则所有“清扫”操作为全屋清扫。
            if map?.currentMapID == noMapID {
                self.cleaningMode = SweeperCleaningMode.init(type: .autoClean)
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: SweeperCleaningMode.init(type: .autoClean)).catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
                return
            }

            if cleaningModeType == .areaClean {
                if selectedLayerID.count == 0 {
                    ToastView.showWarningToast(title: "请选择需要清扫的区域", existTime: nil, centerY: .low)
                    return
                }
                sweeperControl?.cleaningMode.areaIDs = selectedLayerID
            } else if cleaningModeType == .pointClean,
                      let partArea = mapView.getSelectionRect() {
                // 若能够从SelectionRect获取到数据，则修改cleaningMode的PointRect
                sweeperControl?.cleaningMode.leftTopPoint = partArea.leftTopPoint
                sweeperControl?.cleaningMode.rightBottomPoint = partArea.rightBottomPoint
            } else {
                sweeperControl?.cleaningMode = .init(type: .autoClean)
            }

            ToastView.showLoadingToast(cirleWithMessage: nil)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: sweeperControl?.cleaningMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .sweepingPause, .fastMapPause:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .pause)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .stop:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .stop)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .fastMap:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .fastMap)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func saveMapSingleFloor() {
        let deleteMapID = map?.allMapNames.keys.first(where: { (mapID) -> Bool in
                  return mapID != temporaryMapID
              })
        guard let sweeperControl = sweeperControl,
              let deleteMapID = deleteMapID,
              let deleteMapName = map?.allMapNames[deleteMapID] else {
            return
        }
        showAlert(title: "是否保存新地图?", buttons: [
            .init(style: .default, text: "更新“(deleteMapName)”", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                ToastView.showLoadingToast(cirleWithMessage: "正在更新")
                SweeperService.deleteMap(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: deleteMapID).then { (_) in
                    ToastView.showWarningToast(title: "更新成功", existTime: nil, centerY: .low)
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
            }),
            .init(style: .default, text: "另存为新地图", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let alert = SweeperSelectionAlert(title: "相同环境请勿保存多张地图，有可能影响机器人的定位。", message: "我家为多楼层户型") {
                    guard self?.isCurrentMapSaved() == true else {
                        ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                        return
                    }
                    ToastView.showLoadingToast(cirleWithMessage: "正在保存")
                    SweeperService.setMultiFloorEnabled(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, enabled: true, mapID: nil).always {
                        ToastView.dismissLoadingToast()
                    }.then { _ in
                        ToastView.showWarningToast(title: "保存成功", existTime: nil, centerY: .low)
                    }.catch { (error) in
                        ToastView.showWarningToast(warningMessage: error.localizedDescription)
                    }
                } cancelHandler: { [weak self] () in
                    self?.saveMapSingleFloor()
                }
                alert.show()
            }, isPreferred: true),
            .init(style: .default, text: LocalizedString(key: notSaveMap))
        ])
    }

    private func saveMapMultiFloor() {
        showAlert(title: "地图数量已达上限，是否保存新地图？", message: "如点击“保存”，请选择新地图要覆盖哪张旧地图。", messageTextAlignment: .center, buttons: [
            .init(style: .default, text: LocalizedString(key: notSaveMap), color: .theme1),
            .init(style: .default, text: "保存", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let vc = SweeperCoverOldMapController()
                vc.sweeperControl = self?.sweeperControl
                self?.navigationController?.pushViewController(vc, animated: true)
            }, isPreferred: true)
        ])
    }

    private func isCurrentMapSaved() -> Bool {
        return map?.currentMapID == temporaryMapID
    }

    /// preMapID 为 nil，表示为第一次赋值
    private func currentMapDidChanged(preMap: SweeperMap?) {
        guard let map = map else {
            return
        }
        // 展示波纹动画条件： 1. 当前地图id为-2
        //                 2. 当前主状态为清扫中
        //                 3. 第一次进入主页面
        //                 4. 当前无地图I帧
        let needShowRobotWave = map.currentMapID == noMapID && sweeperControl?.basicState?.mainState == .cleaning && (preMap == nil || !hadStartWaveAnimation) && sweeperControl?.hadFrame == false
        if needShowRobotWave {
            startWaveAnimation()
        }
        /// preMapID 从 nil -> 0，未处理后退出主页重新进入
        /// 或 从 “-1” -> 0  表示成功创建，但还未自动保存新地图
        let preMapID = preMap?.currentMapID
        if (preMapID == nil || preMapID == isCreatingMapID) && map.currentMapID == temporaryMapID {
            ///  生成临时地图： 需要判断是多楼层还是单楼层来决定保存方式；
            guard let multiFloorEnabled = sweeperControl?.multiFloorEnabled, let maxMapNumber = sweeperControl?.capability?.maxMapNumber else {
                return
            }
            if multiFloorEnabled {
                if map.mapNumber > maxMapNumber && maxMapNumber > 0 && map.currentMapID == temporaryMapID {
                    // 地图已达上限且能力集中多楼层地图上限不为0，且当前地图是临时地图时，展示多楼层地图上限弹窗
                    needShowSaveMapMultiFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            } else {
                if map.mapNumber > 1 && map.currentMapID == temporaryMapID {
                    // 已经有一张地图且当前地图时临时地图时，展示单楼层地图上限弹窗。
                    needShowSaveMapSingleFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            }
            return
        }

        /// 成功创建，mapID 从 “-1” -> 大于0
        if preMapID == isCreatingMapID && map.currentMapID != noMapID && map.currentMapID != temporaryMapID && map.allMapNames.count == (preMap?.allMapNames.count ?? 0) + 1 {
            ///  生成完整地图：直接进入“已自动保存逻辑”
            needShowMapHasSavedTip = true
        }
    }

    private func showMapNotCompletedAlert(alertMessage: String, cancelHandler: ((UIAlertAction) -> Void)? = nil, defaultHandler: (() -> Void)? = nil) {
        showAlertWith(title: alertMessage, message: nil, messageTextAlignment: nil, defaultButtonTitle: "查看帮助", defaultButtonColor: .theme1, cancelButtonTitle: "关闭", cancelButtonColor: .theme1, cancelButtonHandler: cancelHandler, defaultButtonHandler: { [weak self] (_) in
            let vc = SweeperMapHelpViewController(type: .incomplete)
            self?.navigationController?.pushViewController(vc, animated: true)
            defaultHandler?()
        })
    }

    private func showCanNotCustomCleanAlert(isCreatingMap: Bool, defaultButtonhandler: ((UIAlertAction) -> Void)? = nil) {
        if isCreatingMap {
            showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持定制清扫", defaultHandler: { [weak self] () in
                self?.configurationView?.dismiss()
            })
        } else {
            showAlertWith(title: "请创建地图后再设置定制清扫", defaultButtonTitle: SharedResource.sharedFormatString(key: commonSure), defaultButtonColor: UIColor.black, cancelButtonTitle: nil, defaultButtonHandler: defaultButtonhandler)
        }
    }

    func showFastMapGuideView() {
        if fastMapImageView == nil {
            fastMapImageView = UIImageView()
            fastMapImageView?.image = UIImage.image(named: "quick_build_map")
            fastMapImageView?.sizeToFit()
        }
        guard let imageView = fastMapImageView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            fastMapGuideView?.dismiss()
            var offset: CGFloat = defaultButtonInterval
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            fastMapGuideView = presentGuideWith(viewToPresent: imageView, size: imageView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    func showMapHasSavedTip() {
        if savedMapNoticeView == nil {
            savedMapNoticeView = UIImageView()
            savedMapNoticeView?.image = UIImage.image(named: "edit_map")
            savedMapNoticeView?.sizeToFit()
        }
        guard let noticeView = savedMapNoticeView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            saveMapGuideView?.dismiss()
            var offset: CGFloat = 0
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            saveMapGuideView = presentGuideWith(viewToPresent: noticeView, size: noticeView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    override func collectionViewCell(_ cell: SweeperGlobalCleaningConfigurationCollectionViewCell, didSelectItemAt indexPath: IndexPath) {
        super.collectionViewCell(cell, didSelectItemAt: indexPath)

        let itemIndex = indexPath.section
        let row = indexPath.row
        let parameter = settingItems[itemIndex].paramters[row].type
        if parameter == .suctionForce(.none) {
            showAlertWith(title: "静音模式下吸尘能力将暂时降低，仅本次清扫任务生效。", message: nil, messageTextAlignment: nil, defaultButtonTitle: "确定", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonColor: .black, cancelButtonHandler: nil) { [weak self] (_) in
                self?.setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
            }
        } else {
            setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
        }
    }

    func setGlobalConfig(parameter: SweeperGlobalConfigurationType, itemIndex: Int) {
        var pendingConfig = sweeperControl?.globalCleaningConfig

        switch parameter {
        case .suctionForce(_):
            pendingConfig?.suction = parameter
        case .waterYield(_):
            pendingConfig?.waterYield = parameter
        case .sweepTimes(_):
            pendingConfig?.cleanTimes = parameter
        case .cleanMethod(_):
            pendingConfig?.cleanMethod = parameter
        case .mopMode(_):
            pendingConfig?.mopMode = parameter
        }


        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setGlobalCleaningConfig(device: deviceID, channel: channel, listType: listType, config: pendingConfig).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.then { [weak self] (_) in
            self?.sweeperControl?.globalCleaningConfig = pendingConfig
            self?.configurationView?.collectionView.reloadData()
            self?.updateParamUI()
        }
    }

    func startWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        let animationView = SweeperStartCleanAnimationView(frame: .zero)
        view.addSubview(animationView)

        animationView.snp.makeConstraints { make in
            make.centerX.equalToSuperview().offset(28)
            make.centerY.equalToSuperview().multipliedBy(0.764).offset(28)
            make.width.height.equalTo(56)
        }
        self.startCleanAnimationView = animationView
        animationView.startAnimation()
        hadStartWaveAnimation = true
    }

    func stopWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        startCleanAnimationView = nil
        hadStartWaveAnimation = false
    }

    private func cleanAllFlag() {
        needEntrySaveMapLogic = true
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true
        needShowMapHasSavedTip = false
        needShowSaveMapMultiFloor = false
        needShowSaveMapSingleFloor = false
        needEntrySaveMapLogicAfterBasicStateChanged = false
    }
}

// MARK: Button Action
private extension SweeperMainViewController {
    @objc func paramterButtonDidClick() {
        configurationView?.isSetSeq = isSetSweepSeq()
        configurationView?.isSetPreference = isSetPreference()
        configurationView?.show(view: self.navigationController?.view)
    }

    @objc func clearAreaButtonDidClick() {
        sweepAreaPopView = SweeperClearAreaPopView(type: cleaningModeType)
        sweepAreaPopView?.delegate = self
        sweepAreaPopView?.show()
    }

    @objc func startButtonDidClick() {
        guard (map?.currentMapID) != nil  else {
            return
        }
        if sweeperControl?.dataLoadingState == .success {
            setCleaningMode(type: .sweeping)
        } else {
            showAlertWithWholeHouseClean()
        }
    }

    @objc func stopButtonDidClick() {
        if status == .fastMapPause || status == .fastMap {
            showAlertWithFastMapEnd()
        } else {
            setCleaningMode(type: .stop)
        }
    }

    @objc func pasueButtonDidClick() {
        if status == .sweepingPause {
            setCleaningMode(type: .sweeping)
        } else if status == .fastMapPause {
            setCleaningMode(type: .fastMap)
        } else {
            setCleaningMode(type: .sweepingPause)
        }
    }

    @objc func previewButtonDidClick() {
        guard let mediaState = sweeperControl?.mediaState, checkEntryCondition() else {
            return
        }
        checkMediaStateAndJump(state: mediaState)
    }

    func checkMediaStateAndJump(state: SweeperMediaState) {
        // 若为被分享端，则不判断，直接进入人工驾驶页面
        if isSharedDevice {
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            vc.needShowSettingButton = false
            navigationController?.pushViewController(vc, animated: true)
            return
        }

        switch state {
        case .closed, .open:
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        case .openWithPermission:
            if sweeperControl?.mediaEncryptEnabled == true {
                // 视频加密开启，直接验证密码
                checkUnAuthenticated()
                return
            }
            // 视频加密关闭，需要检测设备空密码
            ToastView.showLoadingToast(cirleWithMessage: nil)
            requestCheckEmptyPassword {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func checkEntryCondition() -> Bool {
        if state?.collectDust == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterCollectionDust))
            return false
        }
        if state?.mopWashState == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterWashingMop))
            return false
        }
        return true
    }

    @objc func baseStationButtonDidClick() {
        if sweeperControl?.basicState?.cleanSinkState != .stop {
            let vc = SweeperBaseStationCleanSinkViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        } else {
            let vc = SweeperBaseStationMainViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func moreButtonDidClick() {
        let vc = SweeperMoreActionViewController(deviceID: deviceID, listType: listType)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    @objc func editButtonDidClick() {
        // 大于0的地图数量为0时(无已保存地图)并且没有地图，不允许进入，若mapID为“-1”允许进入
        if sweeperControl?.mapWithoutZero?.count == 0 && sweeperControl?.map?.currentMapID == noMapID {
            // 若扫地机在清扫、建图时，展示暂无地图
            if (state?.cleanFinished ?? true) {
                let fastMapGuideSheet = SweeperFastMapSheet()
                fastMapGuideSheet.delegate = self
                fastMapGuideSheet.show()
            } else {
                ToastView.showWarningToast(title: "暂无地图", existTime: nil, centerY: .low)
            }
            return
        }

        let alertActionSheet = TPActionSheet.init(title: nil)
        let setRigionAction = TPActionSheetAction.init(title: "设置禁区/虚拟墙", detail: "设置不允许扫地机器人进入的区域", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }

            // 清扫过程中进入编辑禁区页面需要暂停扫地机
            if self.status == .sweeping || self.status == .fastMap {
                self.setCleaningMode(type: .sweepingPause)
            }
            // 回充过程中进入编辑进去页面需要设置为待机
            if self.state?.mainState == .recharge {
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setStandBy(deviceID: self.deviceID, listType: self.listType).always {
                    ToastView.dismissLoadingToast()
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }
            }
            // 指哪到哪和遥控时不允许进入禁区页面
            if self.state?.mainState == .assignLocation || self.state?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterMission))
                return
            }
            let vc = SweeperForbiddenAreaVirtualWallViewController(sweeperControl: self.sweeperControl)
            self.navigationController?.pushViewController(vc, animated: true)
        }

        let editMapAreaAction = TPActionSheetAction.init(title: "编辑地图区域", detail: "划分地图区域并进行标记", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }
            /// 清扫、快速建图中不允许进入编辑区域页面
            if self.status != .stop {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterCleaning))
                return
            }
            /// 正在创建地图中不允许进入编辑区域页面
            guard self.map?.currentMapID != isCreatingMapID else {
                self.showMapNotCompletedAlert(alertMessage: LocalizedString(key: sweeperMapIsNotCompleteForEditingArea))
                return
            }
            let vc = SweeperEditMapAreaViewController(sweeperControl: self.sweeperControl)
            vc.isSetPreferenceOrOrder = self.isSetPreference() || self.isSetSweepSeq()
            self.navigationController?.pushViewController(vc, animated: true)
        }


        let manageMapAction = TPActionSheetAction.init(title: "管理地图", style: .leftTitle) { [weak self] (_) in
            guard let self = self else {
                return
            }
            let vc = SweeperMapManagerViewController()
            vc.delegate = self
            vc.deviceID = self.deviceID
            vc.listType = self.listType
            self.navigationController?.pushViewController(vc, animated: true)
        }

        var editActionArray: [TPActionSheetAction] = []
        editActionArray = map?.currentMapID == noMapID ? [manageMapAction] : [setRigionAction, editMapAreaAction, manageMapAction]

        editActionArray.forEach { (action) in
            action.font = .projectFont(ofSize: 16)
            action.detailFont = .projectFont(ofSize: 12)
            alertActionSheet.addAction(action)
        }
        alertActionSheet.separatorColor = .cellSeparatorGray

        alertActionSheet.show()
    }

    @objc func settingBarButtonItemDidClick() {
        if let vc = SweeperSettingViewController.create() {
            vc.deviceID = deviceID
            vc.listType = listType
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func rechargeButtonDidClick() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setRechargeState(device: deviceID, channel: channel, listType: listType, enabled: !isRecharging).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperRobotOfflineViewDelegate {
    func offlineHelpButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.requiredService?.goToOfflineHelp(deviceID: sweeperControl.deviceID, cloudID: sweeperControl.cloudID, listType: sweeperControl.listType, navigator: self.navigationController)
    }

    func offlineRefreshButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
        SweeperModule.shared.refreshSweeperControl()
    }
}

extension SweeperMainViewController: SweeperClearAreaPopViewDelegate {
    func updateData(with type: CleaningModeType) {
        if map?.currentMapID == isCreatingMapID {
            switch type {
            case .areaClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持区域清扫")
            case .pointClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持选框清扫")
            case .autoClean:
                // DO NOTHING
                break
            case .partClean:
                // DO NOTHING
                break
            case .pause:
                // DO NOTHING
                break
            case .stop:
                // DO NOTHING
                break
            case .fastMap:
                // DO NOTHING
                break
            }
            sweepAreaPopView?.dismiss()
            return
        } else {
            if type == .areaClean {
                if map?.currentMapID != noMapID {
                    ToastView.showWarningToast(title: "请选择区域", existTime: nil, centerY: .low)
                }
            }
        }
        self.cleaningModeType = type
        sweepAreaPopView?.dismiss()
    }
}

// MARK: setup UI
private extension SweeperMainViewController {
    func setupNavigation() {

        navigationItem.title = deviceDetail?.alias ?? "扫地机器人"

        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
        addCustomNavigationLeftBarButtonItem(title: nil, image: SharedResource.sharedImage(named: "common_light_back_nor"))
    }

    func setupButtons() {
        var title: String
        var imageName: String
        if isSharedDevice {
            title = "遥控"
            imageName = "ptz"
        } else {
            title = "视频遥控"
            imageName = "preview_light_nor"
        }
        previewButton = SweeperButton(title: title, fontSize: 9, image: UIImage.image(named: imageName))
        let previewTap = UITapGestureRecognizer.init(target: self, action: #selector(previewButtonDidClick))
        previewButton?.addGestureRecognizer(previewTap)
        if let button = previewButton {
            self.view.bringSubviewToFront(button)
        }
        if let previewButton = previewButton {
            buttonContainerStackView.addArrangedSubview(previewButton)
        }

        editButton = SweeperButton(title: "编辑地图", fontSize: 9, image: UIImage.image(named: "map_black_nor"))

        let editTap = UITapGestureRecognizer.init(target: self, action: #selector(editButtonDidClick))
        editButton?.addGestureRecognizer(editTap)
        if let editButton = editButton {
            buttonContainerStackView.addArrangedSubview(editButton)
        }

        baseStationButton = SweeperButton(title: "基站", fontSize: 9, image: UIImage.image(named: "sweeper_home"))

        let stationTap = UITapGestureRecognizer.init(target: self, action: #selector(baseStationButtonDidClick))
        baseStationButton?.addGestureRecognizer(stationTap)
        if let baseStationButton = baseStationButton {
            buttonContainerStackView.addArrangedSubview(baseStationButton)
        }

        moreButton = SweeperButton(title: "更多", fontSize: 9, image: UIImage.image(named: "star"))

        let moreButtonTap = UITapGestureRecognizer.init(target: self, action: #selector(moreButtonDidClick))
        moreButton?.addGestureRecognizer(moreButtonTap)
        if let moreButton = moreButton {
            buttonContainerStackView.addArrangedSubview(moreButton)
        }

        [previewButton, editButton, baseStationButton, moreButton].forEach { button in
            button?.snp.makeConstraints { make in
                make.width.equalTo(44)
                make.height.equalTo(47)
            }
        }

        /* buttonContainerStackView */
        view.addSubview(buttonContainerStackView)
        buttonContainerStackView.axis = .vertical
        buttonContainerStackView.alignment = .center
        buttonContainerStackView.spacing = 12
        buttonContainerStackView.snp.makeConstraints { make in
            make.width.equalTo(44)
            make.top.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }

        /* createMapButton */
        createMapContainer = SweeperCreateMapView()
        if let createMapContainer = createMapContainer {
            view.addSubview(createMapContainer)

            let goldenRatio: CGFloat = 0.382
            createMapContainer.snp.makeConstraints { make in
                make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2).offset(-(88 * goldenRatio))
                make.centerX.equalToSuperview()
                make.width.equalTo(230)
            }
        }
        createMapContainer?.isHidden = true

        /* chargeButton */
        chargeButton = SweeperButton(title: "返回基站", fontSize: 9, image: UIImage.image(named: "robot_charger"), offsetToTop: 5)
        addContraint(for: chargeButton, trailingToSuperView: -defaultButtonPadding)
        chargeButton.isHidden = true
        chargeButton.snp.makeConstraints { make in
            if let sweeperAlarmView = sweeperAlarmViewController {
                make.bottom.equalTo(sweeperAlarmView.view.snp.top).offset(-defaultButtonPadding / 2)
            } else {
                make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding)
            }
        }
        let chargeTap = UITapGestureRecognizer.init(target: self, action: #selector(rechargeButtonDidClick))
        chargeButton.addGestureRecognizer(chargeTap)

        parameterButton = SweeperButton(title: LocalizedString(key: sweeperCleanSweepAndMop), fontSize: 9, image: UIImage.image(named: "mode_general"), offsetToTop: 5)
        addContraint(for: parameterButton, trailingToSuperView: -defaultButtonPadding, bottomToSuperView: nil)
        parameterButton.snp.makeConstraints { (make) in
            make.bottom.equalTo(chargeButton.snp.bottom)
        }

        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        parameterButton.addGestureRecognizer(paramTap)

    }

    func setupOfflineView() {
        let offlineView = SweeperRobotOfflineView(frame: .zero)
        offlineView.delegate = self
        self.view.addSubview(offlineView)

        let goldenRatio: CGFloat = 0.382
        offlineView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2)
        }
        equipmentOfflineView = offlineView
        equipmentOfflineView?.isHidden = true
    }

    func updateNavigation() {
        if firstTimeUpdateNavigationTitle {
            navigationTitleView = SweeperTitleBatteryView(title: deviceDetail?.alias ?? "扫地机器人", stateText: "", power: 0, charge: false)
            navigationTitleView.snp.remakeConstraints { make in
                make.height.equalTo(44)
                make.width.equalTo(screenWidth - 150)
            }
            navigationItem.titleView = navigationTitleView
            firstTimeUpdateNavigationTitle = false
        }

        let stateText = state?.stateDescription ?? "故障中"
        let battery = state?.battery ?? 0
        let isCharging = state?.mainState == .charging
        navigationTitleView.setState(stateText: stateText, power: battery, charge: isCharging)
    }

    func updateEnvironmentView() {
        temperatureView.text = temperatureText
        humidityView.text = humidityText
    }

    func updateChargeButton() {
        chargeButton.isHidden = !shouldShowChargeButton
        if isRecharging {
            chargeButton.setTitle(title: "停止回充", buttonImage: UIImage.image(named: "robot_charge_stop"))
        } else {
            chargeButton.setTitle(title: "返回基站", buttonImage: UIImage.image(named: "robot_charger"))
        }
        if forbiddenRechargeAndClean {
            chargeButton.titleLabel.textColor = .lightGray3Color.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = false
        } else {
            chargeButton.titleLabel.textColor = .black.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = true
        }
    }

    func setupLoadingView() {
        view.addSubview(loadingView)
        loadingView.delegate = self
        loadingView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(0.764)
        }
    }

    func setupMapView() {
        let mapSize = sweeperControl?.mapSize ?? CGSize(width: defaultMapWidth, height: defaultMapHeight)
        mapView = SweeperHomeMapView(frame: .zero, mapSize: mapSize)
        mapView.backgroundColor = UIColor.clear
        view.addSubview(mapView)
        mapView.delegate = self
        mapView.sweeperIconMapView.delegate = self
        mapView.datasource = self
        mapView.isHidden = true

        mapView.snp.makeConstraints { make in
            make.top.trailing.leading.equalToSuperview()
            make.bottom.equalTo(sweepControlView.snp.top)
        }
        setupTapGesture()
    }

    func setupTapGesture() {
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(didTaped(recognizer:)))
        self.mapView.addGestureRecognizer(tapGesture)
    }

    func setupSweeperAlarmView() {
        let sweeperAlarmViewController = SweeperAlarmBannerViewController()
        sweeperAlarmViewController.window(from: .mainPage)
        sweeperAlarmViewController.sweeperControl = self.sweeperControl

        self.addChild(sweeperAlarmViewController)
        view.addSubview(sweeperAlarmViewController.view)
        sweeperAlarmViewController.view.snp.makeConstraints { make in
            make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding / 2)
            make.leading.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }
        self.sweeperAlarmViewController = sweeperAlarmViewController
    }

    @objc func didTaped(recognizer: UITapGestureRecognizer) {
        captureBubbleViewDismiss()
    }

    func setupEnvironmentView() {
        view.addSubview(environmentView)

        environmentView.snp.makeConstraints { make in
            make.height.equalTo(36)
            make.leading.top.equalToSuperview().offset(12)
        }
        environmentView.backgroundColor = .lightGray3Color.withAlphaComponent(0.1964)
        environmentView.layer.cornerRadius = 5

        [temperatureView, humidityView].forEach { label in
            environmentView.addSubview(label)

            label.backgroundColor = .clear
            label.textColor = .black.withAlphaComponent(0.6)
            label.textAlignment = .left
            label.font = .projectFont(ofSize: 10)
            label.snp.makeConstraints { make in
                make.height.equalTo(14)
                make.trailing.equalToSuperview().offset(-8)
                make.leading.equalToSuperview().offset(8)
            }
        }

        temperatureView.snp.makeConstraints { make in
            make.top.equalToSuperview().offset(4)
        }
        temperatureView.text = temperatureText

        humidityView.snp.makeConstraints { make in
            make.top.equalTo(temperatureView.snp.bottom)
        }
        humidityView.text = humidityText
    }

    func setupControlView() {
        addConstraint(forBottomView: sweepControlView, height: nil)
        sweepControlView.isHidden = true
        sweepControlViewHeightConstraint = NSLayoutConstraint(item: sweepControlView,
                                                             attribute: .height,
                                                             relatedBy: .equal,
                                                             toItem: nil,
                                                             attribute: .notAnAttribute,
                                                             multiplier: 1.0,
                                                             constant: 0)
        sweepControlViewHeightConstraint?.isActive = true

        // button clicked
        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        sweepControlView.parameterButton?.addGestureRecognizer(paramTap)

        let clearTap = UITapGestureRecognizer.init(target: self, action: #selector(clearAreaButtonDidClick))
        sweepControlView.clearAreaButton?.addGestureRecognizer(clearTap)

        let startTap = UITapGestureRecognizer.init(target: self, action: #selector(startButtonDidClick))
        sweepControlView.startButton.addGestureRecognizer(startTap)

        let stopTap = UITapGestureRecognizer.init(target: self, action: #selector(stopButtonDidClick))
        sweepControlView.stopButton.addGestureRecognizer(stopTap)

        let pauseTap = UITapGestureRecognizer.init(target: self, action: #selector(pasueButtonDidClick))
        sweepControlView.pauseButton.addGestureRecognizer(pauseTap)

    }

    func setupUpgradingView() {
        view.addSubview(sweeperBaseUpgradingView)
        sweeperBaseUpgradingView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingUpgradingView = false
    }

    func setupMechanicalOffView() {
        view.addSubview(sweeperMechanicalOffView)
        sweeperMechanicalOffView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingMechanicalView = false
        sweeperMechanicalOffView.delegate = self
    }

    func addConstraint(forBottomView bottomView: UIView?, height: CGFloat?) {
        guard let bottomView = bottomView else {
            return
        }
        bottomView.translatesAutoresizingMaskIntoConstraints = false

        view.addSubview(bottomView)

        // UI中设置的阴影radius为12，此处设置为8，才能与UI的效果一致。
        let shadowRadius: CGFloat = 8
        bottomView.layer.shadowOffset = .init(width: 0, height: 2)
        bottomView.layer.shadowRadius = shadowRadius
        bottomView.layer.shadowColor = UIColor.black.cgColor
        bottomView.layer.shadowOpacity = 0.16

        NSLayoutConstraint(item: bottomView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .width,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        if let height = height {
            NSLayoutConstraint(item: bottomView,
                               attribute: .height,
                               relatedBy: .equal,
                               toItem: nil,
                               attribute: .notAnAttribute,
                               multiplier: 1.0,
                               constant: height).isActive = true
        }

        NSLayoutConstraint(item: bottomView,
                           attribute: .bottom,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .bottom,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        NSLayoutConstraint(item: bottomView,
                           attribute: .centerX,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .centerX,
                           multiplier: 1.0,
                           constant: 0).isActive = true
    }

    func addContraint(for subView: UIView?, trailingToSuperView: CGFloat, topToSuperView: CGFloat? = nil, bottomToSuperView: CGFloat? = nil) {
        guard let subView = subView else {
            return
        }

        view.addSubview(subView)
        subView.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint(item: subView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 44).isActive = true
        NSLayoutConstraint(item: subView,
                           attribute: .height,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 47).isActive = true
        if let topToSuperView = topToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .top,
                               relatedBy: .equal,
                               toItem: view,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: topToSuperView).isActive = true
        }

        if let bottomToSuperView = bottomToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .bottom,
                               relatedBy: .equal,
                               toItem: bottomLayoutGuide,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: bottomToSuperView).isActive = true
        }

        NSLayoutConstraint(item: subView,
                           attribute: .trailing,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .trailing,
                           multiplier: 1.0,
                           constant: trailingToSuperView).isActive = true
    }
}

/// receive bitmap data
extension SweeperMainViewController: SweeperMapMediaPlayerListener {
    func mediaPlayerConnected(connectedSuccess: Bool) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if !connectedSuccess {
            dataLoadingStateChangeAction(loadingState: .failed)
        }
    }

    func dataLoadingStateChanged(loadingState: SweeperDataLoadingState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        dataLoadingStateChangeAction(loadingState: loadingState)
    }

    func mediaPlayerBitmapDataUpdate(dataType: MapMediaPlayerFrameFormat) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        /// 对扫地机地图正处于拖动或缩放时地图的刷新进行限制，避免卡顿的情况。
        guard !mapView.isOperation else {
            return
        }
        if dataType == .map {
            // 第一次收到I帧
            if sweeperControl?.hadFrame == true {
                stopWaveAnimation()
            }
            mapView.sweeperBitmapView.refreshBitmapImage()
            mapView.sweeperAreaView.refreshAreaView()
            if needRefreshMapViewInMediaPlayer {
                needRefreshMapViewInMediaPlayer = false
                mapView.refreshView()
            }
        }

        if sweeperControl?.hadFrame == true && dataType == .path {
            mapView.sweeperRouteView.refreshRouteView()
            // refresh equipment icon and charger pile location.
            mapView.sweeperIconMapView.refreshIconView()
        }
    }

    func mediaPlayerSignalling(mapID: String, type: SweeperConfigUpdateType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if type == .cleaningState {
            updateCleaningStateUI()
        } else if type == .cleaningMode || type == .cleanParam {
            updateCleaningModeUI()
        } else if type == .areaCleaning {
            mapView.updateCustomOrAutoMode()
            mapView.refreshAreaAndLabelView()
        } else if type == .globalCleaningConfig {
            // 修改全局清扫配置
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                cleanMethodMode = mode
                configurationView?.collectionView.reloadData()
            }
        } else {
            mapView.refreshView()
            mapView.refreshAreaAndLabelView()
        }
    }

    func mediaPlayerBasicStateDidChanged(preState: SweeperState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        basicStateChangeAction(showToast: true)
        sweeperAlarmViewController?.showAlarm()
        sweeperAlarmViewController?.showNotify()

        // 当前扫地机清扫结束时，若需要进入地图保存逻辑，则重新进入
        if !preState.cleanFinished && state?.cleanFinished == true && needEntrySaveMapLogicAfterBasicStateChanged {
            currentMapDidChanged(preMap: nil)
            saveMapLogic()
            needEntrySaveMapLogicAfterBasicStateChanged = false
        }
    }

    func mediaPlayerMapIDDidChanged(preMap: SweeperMap) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        currentMapDidChanged(preMap: preMap)

        /// 每次修改current map id 后， 地图的大小都会发生变化，故需要刷新初始地图的大小以适应屏幕
        mapView.restoreInitalMapView()
        mapView.shouldRefreshSize = true
        mapView.refreshView()
        mapView.updateCleanningModeAndSweepingState()
        mapView.updateCustomOrAutoMode()
        mapView.refreshAreaAndLabelView()
    }

    func mediaPlayerAlarm(type: SweeperAlarmType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        let alarm = SweeperAlarm(type: type)

        // 当前alarm需要在主页面显示、当基站升级、开关断开时不展示
        guard alarm.window.contains(.mainPage) && sweeperMechanicalOffView.isHidden && sweeperBaseUpgradingView.isHidden else {
            return
        }

        // 展示Toast
        if alarm.rank.contains(.toast),
           let message = alarm.toastTitle {
            ToastView.showWarningToast(title: message, existTime: nil, centerY: .low)
            return
        }

        // 展示Dialog，不展示只在基站展示的dialog
        if alarm.rank.contains(.dialog),
           !SweeperAlarm.baseDialogTypes.contains(type),
           let title = alarm.toastTitle {
            showAlertWith(title: title, message: alarm.toastContent, messageTextAlignment: .center, defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil, cancelButtonHandler: nil, defaultButtonHandler: nil)
            return
        }
    }
}

extension SweeperMainViewController: SweeperMapViewDataSource {
    func area(_ view: UIView, customCleanConfigurationIn areaID: Int) -> SweeperGlobalCleaningConfiguration? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaCleaningConfiguration
    }

    func area(_ view: UIView, infomationLayerMarkIn areaID: Int) -> String? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaLabel
    }

    func areaIDSet(_ in: UIView) -> [Int]? {
        return sweeperControl?.mapModel?.areaModel.areaIDs
    }

    func areaLabelLocation(_ view: UIView, areaID: Int) -> CGPoint? {
        return sweeperControl?.mapModel?.areaModel.areaLabelLocation[areaID]
    }

    func bitmapImage(_ view: UIView) -> CGImage? {
        return sweeperControl?.mapModel?.bitmapImage()
    }

    func bitmapOffset(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.offset
    }

    func bitmapSize(_ view: UIView) -> CGSize? {
        return sweeperControl?.mapModel?.bitmapSize
    }

    func areaData(_ view: UIView) -> [UInt8]? {
        return sweeperControl?.mapModel?.areaModel.areaData
    }

    func routeAllPointArray(_ view: UIView) -> [RoutePoint]? {
        return sweeperControl?.routeModel?.routePoints
    }

    func virtualWallIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.virtualWallModel?.wallIDs
    }

    func virutalWall(_ view: UIView, wallID: Int, isInEditMap: Bool) -> (CGPoint, CGPoint)? {
        return sweeperControl?.virtualWallModel?.couplePiontDictionary[wallID]
    }

    func forbiddenAreaIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.forbiddenAreaModel?.areaIDs
    }

    func forbiddenArea(_ view: UIView, areaID: Int, isInEditMap: Bool) -> RectangleArea? {
        return sweeperControl?.forbiddenAreaModel?.couplePiontDictionary[areaID]
    }

    func equipmentLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.routeModel?.equipmenLocation
    }

    func equipmentAngle(_ view: UIView) -> CGFloat? {
        return sweeperControl?.routeModel?.equipmenOritention
    }

    func chargePileLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.chargePileLocation
    }

    func barrierIDSet(_ view: UIView) -> [Int]? {
        if let keys = sweeperControl?.barriersModel?.barrierDictionary.keys {
            return Array(keys)
        } else {
            return nil
        }
    }

    func barrier(_ view: UIView, barrierModelIn barrierID: Int) -> SweeperBarrier? {
        return sweeperControl?.barriersModel?.barrierDictionary[barrierID]
    }

    func rectClean(_ view: UIView) -> (leftTopPoint: CGPoint, rightBottomPoint: CGPoint)? {
        if cleaningMode.leftTopPoint != .zero && cleaningMode.rightBottomPoint != .zero {
            return (cleaningMode.leftTopPoint, cleaningMode.rightBottomPoint)
        } else {
            return nil
        }
    }

    func mapScale(_ view: UIView) -> CGFloat? {
        return sweeperControl?.capability?.mapScale
    }
}

extension SweeperMainViewController: SweeperHomeMapViewDelegate {
    func hadMapFrame(_ view: SweeperHomeMapView) -> Bool? {
        return sweeperControl?.hadFrame
    }

    func areaSelected(_ view: SweeperHomeMapView) -> [Int]? {
        if cleaningModeType == .areaClean {
            return selectedLayerID
        } else {
            return nil
        }
    }

    func homeMapViewIsSetPreference(_ view: SweeperHomeMapView) -> Bool {
        return isSetPreference()
    }

    func homeMapViewIsSetSeq(_ view: SweeperHomeMapView) -> Bool {
        return isSetSweepSeq()
    }

    func layer(_ view: SweeperHomeMapView, layerSelectedSequence layerID: Int) -> Int? {
        if cleaningModeType == .areaClean, let orderID = selectedLayerID.firstIndex(of: layerID) {
            return orderID
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, layerCleaningOrder layerID: Int) -> Int? {
        if let order = sweeperControl?.mapModel?.areaModel.areaCleaningOrder,
           let orderID = order.firstIndex(of: layerID) {
            return orderID + 1
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, selectedLayer layerID: Int) {
        if let index = selectedLayerID.firstIndex(of: layerID) {
            selectedLayerID.remove(at: index)
        } else {
            selectedLayerID.append(layerID)
        }
        if cleaningModeType == .areaClean && !selectedLayerID.isEmpty {
            ToastView.showWarningToast(title: "已选择(selectedLayerID.count)个区域", existTime: nil, centerY: .low)
        }
        updateClearingAreaButton()
        mapView.refreshAreaAndLabelView()
    }
}

extension SweeperMainViewController {

    // 物体抓拍气泡展示
    private func captureBubbleViewShow(captureView: UIImageView, titleText: String, iconImage: UIImage, status: CaptureImageLoadingStatus, obstacleID: Int, thumbnail: UIImage? = nil) {
        sweepCaptureView.removeFromSuperview()
        captureBubbleViewLayout(captureView: captureView)
        sweepCaptureView.delegate = self

        // 更新障碍物抓拍气泡的展示
        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: thumbnail, obstacleID: obstacleID)

        // 更新障碍物抓拍是否有缩略图以及缩略图状态
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl?.barrierRecognitionEnabled ?? false, captureImageStatus: status)

        self.view.layoutIfNeeded()
        self.autoSuitPosition()
    }

    private func captureBubbleViewLayout(captureView: UIImageView) {
        self.mapView.addSubview(sweepCaptureView)
        sweepCaptureView.snp.remakeConstraints { make in
            make.centerX.equalTo(captureView.snp.centerX)
            make.bottom.equalTo(captureView.snp.top).offset(-12)
            make.width.equalTo(159)
            if sweeperControl?.barrierRecognitionEnabled ?? false {
                make.height.equalTo(128)
            } else {
                make.height.equalTo(40)
            }
        }
    }

    // 物体抓拍气泡隐藏
    private func captureBubbleViewDismiss() {
        sweepCaptureView.dismiss()
    }

    private func autoSuitPosition() {
        var offsetX: CGFloat = 0
        var offsetY: CGFloat = 0
        let maxXCoordinate = mapView.frame.width - sweepCaptureView.frame.width - 16
        if sweepCaptureView.frame.origin.x < 16 {
            offsetX = 16 - sweepCaptureView.frame.origin.x
        } else if sweepCaptureView.frame.origin.x > maxXCoordinate {
            offsetX = maxXCoordinate - sweepCaptureView.frame.origin.x
        }

        if sweepCaptureView.frame.origin.y < 16 {
            offsetY = 16 - sweepCaptureView.frame.origin.y
        }
        // 不用考虑底部超出边界，因为弹窗从顶部出现

        mapView.moveBy(x: offsetX, y: offsetY)
    }

    /// 刷新当前正在展示的气泡及其内容
    private func refreshBubbleView() {
        guard let sweeperControl = sweeperControl,
              let obstacleID = obstacleID,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              let iconImage = barrier.type.bigImage,
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            captureBubbleViewDismiss()
            return
        }
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
            return
        }

        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: .loading)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { [weak self] (status, image) in
            self?.sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: image, obstacleID: obstacleID)
            self?.sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: status)
        }
    }

}

extension SweeperMainViewController: SweeperMapManagerViewControllerDelegate {
    func mapManagerBeginSweep(_ controller: SweeperMapManagerViewController) {
        // 强制扫地机进入新建地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .autoClean)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    func mapManagerFastMap(_ controller: SweeperMapManagerViewController) {
        // 开始快速建图
        startFastMapAlert()
    }
}

extension SweeperMainViewController: SweeperCaptureBubbleViewDelegate {
    func captureNextButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.titleLabel.textColor = UIColor.black.withAlphaComponent(0.5)
        // 获取全部障碍物的详情页
        let sweepCaptureNextPageViewController = SweeperCaptureNextPageViewController(deviceID: deviceID, listType: listType)
        sweepCaptureNextPageViewController.delegate = self

        // 更新详情页跳转到具体哪个页面
        sweepCaptureNextPageViewController.obstacleID = captureView.obstacleID
        self.navigationController?.pushViewController(sweepCaptureNextPageViewController, animated: true)
    }

    func reloadButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.imageStatus = .loading
        let barrierID = captureView.obstacleID
        guard let fileID = sweeperControl?.barriersModel?.barrierDictionary[barrierID]?.fileID else {
            return captureView.imageStatus = .loadNoImage
        }

        SweeperDownloader.downloadObstacleImage(forDevice: deviceID, listType: listType, fileID: fileID) { status, image in
            captureView.imageStatus = status
            captureView.titleImageView.image = image
        }
    }

    func handleGestures(enable: Bool) {
        mapView.isGestureEnable = enable
    }
}

extension SweeperMainViewController: SweeperMainMapLoadingViewDelegate {
    func reloadButtonDidClick(_ UIView: SweeperMainMapLoadingView) {
        refreshMediaPlayerAndSweeperControl()
    }
}

extension SweeperMainViewController: SweeperIconMapViewDelegate {
    func didTapBaseStation(in view: SweeperIconMapView) {
        baseStationButtonDidClick()
    }

    func iconMap(_ view: SweeperIconMapView, transforToScreenPointFrom realPoint: CGPoint) -> CGPoint? {
        // 之前未调用
        return nil
    }

    func didTapObstacle(in view: UIImageView, obstacleID: Int) {

        guard let sweeperControl = sweeperControl,
              let iconImage = sweeperControl.barriersModel?.barrierDictionary[obstacleID]?.type.bigImage,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            return
        }
        self.obstacleID = obstacleID
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loadNoImage, obstacleID: obstacleID)
            return
        }

        self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loading, obstacleID: obstacleID)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { status, image in
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: status, obstacleID: obstacleID, thumbnail: image)
        }
    }
}

extension SweeperMainViewController: SweeperNewPasswordProtocol {
    func checkUnAuthenticated() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperModule.shared.requiredService?.checkUserInfo(deviceID: deviceID, listType: listType, completion: { [weak self] (success, errorCode) in
            ToastView.dismissLoadingToast()
            guard let self = self else {
                return
            }
            if success {
                self.goToPreview()
                return
            }

            if errorCode == TPSS_ASYNC_EC_TIMEOUT || errorCode == TPSS_COMM_EC_SYSTEM {
                /* 请求超时 */
                ToastView.showWarningToast(warningMessage: "网络错误")
                return
            }

            /* 设备锁定 */
            if errorCode == TPSS_COMM_EC_PREVIEW_LOCKED {
                self.showAlertWith(title: SharedResource.sharedString(key: sweeperPreviewLockedAlertTitle), defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil)
                return
            }

            /* 鉴权失败,弹出密码输入框 */
            self.presentInputPasswordVC(deviceID: self.deviceID, listType: self.listType)

        })
    }
}

extension SweeperMainViewController: SweeperVerifyPasswordProtocol {
    func verifySuccessHandler() {
        goToPreview()
    }
}

extension SweeperMainViewController: SweeperCaptureNextPageViewControllerDelegate {
    func ignoreButtonDidClick(sweeperCaptureNextPageViewController: SweeperCaptureNextPageViewController, barrierID: Int) {
        // 点击障碍物抓拍详情页的“忽略”所对应的障碍物Id
        guard let mapID = map?.currentMapID else {
             return
        }
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestIgnoreBarrier(device: deviceID, channel: channel, listType: listType, barrierID: "(barrierID)", mapID: mapID).always {
            ToastView.dismissLoadingToast()
        }.then { [weak self] (_) in
            ToastView.showWarningToast(warningMessage: "已忽略该物体")
            self?.sweepCaptureView.dismiss()
            self?.goBackToSweeperMainViewController()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperMechanicalOffViewDelegate {
    func refreshButtonDidClick(in: SweeperMechanicalOffView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        sweeperMechanicalOffView.refreshLoadingUI(connectedState: .loading)
        view.bringSubviewToFront(sweeperMechanicalOffView)
        SweeperService.getSweeperState(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType).then { [weak self] (state) in
            guard let state = state else {
                return
            }
            self?.showMechanicalOffView(switchOn: state.mechanicalSwitchOn)
        }
    }

    func showMechanicalOffView(switchOn: Bool) {
        // 若开关关闭
        if !switchOn {
            isShowingMechanicalView = true
            sweeperMechanicalOffView.refreshLoadingUI(connectedState: .off)
        } else {
            isShowingMechanicalView = false
        }
    }
}

extension SweeperMainViewController: SweeperMoreActionViewControllerDelegate {
    func cleanWholeHouse(in vc: SweeperMoreActionViewController) {
        showSweepTipsAlert()
    }
}

extension SweeperMainViewController: SweeperFastMapSheetDelegate {
    func startFastMap(view: SweeperFastMapSheet) {
        startFastMapAlert()
    }
}

extension String {
    func separatedBySemiColon(isAutoFill: Bool = true) -> (String, String?) {
        let seperator = self.contains(":") ? ":" : "："
        let separatedTexts: [String] = self.components(separatedBy: seperator)
        if !isAutoFill && separatedTexts.count == 1 {
            return (separatedTexts[0], nil)
        } else {
            return (separatedTexts.count >= 1 ? separatedTexts[0] : "", separatedTexts.count >= 2 ? separatedTexts[1] : "")
        }
    }
}
//
//  OnlineDeviceListMasterViewController.swift
//  SurveillanceHome
//
//  Created by Li Linfeng on 2019/12/9.
//  Copyright © 2019 tplink. All rights reserved.
//

import UIKit
import SurveillanceHomeBase
import SharedResource
import TPFoundation
import DeviceDetailModule
import NetService

private var pageIndexAssociatedObjectHandle: UInt8 = 0

final class OnlineDeviceListMasterViewController: BaseViewController {
    @IBOutlet private weak var groupCollectionView: UICollectionView!
    @IBOutlet private weak var groupToolbarShadowView: UIView!
    @IBOutlet private weak var groupToolbarContainer: UIView!
    @IBOutlet private weak var groupToolbarDropMenuButton: UIButton!
    @IBOutlet private weak var recentPreviewView: RecentPreviewView!
    @IBOutlet private weak var containerViewBottom2SuperViewBottomConstraint: NSLayoutConstraint!
    @IBOutlet private weak var containerViewTop2TopLayoutGuideBottomConstraint: NSLayoutConstraint!

    override var navigationBarTraits: [NavigationBarTrait] {
        return NavigationBarTrait.noSeparator
    }

    private var deviceGroups: [TPSSDeviceGroup] = []
    private var currentGroupIndex: Int = 0

    private var newCreateGroupName = ""

    private var pageController: UIPageViewController!
    private var deviceListVCCacheDictionary = [TPSSDeviceGroupID: OnlineDeviceListViewController]()
    private var transitionVCForPageController = UIViewController()
    lazy private var loginCacheVC = DeviceListLoginViewController.create()

    private var firstAppear = true
    private var shouldRecreate: Bool = false

    /// for routers' entry
    private var isLoginBefore = false

    var sdCardStatusShowed: SDCardStatusShowed = .none
    var diskStatusShowed: SDCardStatusShowed = .none

    // camera display
    private var shouldShowCameraDisplayNoActiveChannelAlert = false
    private var addChannelCameraDisplay: TPSSDeviceForDeviceList?

    // navigation
    private lazy var moreToolBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(moreToolsButtonClicked(_:)))
    }()

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_add_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(addDeviceButtonClicked(_:)))
    }()

    // MARK: guides and overlays
    private weak var addDeviceGuideView: GuidePresentationView?
    private weak var moreToolsPopoverView: GuidePresentationView?

    private lazy var groupPresenter = GroupListPresentationManager()
    private var presentedGroupList: GroupListViewController? {
        return presentedViewController as? GroupListViewController
    }

    private var currentList: OnlineDeviceListViewController {
        if let viewControllers = pageController.viewControllers, let firstViewController = viewControllers.first as? OnlineDeviceListViewController {
            return firstViewController
        }
        return OnlineDeviceListViewController()
    }

    private var isCloudLogin: Bool {
        return DeviceListModule.shared.requiredService?.isCloudLogin ?? false
    }

    private var isReordering = false                // 是否正在处于排序模式
    private var shouldToggleGroupModeAfterGetList = false   // 是否需要在获取列表结束后切换防护模式，仅在列表还未获取完时触发防护模式切换使用

    private var isShowing: Bool {
        return isShowing(ignorePresentedClasses: [UIAlertController.classForCoder()])
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        setupView()

        NotificationCenter.default.addObserver(self, selector: #selector(handleShowCameraDisplayNoActiveChannelAlertNotification(_:)), name: .ShowCameraDisplayNoActiveChannelAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleShowStorageDetectAlertNotification(_:)), name: .ShowStorageDetectAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListInvalidated), name: .DeviceListInvalidated, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListUpdated), name: .DeviceListUpdated, object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderBegined(_:)),
                                               name: .DeviceListReorderBegined,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderEnded(_:)),
                                               name: .DeviceListReorderEnded,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupAndDeviceList(_:)),
                                               name: .UpdateGroupAndDeviceListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: DeviceListNetworkObserver.localDeviceRefreshed,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupList(_:)),
                                               name: .UpdateGroupListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: .unbindDiscoveryFinished,
                                               object: nil)

        _ = DeviceListModule.shared.requiredService?.addEntrustObserver(observeTypes: [.entrustmentStop, .entrustmentExitByTrustee], { (_, _) in
            DeviceListManager.shared.updateDeviceList(of: DeviceListManager.shared.defaultGroupID).always {
                self.currentList.reload()
            }
        })
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        showGroupAndNavigationButton(true)
        if !isCloudLogin {
            showEmpty()
        } else if firstAppear {
            firstAppear = false
            restore()
        } else if shouldRecreate {
            shouldRecreate = false
            reload()
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        checkUpdateIfNeeded()

        if isCloudLogin {
            showPopoverGuideIfNeeded()
        }

        if shouldShowCameraDisplayNoActiveChannelAlert {
            shouldShowCameraDisplayNoActiveChannelAlert = false
            showCameraDisplayNoActiveChannelAlert()
        }
        updateGroupShadow()
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)

        dismissPresentedViews()
    }

    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let vc = segue.destination as? UIPageViewController {
            pageController = vc
            pageController.dataSource = self
            pageController.delegate = self
        }
    }

    private func refreshAfterGroupUpdated() {
        guard !isReordering else {
            return
        }

        guard isShowing else {
            // 如果分组刷新完，此时页面不是正在显示，则不进行页面刷新，仅记录状态，等回到本页面才统一进行刷新。
            // 需要注意通过记录状态后续回到页面才处理的逻辑，要与本方法后续处理逻辑要保持一致
            shouldRecreate = true
            return
        }

        reload()
    }

    private func showEmpty() {
        deviceGroups = []
        currentGroupIndex = -1

        showGroupAndNavigationButton(false)

        let emptyVC: UIViewController?
        // 有发现出来的/已绑定到局域网的设备时显示带登陆按钮的设备列表；没有则显示普通的登陆提示页
        if DeviceListManager.shared.unbindDetailDeviceList().count > 0 {
            emptyVC = createUnloginPage()
        } else {
            emptyVC = loginCacheVC
        }
        if let emptyVC = emptyVC {
            pageController.setViewControllers([emptyVC], direction: .forward, animated: false, completion: nil)
        }
        groupCollectionView.reloadData()
    }

    private func showGroupAndNavigationButton(_ shouldShow: Bool) {
        if shouldShow {
            navigationItem.leftBarButtonItem = moreToolBarButtonItem
            groupToolbarDropMenuButton.isHidden = false
        } else {
            navigationItem.leftBarButtonItem = nil
            groupToolbarDropMenuButton.isHidden = true
        }
    }

    private func restore() {
        deviceGroups = DeviceListManager.shared.groupList

        loadGroup(with: DeviceListManager.shared.lastSelectedGroupID)
    }

    private func reload(with preferredGroupID: String? = nil) {
        let oldGroupID = preferredGroupID ?? DeviceListManager.shared.lastSelectedGroupID
        deviceGroups = DeviceListManager.shared.groupList
        presentedGroupList?.groups = deviceGroups

        loadGroup(with: oldGroupID)
    }

    private func loadGroup(with groupID: String) {
        let currentGroup = DeviceListManager.shared.group(of: groupID) ?? DeviceListManager.shared.defaultGroup

        guard let groupIndex = deviceGroups.firstIndex(where: { $0.groupID == currentGroup.groupID }) else {
            return
        }

        currentGroupIndex = groupIndex

        presentedGroupList?.currentGroupID = currentGroup.groupID
        presentedGroupList?.reload()

        commonLoad()
    }

    private func commonLoad(animated: Bool = false, recreate: Bool = true) {
        groupCollectionView.reloadData()

        guard currentGroupIndex >= 0 else {
            return
        }

        groupCollectionView.scrollToItem(at: IndexPath(item: currentGroupIndex, section: 0), at: .right, animated: false)
        updateGroupShadow()

        if recreate, let vc = createPage(for: currentGroupIndex) {
            pageController.setViewControllers([vc], direction: .forward, animated: false, completion: nil)
        }

        storeGroupParameter()
    }

    private func updateGroupShadow() {
        groupToolbarShadowView.isHidden = groupCollectionView.bounds.maxX >= (groupCollectionView.contentSize.width - 1)
    }

    private func refreshAllDeviceLists() {
        if let viewController = pageController.viewControllers {
            viewController.forEach {
                if let vc = $0 as? OnlineDeviceListViewController {
                    vc.reload()
                }
            }
        }
    }

    private func createPage(for index: Int) -> OnlineDeviceListViewController? {
        let group = deviceGroups[index]
        guard let vc = createPage(for: group.groupID as TPSSDeviceGroupID) else {
            return nil
        }
        objc_setAssociatedObject(vc, &pageIndexAssociatedObjectHandle, index, .OBJC_ASSOCIATION_COPY_NONATOMIC)
        vc.realGroup = deviceGroups[index]
        return vc
    }

    private func createUnloginPage() -> OnlineDeviceListViewController? {
        return createPage(for: "unlogin page")
    }

    private func createPage(for key: TPSSDeviceGroupID) -> OnlineDeviceListViewController? {
        let vc: OnlineDeviceListViewController?
        if let item = deviceListVCCacheDictionary[key] {
            vc = item
        } else {
            vc = OnlineDeviceListViewController.create()
            deviceListVCCacheDictionary[key] = vc
        }
        return vc
    }
}

extension OnlineDeviceListMasterViewController: DeviceListUnwindDestination {}

// MARK: Popover handler
extension OnlineDeviceListMasterViewController {
    private func updateMenu() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let networkAvailable = NetworkManager.shared.isConnected
        let isInHomeMode = deviceGroups[currentGroupIndex].activeMode != .goOut
        let isBigCardMode = deviceGroups[currentGroupIndex].displayMode != .smallCard
        let homeModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_home_active") : DeviceListModule.image(named: "devicelist_home_disabled")
        let outModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_out_active") : DeviceListModule.image(named: "devicelist_out_disabled")
        DeviceGroupMenuItem.alarmMode.image = (isInHomeMode ? homeModeImage : outModeImage)?.withRenderingMode(.alwaysOriginal)
        DeviceGroupMenuItem.alarmMode.enabled = networkAvailable
        DeviceGroupMenuItem.alarmMode.title = isInHomeMode ? LocalizedString(key: deviceListModeHome) : LocalizedString(key: deviceListModeOut)
        DeviceGroupMenuItem.alarmMode.subtitle = isInHomeMode ? LocalizedString(key: deviceListSwitchModeToOut) : LocalizedString(key: deviceListSwitchModeToHome)
        DeviceGroupMenuItem.viewMode.title = isBigCardMode ? LocalizedString(key: deviceListViewGrid) : LocalizedString(key: deviceListViewList)
        DeviceGroupMenuItem.viewMode.subtitle = isBigCardMode ? LocalizedString(key: deviceListSwitchViewToList) : LocalizedString(key: deviceListSwitchViewToGrid)
        DeviceGroupMenuItem.viewMode.image = isBigCardMode ?  DeviceListModule.image(named: "devicelist_grid")?.withRenderingMode(.alwaysOriginal) : DeviceListModule.image(named: "devicelist_list")?.withRenderingMode(.alwaysOriginal)
    }

    private func handleDeviceGroupMenu(item: DeviceGroupMenuView.Item) {
        switch item {
        case .alarmMode:
            toggleGroupMode()
        case .search:
            navigateToSearch()
        case .viewMode:
            toggleDisplayMode()
        }
    }

    private func toggleGroupMode() {
        dismissPresentedViews()

        let deviceListUpdateStatus = DeviceListManager.shared.deviceListUpdateStatus
        if !deviceListUpdateStatus.cloudUpdateNecessaryInfoFinished {
            // 列表必要信息没获取到，此时若需要改变防护模式，就先请求获取数据并且loading，等所有信息获取完处理，避免数据不完整导致处理出错
            if !deviceListUpdateStatus.isUpdatingList {
                DeviceListManager.shared.updateGroupAndDeviceList()
            }
            shouldToggleGroupModeAfterGetList = true
            ToastView.showLoadingToast(cirleWithMessage: nil)
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.activeMode
        let newMode = group.activeMode == .goOut ? TPSSDeviceGroupMode.atHome : .goOut
        group.activeMode = newMode
        ToastView.showLoadingToast(cirleWithMessage: nil)
        DeviceListManager.shared.changeActiveMode(with: deviceGroups[currentGroupIndex]).then { () in
            self.currentList.reload()
            self.currentList.showToastForActiveMode(newMode)
        }.catch { (_) in
            group.activeMode = originalMode
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func toggleDisplayMode() {
        dismissPresentedViews()

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.displayMode
        let newMode = originalMode == .bigCard ? DeviceUIDisplayType.smallCard : .bigCard

        DeviceListManager.shared.changeDisplayMode(for: group.groupID, with: newMode)

        for section in 0..<currentList.collectionView.numberOfSections {
            for item in 0..<currentList.collectionView.numberOfItems(inSection: section) {
                if newMode == .smallCard {
                    currentList.fold(at: IndexPath(row: item, section: section))
                } else {
                    currentList.unfold(at: IndexPath(row: item, section: section))
                }
            }
        }

        currentList.reload()
    }

    private func navigateToSearch() {
        dismissPresentedViews()
        let allDevices = DeviceListManager.shared.allDetailDevices
        let allGroups = DeviceListManager.shared.groupList
        let vc = RemoteDeviceListSearchViewController(devices: allDevices, groups: allGroups)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }
}

extension OnlineDeviceListMasterViewController {
    // MARK: Popover
    private func showPopoverGuideIfNeeded() {
        // add device popover
        if UserDefaults.standard.object(forKey: deviceListLaunchKey) == nil {
            showAddDevicePopover()
            UserDefaults.standard.set(true, forKey: deviceListLaunchKey)
        }
    }

    private func showAddDevicePopover() {
        if !isShowing() {
            /* 如果界面切换了不要加载 */
            return
        }
        if let source = (navigationItem.rightBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            navigationController?.navigationBar.layoutIfNeeded()
            dismissPresentedViews()
            addDeviceGuideView = presentGuideWith(viewToPresent: TutorialGuideView.addDevice, size: TutorialGuideView.addDevice.frame.size, source: source, clickThrough: true)
            addDeviceGuideView?.delegate = self
        }
    }
}

extension OnlineDeviceListMasterViewController: GuidePresentationViewDelegate {
    func guidePresentationViewDidDismiss(_ view: GuidePresentationView) {
        if view == moreToolsPopoverView {
            navigationItem.leftBarButtonItem?.tintColor = UIColor(white: 0, alpha: 0.8)
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        }
    }
}

// MARK: - util
extension OnlineDeviceListMasterViewController {
    private func storeGroupParameter() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        DeviceListManager.shared.updateLastSelectGroupID(deviceGroups[currentGroupIndex].groupID)
    }
}

extension OnlineDeviceListMasterViewController {

    private func presentUpgradeInfo(appVersionInfo: AppUpgradeModuleBaseUpgradeInfo) {
        let alertViewController = DeviceListUpgradeAlertController(versionInfo: appVersionInfo)
        present(alertViewController, animated: true, completion: nil)
    }

    private func checkUpdateIfNeeded() {
        let requiredService = DeviceListModule.shared.requiredService
        guard requiredService?.shouldShowNewAppVersion() ?? false else {
            return
        }

        // 仅跳转至需要更新的包中（若对应版本的升级包needNotify为false，而另外版本的needNotify为true，会跳转至另一版本）
        if TPAppUtils.isTestFlightBeta() {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, appVersionInfo.needNotify, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        } else {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo, appVersionInfo.needNotify {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        }

    }
}

extension OnlineDeviceListMasterViewController: DeviceListSearchViewControllerDelegate {
    func navigateToGroup(group: TPSSDeviceGroup) {
        navigationController?.popViewController(animated: true)
        DispatchQueue.main.async {
            self.loadGroup(with: group.groupID)
        }
    }

    func navigateToSyncPreviewViewController(device: DeviceDetail) {
        goToSyncPreview(ipc: device, listType: device.listType)
    }

    func navigateToPreviewViewController(device: DeviceDetail, channel: TPSSChannelInfo?) {
        if device.deviceType == .smartLock {
            DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
            return
        }
        goToPreview(device: device, channel: channel)
    }

    func navigateToBatteryDoorbellViewController(device: DeviceDetail, fromNVR nvr: (deviceID: TPSSDeviceIdentifier, channel: UInt)?) {
        DeviceListModule.shared.requiredService?.navigateToBatteryDoorbellViewController(for: device.identifier, group: DeviceListManager.shared.defaultGroupID, listType: device.listType, navigator: navigationController, from: nvr?.deviceID, channelInNVR: nvr?.channel.intValue)
    }

    func navigateToNVRViewController(nvr: DeviceDetail) {
        var groupId = DeviceListManager.shared.defaultGroup.groupID
        if currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex {
            groupId  = deviceGroups[currentGroupIndex].groupID
        }
        goToNVR(nvr: nvr, groupID: groupId)
    }

    func navigateToSolarControllerManagerViewController(device: DeviceDetail) {
        goToSolarController(solarController: device)
    }

    func navigateToRouterManagerViewController(device: DeviceDetail) {
        goToRouter(device: device)
    }

    func navigateToSmartLockViewController(device: DeviceDetail) {
        DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
    }
}

// MARK: Navigation
extension OnlineDeviceListMasterViewController: PreviewControllerEntrance {
    func goToPreview(device: DeviceDetail, channel: TPSSChannelInfo?) {
        goToPreview(deviceID: device.identifier, channelID: channel?.channelId.intValue ?? -1, listType: device.listType)
    }

    func goToNVR(nvr: DeviceDetail, groupID: String? = nil) {
        let vc = NVRTabViewController()
        vc.cloudIdentifier = nvr.cloudDeviceID
        vc.deviceIdentifier = nvr.identifier
        vc.listType = nvr.listType
        vc.groupId = groupID
        navigationController?.pushViewController(vc, animated: true)
    }

    func goToSolarController(solarController: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToSolarControllerManagerViewController(deviceID: solarController.identifier, listType: solarController.listType, navigator: navigationController)
    }

    func goToRouter(device: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToRouterDefault(mac: device.mac, listType: device.listType, isOnline: device.online, navigator: navigationController)
    }
}

// MARK: Actions
extension OnlineDeviceListMasterViewController {
    private func dismissPresentedViews() {
        addDeviceGuideView?.dismiss()
        moreToolsPopoverView?.dismiss()

        presentedGroupList?.dismiss(animated: true, completion: nil)

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }

    @IBAction private func addDeviceButtonClicked(_ sender: Any) {
        guard isCloudLogin else {
            showAlertWith(title: LocalizedString(key: deviceListNotLogin), defaultButtonTitle: LocalizedString(key: deviceListLogin), defaultButtonHandler: { (_) in
                DeviceListModule.shared.requiredService?.navigateToLoginViewController(navigator: self.navigationController)
            })
            return
        }
        dismissPresentedViews()

        DeviceListModule.shared.requiredService?.presentDeviceAddViewController(viewController: self, listType: listType)
    }

    @IBAction private func moreToolsButtonClicked(_ sender: Any) {
        guard isCloudLogin else { return }

        if moreToolsPopoverView != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let size = CGSize(width: 212, height: 16 + DeviceGroupMenuView.Item.allCases.count * 44)
        let menuView = DeviceGroupMenuView(frame: CGRect(origin: .zero, size: size))
        menuView.action = handleDeviceGroupMenu

        dismissPresentedViews()

        updateMenu()

        if let source = (navigationItem.leftBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
            menuView.configurePopoverShadow(cornerRadius: 8)
            moreToolsPopoverView = presentGuideWith(viewToPresent: menuView, size: size, backgroundColor: .clear, source: source, offset: CGPoint(x: -12, y: 4))
            moreToolsPopoverView?.delegate = self
        }
        navigationItem.leftBarButtonItem?.tintColor = .theme1
    }

    @IBAction private func groupMenuToggled(_ sender: UIButton) {
        guard isCloudLogin else { return }

        if presentedViewController != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_up_small_normal"), for: .normal)

        let groups = DeviceListManager.shared.groupList
        guard let vc = GroupListViewController.create() else {
            return
        }
        let height = CGFloat(groups.count) * 52 + 72
        vc.preferredContentSize = CGSize(width: UIScreen.main.bounds.width, height: height)
        vc.modalPresentationStyle = .custom
        vc.transitioningDelegate = groupPresenter
        vc.groups = groups
        vc.currentGroupID = deviceGroups[currentGroupIndex].groupID
        vc.delegate = self
        present(vc, animated: true, completion: nil)
    }

    @IBAction private func recentPreviewClicked(_ sender: Any) {
        // 不会用到此按钮，但暂时保留
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDataSource {
    private func groupInformation(at index: Int) -> (String, Bool) {
        if deviceGroups.isEmpty { return (LocalizedString(key: deviceListMyDevice), true) }
        return (deviceGroups[index].groupName, index == currentGroupIndex)
    }

    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }

    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return max(1, deviceGroups.count)
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        return collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)
    }
}

extension OnlineDeviceListMasterViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        updateGroupShadow()
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDelegate {
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        if deviceGroups.isEmpty { return }
        dismissPresentedViews()
        loadGroup(with: deviceGroups[indexPath.item].groupID)
    }
}

extension OnlineDeviceListMasterViewController: DeviceGroupNameLayoutDelegate {
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, groupForItemAt indexPath: IndexPath) -> (name: String, selected: Bool) {
        return groupInformation(at: indexPath.item)
    }
}

// MARK: Page Management
extension OnlineDeviceListMasterViewController: UIPageViewControllerDataSource {
    func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex > 0 && currentGroupIndex < deviceGroups.count else { return nil }
        return createPage(for: currentGroupIndex - 1)
    }

    func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex >= 0 && currentGroupIndex < deviceGroups.count - 1 else { return nil }
        return createPage(for: currentGroupIndex + 1)
    }
}

extension OnlineDeviceListMasterViewController: UIPageViewControllerDelegate {
    func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
        if completed {
            if let viewControllers = pageViewController.viewControllers, let firtViewController = viewControllers.first {
                if let currentGroupIndex = objc_getAssociatedObject(firtViewController, &pageIndexAssociatedObjectHandle) as? Int {
                    self.currentGroupIndex = currentGroupIndex
                    commonLoad(animated: true, recreate: false)
                }
            }
        }
    }
}

// MARK: Group Management
extension OnlineDeviceListMasterViewController: GroupListViewControllerDelegate {
    func groupListViewController(_ groupListViewController: GroupListViewController, canMoveGroupTo destinationIndex: Int) -> Bool {
        guard deviceGroups.count > destinationIndex else {
            return false
        }
        let group = deviceGroups[destinationIndex]
        return !group.isDefaultGroup
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didMoveGroupAt sourceIndex: Int, to destinationIndex: Int) {
        // check if current group index has changed
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let originalGroup = deviceGroups[currentGroupIndex]
        deviceGroups.swapAt(sourceIndex, destinationIndex)
        if let newIndex = deviceGroups.firstIndex(of: originalGroup), currentGroupIndex != newIndex {
            currentGroupIndex = newIndex
        }
        // always invalidate page controller cache
        pageController.setViewControllers([currentList], direction: .forward, animated: false, completion: nil)
        groupCollectionView.moveItem(at: IndexPath(item: sourceIndex, section: 0), to: IndexPath(item: destinationIndex, section: 0))
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didSelectGroupAt index: Int) {
        dismissPresentedViews()
        loadGroup(with: deviceGroups[index].groupID)
    }

    func groupListViewControllerDidSelectCreatingNewGroup(_ groupListViewController: GroupListViewController) {
        dismissPresentedViews()
        guard let vc = CommonNameInputViewController.create() else {
            return
        }
        vc.navigationTitle = LocalizedString(key: deviceListSetGroupNameTitle)
        vc.doneButtonTitle = LocalizedString(key: commonNextStep)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didRequestEditingGroupAt index: Int) {
        dismissPresentedViews()
        guard let vc = GroupSettingViewController.create() else {
            return
        }
        vc.group = deviceGroups[index]
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewControllerDidDismiss(_ groupListViewController: GroupListViewController) {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
        _ = DeviceListManager.shared.updateGroupOrder(newGroup: deviceGroups)
    }
}

extension OnlineDeviceListMasterViewController: CommonNameInputViewControllerDelegate {
    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didCancelWith text: String) {
        navigationController?.popViewController(animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didFinishWith text: String) {
        guard deviceGroups.count > 0 else {
            navigationController?.popToViewController(self, animated: true)
            return
        }
        newCreateGroupName = text
        let vc = DeviceSelectionViewController(entry: .groupAddIndependent, group: DeviceListManager.shared.defaultGroupID, canProceedWithNoSelection: true)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, errorMessageFor text: String) -> (allowed: Bool, message: String?) {
        let error = TPSSDeviceListValidate.validateDeviceGroupName(text)
        if error != nil {
            return (true, error?.message)
        }

        if DeviceListManager.shared.groupList.contains(where: { $0.groupName == text }) {
            return (true, LocalizedString(key: deviceListNameExists))
        }
        return (true, nil)
    }

    func placeholderForNameInputViewController(_ nameInputViewController: CommonNameInputViewController) -> String? {
        return SharedResource.sharedString(key: shareStringLengthConstraint)
    }
}

extension OnlineDeviceListMasterViewController {
    @objc func handleShowCameraDisplayNoActiveChannelAlertNotification(_ noti: NSNotification) {
        if let (device, listType) = noti.object as? (DeviceDetail, TPSSDeviceListType), listType == .remote {
            shouldShowCameraDisplayNoActiveChannelAlert = true
            addChannelCameraDisplay = DeviceListManager.shared.device(with: device.identifier)
        }
    }

    @objc func handleShowStorageDetectAlertNotification(_ noti: NSNotification) {
        diskStatusShowed = .none
        sdCardStatusShowed = .none
    }

    private func showCameraDisplayNoActiveChannelAlert() {
        showAlertWith(title: LocalizedString(key: deviceAddCameraDisplayNoActiveChannelsTitle), defaultButtonTitle: LocalizedString(key: deviceAddAddNext), cancelButtonTitle: LocalizedString(key: commonNotNow), cancelButtonHandler: nil) { (_) in
            if let cameraDisplay = self.addChannelCameraDisplay {
                DeviceListModule.shared.requiredService?.navigateToCameraDisplayDiscoverViewController(deviceID: cameraDisplay.identifier, discoverType: .cameraDisplay, listType: self.listType, navigator: self.navigationController)
                // 需要在中间插一个ViewController
                let vc = NVRTabViewController()
                vc.cloudIdentifier = cameraDisplay.cloudDeviceId
                vc.deviceIdentifier = cameraDisplay.identifier
                vc.listType = .remote
                vc.hidesBottomBarWhenPushed = true
                if var tmpViewControllers = self.tpNavigationController?.viewControllers {
                    tmpViewControllers.insert(vc, at: tmpViewControllers.count - 1)
                    self.tpNavigationController?.setViewControllers(tmpViewControllers, animated: true)
                }
            }
        }
    }
}

extension OnlineDeviceListMasterViewController: DeviceSDCardStatusChecker {
    var listType: TPSSDeviceListType { return .remote }

    func formatProcessDidFinish() {
        currentList.reload()
    }
}

extension OnlineDeviceListMasterViewController: DeviceSelectionViewControllerDelegate {
    func deviceSelectionViewController(_ deviceSelectionViewController: DeviceSelectionViewController, didPressRightBarButtonItemWithDeviceChannels selectedDeviceChannels: [DeviceDetail: [ChannelId]]) {
        switch deviceSelectionViewController.entryType {
        case .groupAddIndependent:
            ToastView.showLoadingToast(cirleWithMessage: nil)

            let targetDeviceChannels = DeviceSelectionViewController.covertDeviceChannel(selectedDeviceChannels)
            DeviceListManager.shared.createGroup(name: newCreateGroupName, deviceChannelMap: targetDeviceChannels).always {
                ToastView.dismissLoadingToast()
            }.then { (groupID) in
                self.navigationController?.popToViewController(self, animated: true)
                self.reload(with: groupID)
            }.catch { (error) in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }
        default:
            break
        }
    }
}

// MARK: - notification
extension OnlineDeviceListMasterViewController {
    @objc private func handleDeviceListInvalidated() {
        shouldRecreate = true
        deviceListVCCacheDictionary.removeAll()
    }

    @objc private func handleDeviceListUpdated() {
        showUpdateAlertIfAny()
    }

    @objc private func handleReorderBegined(_ notification: Notification) {
        enterReorderMode()
    }

    @objc private func handleReorderEnded(_ notification: Notification) {
        exitReorderMode()
    }

    @objc private func handleUpdateGroupAndDeviceList(_ notification: Notification) {
        if isCloudLogin {
            handleGroupModeToggleAfterGetList(notification)
        } else if isShowing {
            // 处理非登录场景

            // 仅页面正在显示才处理数据获取结果更新页面状态，否则等viewWillAppear再处理。避免正在获取列表
            // 时切换到其它页面，列表获取有结果后触发本逻辑使得子VC触发viewWillAppear，后续真正展示页面时
            // 就不再触发viewWillAppear导致数据异常
            showEmpty()
        }
    }

    @objc private func handleLocalDeviceRefreshed(_ notification: Notification) {
        if !isCloudLogin && isShowing {
            // 非登录且页面正在显示时才需要处理因网络状态变化重新发现完的通知，因为此时可能需要在有/无设备的页面之间切换。
            // 如果页面没有在显示则不需要处理，因为viewWillAppear会触发该逻辑
            showEmpty()
        }
    }

    @objc private func handleUpdateGroupList(_ notification: Notification) {
        if let dic = notification.object as? [String: Any],
           let error = dic[DeviceListManager.notificationKeyError] as? Error {
            ToastView.showWarningToast(title: error.localizedDescription, existTime: nil, centerY: .lowest)
            return
        }
        // 失败也更新，此时显示默认分组
        refreshAfterGroupUpdated()
    }

    private func handleGroupModeToggleAfterGetList(_ notification: Notification) {
        let finishHandler: (() -> Void) = {
            if self.shouldToggleGroupModeAfterGetList {
                ToastView.dismissLoadingToast()
                self.shouldToggleGroupModeAfterGetList = false
                self.toggleGroupMode()
            }
        }

        guard let dic = notification.object as? [String: Any],
              let status = dic[DeviceListManager.notificationKeyListUpdateStatus] as? DeviceListUpdateStatus else {
            finishHandler()
            return
        }

        if status.cloudUpdateNecessaryInfoFinished {
            finishHandler()
        }
    }
}

extension OnlineDeviceListMasterViewController: Storyboarded {
    static var storyboardName: String { return "DeviceList" }
    static var storyboardBundle: Bundle? { return Bundle.deviceListModuelBundle }
}

extension Notification.Name {
    static var DeviceListUpdated: Notification.Name { return Notification.Name("DeviceListUpdated") }
}

// MARK: - setup
extension OnlineDeviceListMasterViewController {
    private func setupView() {
        setupBarButtonItems()
        setupButtons()
    }

    private func setupBarButtonItems() {
        navigationItem.leftBarButtonItem = moreToolBarButtonItem
        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
    }

    private func setupButtons() {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }
}

// MARK: - reorder
extension OnlineDeviceListMasterViewController {
    // 本vc不会主动进入排序模式，而是依赖于OnlineDeviceListViewController的通知
    private func enterReorderMode() {
        isReordering = true
        tabBarController?.tabBar.isUserInteractionEnabled = false
        groupToolbarContainer.isUserInteractionEnabled = false

        pageController.scrollEnable = false

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
    }

    private func showUpdateAlertIfAny() {
        if DeviceListManager.shared.allDetailDevices.contains(where: {(DeviceListModule.shared.requiredService?.onboardingTypeFromQRCode(qrCode: $0.qrCode) ?? 0) == TPSS_EC_GENERAL} ) || DeviceListManager.shared.hasUnsupportedDevice {
            // 二维码获取不支持的设备或者读取设备列表中有不支持的设备时，弹出升级提示
            let lastVersion: (isShow: Bool, versionCode: Int) = DeviceListModule.shared.requiredService?.checkShowUpdateAlert() ?? (false, 0)
            if lastVersion.isShow {
                showAlertWith(title: LocalizedString(key: commonNoticeUpdateAPP), message: nil, messageTextAlignment: nil,
                              defaultButtonTitle: LocalizedString(key: commonUpdateNow), defaultButtonColor: .theme1,
                              cancelButtonTitle: LocalizedString(key: commonIgnoreNotice), cancelButtonColor: .black.withAlphaComponent(0.8),
                              cancelButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.updateUserNoMoreNotify(version: lastVersion.versionCode)
                    self.showDiskAlertIfAny()
                }, defaultButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.jumpAndCheckAppVersion()
                    self.showDiskAlertIfAny()
                })
            } else {
                showDiskAlertIfAny()
            }
        } else {
            showDiskAlertIfAny()
        }
    }

    private func exitReorderMode() {
        tabBarController?.tabBar.isUserInteractionEnabled = true
        groupToolbarContainer.isUserInteractionEnabled = true

        pageController.scrollEnable = true

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }

        isReordering = false
    }
}
//
//  SweeperMainViewController.swift
//  Pods
//
//  Created by 爱迪生 on 2021/8/2.
//

import UIKit
import SurveillanceHomeBase
import Promises
import SwiftyJSON
import SharedResource
import TPFoundation
import SimplePlayer
import DeviceDetailModule
import SnapKit
import NetService
import ThemeTool

enum CaptureImageLoadingStatus: Equatable {
    case loadSuccess
    case failure
    case loading
    case loadNoImage
    case model(SweeperBarrierType)
}

enum MainMapLoadingState {
    case loading
    case failure
    case noMap
    case hasMap
}

class SweeperMainViewController: SweeperGlobalConfigurationViewController {
    var needShowFastMapGuide: Bool = false
    // MARK: subviews
    private var previewButton: SweeperButton?
    weak var inputPasswordVC: UIViewController?
    var inputPassword: String?
    private var editButton: SweeperButton?
    private var baseStationButton: SweeperButton?
    private var moreButton: SweeperButton?
    private var parameterButton = SweeperButton()
    private var navigationTitleView = SweeperTitleBatteryView()
    private var chargeButton = SweeperButton()
    private var createMapContainer: SweeperCreateMapView?
    private var sweepAreaPopView: SweeperClearAreaPopView?
    private var sweeperAlarmViewController: (UIViewController & SweeperAlarmWindowSuitable)?
    private var startCleanAnimationView: SweeperStartCleanAnimationView?
    private var mapView = SweeperHomeMapView(frame: .zero, mapSize: .init(width: 1200, height: 1200))
    private var loadingView = SweeperMainMapLoadingView(frame: .zero)
    private var buttonContainerStackView = UIStackView()
    private var environmentView = UIView(frame: .zero)
    private var temperatureView = UILabel(frame: .zero)
    private var humidityView = UILabel(frame: .zero)
    private var equipmentOfflineView: SweeperRobotOfflineView?

    private var sweepControlView = SweeperControlView()
    private var sweepCaptureView = SweeperCaptureBubbleView()
    private var sweeperBaseUpgradingView = SweeperBaseStationUpgradingView()
    private var sweeperMechanicalOffView = SweeperMechanicalOffView()

    private var sweepControlViewHeightConstraint: NSLayoutConstraint?
    private var heightForControlView: CGFloat {
        switch status {
        case .stop:
            return 88 + bottomSafeAreaInset
        case .fastMap, .fastMapPause:
            return 69 + bottomSafeAreaInset
        case .sweepingPause, .sweeping:
            return 143 + bottomSafeAreaInset
        }
    }

    enum AlarmButtonClickMode {
        case exit
        case more
        case none
    }
    private var alarmButtonClickMode: AlarmButtonClickMode = .exit

    // 快速建图引导view
    private var fastMapImageView: UIImageView?
    private var fastMapGuideView: GuidePresentationView?


    // 地图已自动保存通知
    private var savedMapNoticeView: UIImageView?
    private var saveMapGuideView: GuidePresentationView?
    // 存储设备详细信息
    private var deviceDetail: DeviceDetail?
    private var isSharedDevice: Bool {
        return deviceDetail?.isSharedDevice ?? false
    }

    private var robotOffline = false
    private var hadStartWaveAnimation = false

    /// 首次载入
    /// 第一帧地图帧/路径帧到来时刷新所有界面
    private var needRefreshMapViewInMediaPlayer = true
    private var needEntrySaveMapLogic = true
    private var needShowCleaningLog = true

    /// 该属性用于，当前保存地图弹窗弹出时，扫地机正在清扫。保存该弹出状态，在清扫结束后再进入一遍保存地图逻辑。
    private var needEntrySaveMapLogicAfterBasicStateChanged = false


    /// 在地图变化时，将下列是否需要展示“地图保存”弹窗标识为true
    /// 在dataloading成功时，进行展示
    private var needShowSaveMapMultiFloor = false
    private var needShowSaveMapSingleFloor = false
    private var needShowMapHasSavedTip = false

    /// 基站升级与关机页面展示
    private var isShowingUpgradingView: Bool {
        get {
            return !sweeperBaseUpgradingView.isHidden
        }
        set {
            sweeperBaseUpgradingView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var isShowingMechanicalView: Bool {
        get {
            return !sweeperMechanicalOffView.isHidden
        }
        set {
            sweeperMechanicalOffView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var shouldShowChargeButton: Bool {
        get {
            guard let state = state else {
                return false
            }
            // 清扫完成并且不在基站上
            return state.cleanFinished && !state.onboard
        }
    }

    private var firstTimeUpdateNavigationTitle: Bool = true

    private var cleaningMode: SweeperCleaningMode {
        get {
            return sweeperControl?.cleaningMode ?? SweeperCleaningMode.init(type: .autoClean)
        }
        set {
            sweeperControl?.cleaningMode = newValue
            updateCleaningModeUI()
        }
    }

    private var cleaningModeType: CleaningModeType {
        get {
            return cleaningMode.type
        }
        set {
            cleaningMode.type = newValue
        }
    }

    override var sweeperCustomOrAutoMode: SweeperCustomOrAutoMode {
        get {
            return (sweeperControl?.customCleanEnabled ?? false) ? .custom : .auto
        }
        set { }
    }

    private var map: SweeperMap? {
        get {
            return sweeperControl?.map
        }
        set {
            let preMap = map
            sweeperControl?.map = newValue
            currentMapDidChanged(preMap: preMap)
        }
    }

    private var status: SweeperProcedure = .stop

    private var state: SweeperState? {
        get {
            return sweeperControl?.basicState
        }

        set {
            sweeperControl?.basicState = newValue
            basicStateChangeAction(showToast: true)
        }
    }

    private var temperatureText: String {
        get {
            var text = "环境温度："
            if let temperature = state?.temperature {
                let temperatureValue = Int(temperature)
                if temperatureValue == 127 || temperatureValue < -40 {
                    text += "--"
                } else {
                    text += "(Int(temperature))℃"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var humidityText: String {
        get {
            var text = "环境湿度："
            if let humidity = state?.humidity {
                let humidityValue = Int(humidity)
                if humidityValue < 0 || humidityValue > 100 {
                    text += "--"
                } else {
                    text += "(Int(humidity))%"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var cleaningState: SweeperCleaningState? {
        get {
            return sweeperControl?.cleaningState
        }

        set {
            sweeperControl?.cleaningState = newValue
            updateCleaningStateUI()
        }
    }

    private var isRecharging: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .recharge
    }

    private var forbiddenRechargeAndClean: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .assignLocation || state.mainState == .remoteControl
    }

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = SharedResource.sharedImage(named: "shared_setting_icon_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(settingBarButtonItemDidClick))
    }()

    // selected layerID backup
    private var selectedLayerID = [Int]()

    // 当前展示的障碍物ID
    private var obstacleID: Int?

    override var navigationBarTraits: [NavigationBarTrait] {
        return [.hidden(on: false), .style(style: .default), .translucent(on: false), .barTint(color: .init(hexString: lightGray10Color)), .separatorStyle(color: .clear, height: 0.0), .backgroundImage(image: UIImage())]
    }

    // MARK: - Constants
    private let chargeButtonPadding = 8.0
    private let defaultButtonPadding = 12.0
    private let defaultButtonInterval = 59.0
    private let battreyThreshold = 20
    private let bottomSafeAreaInset = TPUIUtils.safeAreaInsets().bottom

    override init(deviceID: TPSSDeviceIdentifier, listType: TPSSDeviceListType) {
        super.init(deviceID: deviceID, listType: listType)

        SweeperModule.shared.registerControlListener(listener: self, deviceID: deviceID, listType: listType)
        SweeperModule.shared.registerMapListener(mapListener: self)
        NotificationCenter.default.addObserver(self, selector: #selector(willEnterForeground), name: UIApplication.willEnterForegroundNotification, object: nil)
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        view.backgroundColor = .init(hexString: lightGray10Color)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        setupNavigation()
        setupControlView()
        setupMapView()
        setupSweeperAlarmView()
        setupButtons()
        setupOfflineView()
        setupEnvironmentView()
        setupLoadingView()
        setupUpgradingView()
        setupMechanicalOffView()
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true

        // 离开当前页面时，会使动画失效，若正在展示动画，再重新进入时，需要重新开始动画
        if hadStartWaveAnimation {
            startWaveAnimation()
        }

        if let loadingState = sweeperControl?.dataLoadingState {
            dataLoadingStateChangeAction(loadingState: loadingState)
        } else {
            updateViewShowState(state: .failed)
        }
        captureBubbleViewDismiss()
        // 横幅始终展示在最前方
        if let alarmView = sweeperAlarmViewController?.view {
            view.bringSubviewToFront(alarmView)
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        if needShowFastMapGuide {
            showFastMapGuideView()
            needShowFastMapGuide = false
        }
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        savedMapNoticeView?.removeFromSuperview()
    }

    deinit {
        SweeperModule.shared.removeControlListener(listener: self)
        SweeperModule.shared.removeMapListener(mapListener: self)
        NotificationCenter.default.removeObserver(self)
    }

    // 将从后台切换到前台，看作视图willAppear，方法作相同处理
    @objc func willEnterForeground() {
        cleanAllFlag()

        // 若当前的载入状态为loading时，对UI进行loading状态的刷新。
        // 否则等待dataLoadingStateDidChanged方法回调(从 loading -> 其他状态)。
        // 注：dataLoadingStateDidChanged方法在 loading -> loading 时不会被调用。
        if sweeperControl?.dataLoadingState == .loading {
            dataLoadingStateChanged(loadingState: .loading)
        }
    }

    /// 根据载入状态更新主页面View的展示情况
    /// -主页面加载状态 -
    /// 需要管理的控件：创建地图按钮、主页面地图、载入（载入失败）页面、编辑地图按钮、边扫边拖（定制清扫）悬浮按钮
    private func updateViewShowState(state: SweeperDataLoadingState) {
        switch state {
            case .loading:
                loadingView.isHidden = false
                loadingView.isLoadingFailure = false
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
            case .failed:
                loadingView.isLoadingFailure = true
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
                // 若扫地机离线，则展示离线页面，否则展示加载失败页面
                loadingView.isHidden = robotOffline
                equipmentOfflineView?.isHidden = !robotOffline
            case .noMap:
                createMapContainer?.isHidden = false
                loadingView.isHidden = true
                mapView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                parameterButton.isHidden = false
                moreButton?.isHidden = false
                editButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
            case .success:
                loadingView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                mapView.isHidden = false
                createMapContainer?.isHidden = true
                parameterButton.isHidden = false
                editButton?.isHidden = false
                moreButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
        }
    }

    override func willUpdateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode, showAlert: Bool) -> Bool {
        /// 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            if showAlert {
                showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap)
            }
            return false
        }
        return super.willUpdateSweeperCustomOrAutoMode(newMode: newMode, showAlert: showAlert)
    }

    override func updateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode) {
        /// 1. 若切换时当前清扫模式与newMode相同，则无需进入后续逻辑
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap,
              let sweeperControl = sweeperControl,
              let mapID = sweeperControl.map?.currentMapID,
              newMode != sweeperCustomOrAutoMode else {
            return
        }

        /// 2. 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap) { [weak self] (_) in
                self?.configurationView?.selectSegment(type: .auto)
            }
            return
        }

        /// 3. 切换为定制清扫时，无设置清扫顺序与清扫偏好，则不向设备发送请求（并在退出弹窗时（configurationFinished）切换回变扫边拖）
        if newMode == .custom && !isSetPreference() && !isSetSweepSeq() {
            return
        }

        /// 4. 发送切换清扫模式的接口，并修改主页面UI
        let customCleanEnabled = newMode == .custom
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestSetCleaningParam(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: mapID, customEnabled: customCleanEnabled).always {
            ToastView.dismissLoadingToast()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }

    override func configurationFinished() {
        /// 若configurationView当前处于定制清扫页面（“1”状态），则判断是否已设置定制清扫，若否切回边扫边拖。
        if !isSetPreference() && !isSetSweepSeq() && !settingButtonDidClickFlag && configurationView?.segmentedControl.selectedSegmentIndex == 1 {
            ToastView.showWarningToast(title: "未设置定制清扫，只能使用普通清扫", existTime: nil, centerY: .low)
            // 0 - means auto cleaning
            configurationView?.selectSegment(type: .auto)
        }
    }

    override func preferenceButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.preferenceButtonClickOperation()
    }

    override func sweepOrderButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.sweepOrderButtonClickOperation()
    }

    private func refreshMediaPlayerAndSweeperControl() {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.refreshSweeperControl()
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
    }

    private func updateConfigurationView() {
        configurationView?.selectSegment(type: sweeperCustomOrAutoMode)
        if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
            cleanMethodMode = mode
        }
    }

    private func updateClearingAreaButton() {
        var text = "全屋"
        var imagePath = "sweep_home"
        var title = text
        switch cleaningModeType {
        case .pointClean:
            text = "选框"
            title = text
            imagePath = "sweep_frame"
        case .areaClean:
            text = "区域"
            title = text
            imagePath = "sweep_region"
        case .autoClean:
            text = "全屋"
            title = text
            imagePath = "sweep_home"
        case .partClean:
            // 仅在sweepControlView的RangeTitle中修改
            updateData(with: .autoClean)
            title = "局部"
        case .fastMap:
            // DO NOTHING
            return
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
        sweepControlView.clearAreaButton?.titleLabel.text = text
        sweepControlView.clearAreaButton?.titleImageView.image = UIImage.image(named: imagePath)
        sweepControlView.rangeTitleLabel.text = title
        sweepControlView.clearAreaButton?.selectedAreaNumber = cleaningModeType == .areaClean ? selectedLayerID.count : 0
    }

    private func updateSweeperHomeMapViewCleanMode() {
        switch cleaningModeType {
        case .pointClean:
            mapView.cleaningModeType = .pointClean
        case .areaClean:
            mapView.cleaningModeType = .areaClean
        case .autoClean:
            mapView.cleaningModeType = .autoClean
        case .partClean:
            mapView.cleaningModeType = .partClean
        case .fastMap:
            mapView.cleaningModeType = .fastMap
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
    }

    private func updateSelectedLayerID() {
        if let seq = sweeperControl?.cleaningMode.areaIDs {
            selectedLayerID = seq
        }
    }

    private func updateParamUI() {
        var text = ""
        var imagePath = ""
        switch sweeperCustomOrAutoMode {
        case .auto:
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                switch mode {
                case .sweep:
                    text = LocalizedString(key: sweeperCleanOnlySweep)
                    imagePath = "mode_sweep"
                case .mop:
                    text = LocalizedString(key: sweeperCleanOnlyMop)
                    imagePath = "mode_mop"
                case .both:
                    text = LocalizedString(key: sweeperCleanSweepAndMop)
                    imagePath = "mode_sweep_mop"
                }
            }
        case .custom:
            text = LocalizedString(key: sweeperCustomClean)
            imagePath = "mode_diy"
        }
        let image = UIImage.image(named: imagePath)
        // 控制栏的参数按钮
        sweepControlView.parameterButton?.titleLabel.text = text
        sweepControlView.parameterButton?.titleImageView.image = image

        // 悬浮的参数按钮
        parameterButton.titleLabel.text = text
        parameterButton.titleImageView.image = image
    }

    private func updateSweeperHomeMapViewCustomOrAutoMode() {
        switch sweeperCustomOrAutoMode {
        case .auto:
            mapView.sweeperCustomOrAutoMode = .auto
        case .custom:
            mapView.sweeperCustomOrAutoMode = .custom
        }
    }

    private func dataLoadingStateChangeAction(loadingState: SweeperDataLoadingState) {
        // 1. 判断设备是否离线（deviceDetail.online）
        if loadingState == .failed {
            robotOffline = !(deviceDetail?.online ?? false)
        }

        // 2. 判断基站是否升级，若是，则不展示所有UI（除了导航栏）
        if state?.chargeBaseUpgrading == true {
            isShowingUpgradingView = true
            updateNavigation()
            return
        }

        if let switchOn = state?.mechanicalSwitchOn {
            showMechanicalOffView(switchOn: switchOn)
        }

        // 3. 刷新UI状态(是否hidden)
        updateViewShowState(state: loadingState)

        // 4. 载入成功（success or nomap）按照其他状态展示UI
        if loadingState == .success {
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            mapView.updateCleanningModeAndSweepingState()
            mapView.updateCustomOrAutoMode()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            sweeperAlarmViewController?.showAlarm()
            sweeperAlarmViewController?.showNotify()
            if needShowCleaningLog {
                sweeperAlarmViewController?.showCleaningLog()
                needShowCleaningLog = false
            }
            if needEntrySaveMapLogic {
                currentMapDidChanged(preMap: nil)
                needEntrySaveMapLogic = false
            }
            saveMapLogic()
        } else if loadingState == .noMap {
            // 尽管当前map id 为-2，但当设备发送地图帧过来时，仍然需要展示地图，故仍然需要刷新mapView
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            sweeperAlarmViewController?.showCleaningLog()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            // 用户未进入引导页，且当前不在清扫、建图中，需要进入快速建图引导页
            if UserDefaults.standard.shouldShowGuideForFastMap(for: deviceID) && (state?.cleanFinished ?? true) {
                let vc = SweeperFastMapGuideViewController(deviceID: deviceID, listType: listType)
                navigationController?.pushViewController(vc, animated: true)
            }
        }
    }

    private func saveMapLogic() {
        // 若需要展示弹窗，但当前在清扫中，则将弹窗状态保存起来，待扫地机状态变化时重新进入。
        if state?.cleanFinished == false && (needShowSaveMapSingleFloor || needShowSaveMapMultiFloor) {
            needEntrySaveMapLogicAfterBasicStateChanged = true
            return
        }
        if needShowMapHasSavedTip {
            showMapHasSavedTip()
            needShowMapHasSavedTip = false
        }
        if needShowSaveMapSingleFloor {
            saveMapSingleFloor()
            needShowSaveMapSingleFloor = false
        }
        if needShowSaveMapMultiFloor {
            saveMapMultiFloor()
            needShowSaveMapMultiFloor = false
        }
    }

    private func basicStateChangeAction(showToast: Bool) {
        // 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 展示波纹动画: 1. 当前地图ID为-2；
        //             2. 当前在清扫中；
        //             3. 未展示过动画
        //             4. 无地图帧
        if map?.currentMapID == noMapID
            && state?.cleanFinished == false && !hadStartWaveAnimation && sweeperControl?.hadFrame == false {
            startWaveAnimation()
        }
        if (state?.cleanFinished == true) {
            stopWaveAnimation()
        }
        // 特殊情况处理，当扫地机进入清扫状态时
        // 且当前处于无地图时，需要显示地图（而非等到map更改的信令进行变化）
        // 再次变为非清扫状态，且无地图时，需要展示无地图Image
        if map?.currentMapID == noMapID && state?.cleanFinished == false {
            updateViewShowState(state: .success)
        } else if map?.currentMapID == noMapID && state?.cleanFinished == true {
            updateViewShowState(state: .noMap)
        }

        // 扫地机关机状态更新
        showMechanicalOffView(switchOn: state?.mechanicalSwitchOn ?? false)

        if showToast {
            updateBasicStateToastView()
        }
        // 更新扫地机当前的清扫状态（将扫地机状态分为清扫中、暂停中、未清扫，后续根据该status更新清扫UI）
        updateSweepProduce()

        updateUI()
    }

    /// 使用Clean Finished，fast Map  字段与 basic state字段联合判断当前清扫是否结束
    private func updateSweepProduce() {
        guard let state = state else {
            status = .stop
            return
        }
        if state.cleanFinished && state.mainState != .paused && state.mainState != .cleaning {
            // 若设备清扫完成且设备主状态不在清扫、暂停时
            status = .stop
        } else {
            if state.fastMap {
                // 若为快速建图
                if state.mainState == .cleaning {
                    status = .fastMap
                } else {
                    status = .fastMapPause
                }
            } else {
                // 若不为快速建图，则展示正常清扫UI
                if state.mainState == .cleaning {
                   status = .sweeping
                } else {
                   status = .sweepingPause
                }
            }
        }
    }

    // 根据信令展示ToastView
    private func updateBasicStateToastView() {
        guard let state = state else {
            return
        }
        // 主状态为回充，遥控，清扫时候，主页均需展示loading
        if ((state.mainState == .cleaning || state.mainState == .recharge || state.mainState == .remoteControl) && state.subState == .relocate) {
            ToastView.showLoadingToast(cirleWithMessage: "定位中...", existTime: 60, existMessage: nil)
        } else {
            ToastView.dismissLoadingToast()
        }
    }

    /// 根据status更新：清扫面板、清扫参数、导航栏里扫地机的状态、回充按钮、提示栏的位置；
    /// status:     sweeping：当cleanFinished为false，且mainState为Cleaning，subState为Sweeping；
    ///        pause：当cleanFinished为false，
    private func updateUI() {
        // 只当地图数据载入完成之后，更新信令收到后的UI
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 每次收到信令后，获取设备状态，更新设备状态同时更新界面UI

        // 控制面板
        sweepControlView.status = status
        sweepControlViewHeightConstraint?.constant = heightForControlView
        if status == .stop {
            // 清扫参数按钮
            parameterButton.isHidden = true
            // 地图控件
            mapView.isSweeping = false
        } else if status == .fastMap || status == .fastMapPause {
            mapView.isSweeping = true
            parameterButton.isHidden = true
        } else {
            parameterButton.isHidden = false
            mapView.isSweeping = true
        }
        // 导航栏的状态和电量
        updateNavigation()
        // 温度湿度更新
        updateEnvironmentView()
        // 充电按钮
        updateChargeButton()
        refreshBubbleView()
    }

    private func updateCleaningStateUI() {
        guard let state = cleaningState else {
            return
        }
        sweepControlView.areaTitleLabel.text = "(state.cleaningArea)㎡"
        sweepControlView.timeTitleLabel.text = "(state.cleaningTime)min"
    }

    private func updateCleaningModeUI() {
        /// 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        /// 修改设置清扫模式（cleaningMode）按钮的样式
        updateClearingAreaButton()
        /// 修改地图的清扫模式
        updateSweeperHomeMapViewCleanMode()
        /// 根据获取到的cleaningMode中区域清扫的ID，更新地图区域的清扫顺序数组
        updateSelectedLayerID()
        /// 修改定制清扫/边扫边拖属性 - 通过回调去更新该属性更新后主页后续的UI。回调中调用的方法 - updateSweeperCustomOrAutoMode()
        updateConfigurationView()
        /// 修改定制清扫/边扫边拖按钮的样式
        updateParamUI()
        /// 修改定制清扫/边扫边拖地图的样式
        updateSweeperHomeMapViewCustomOrAutoMode()
    }

    private func showAlertWithWholeHouseClean() {
        showAlertWith(title: "进行一次全屋清扫", message: "清扫完成后，将建立家居地图。", messageTextAlignment: .center, defaultButtonTitle: "进行全屋清扫", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonHandler: nil) { [weak self] (_) in
            self?.showSweepTipsAlert()
        }
    }

    private func startFastMap() {
        if sweeperControl?.basicState?.mainState == .remoteControl {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFastMapDuringRemoteControl))
            return
        }
        if sweeperControl?.basicState?.mainState == .assignLocation {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFAstMapDuringAssignLocation))
            return
        }
        // 强制扫地机进入新建快速地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .fastMap)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: self.deviceID, channel: self.channel, listType: self.listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func startFastMapAlert() {
        let alert = SweeperTipsAlert(type: .fastMap) { [weak self] () in
            guard let self = self else { return }
            self.startFastMap()
        }
        alert.show()
    }

    private func showAlertWithFastMapEnd() {
        showAlertWith(title: "尚未得到完整地图，确定要结束吗？", message: nil, messageTextAlignment: .center, defaultButtonTitle: "结束建图", defaultButtonColor: .theme1, cancelButtonTitle: "继续", cancelButtonHandler: nil) { [weak self] (_) in
            self?.setCleaningMode(type: .stop)
        }
    }

    private func showSweepTipsAlert() {
        let alert = SweeperTipsAlert(type: .clean) { [weak self] () in
            self?.setCleaningMode(type: .sweeping)
        }
        alert.show()
    }

    private func setCleaningMode(type: SweeperProcedure) {
        switch type {
        case .sweeping:
            if sweeperControl?.basicState?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringRemoteControl))
                return
            }
            if sweeperControl?.basicState?.mainState == .assignLocation {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringAssignLocation))
                return
            }
            // 若扫地机当前无地图，则所有“清扫”操作为全屋清扫。
            if map?.currentMapID == noMapID {
                self.cleaningMode = SweeperCleaningMode.init(type: .autoClean)
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: SweeperCleaningMode.init(type: .autoClean)).catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
                return
            }

            if cleaningModeType == .areaClean {
                if selectedLayerID.count == 0 {
                    ToastView.showWarningToast(title: "请选择需要清扫的区域", existTime: nil, centerY: .low)
                    return
                }
                sweeperControl?.cleaningMode.areaIDs = selectedLayerID
            } else if cleaningModeType == .pointClean,
                      let partArea = mapView.getSelectionRect() {
                // 若能够从SelectionRect获取到数据，则修改cleaningMode的PointRect
                sweeperControl?.cleaningMode.leftTopPoint = partArea.leftTopPoint
                sweeperControl?.cleaningMode.rightBottomPoint = partArea.rightBottomPoint
            } else {
                sweeperControl?.cleaningMode = .init(type: .autoClean)
            }

            ToastView.showLoadingToast(cirleWithMessage: nil)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: sweeperControl?.cleaningMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .sweepingPause, .fastMapPause:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .pause)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .stop:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .stop)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .fastMap:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .fastMap)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func saveMapSingleFloor() {
        let deleteMapID = map?.allMapNames.keys.first(where: { (mapID) -> Bool in
                  return mapID != temporaryMapID
              })
        guard let sweeperControl = sweeperControl,
              let deleteMapID = deleteMapID,
              let deleteMapName = map?.allMapNames[deleteMapID] else {
            return
        }
        showAlert(title: "是否保存新地图?", buttons: [
            .init(style: .default, text: "更新“(deleteMapName)”", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                ToastView.showLoadingToast(cirleWithMessage: "正在更新")
                SweeperService.deleteMap(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: deleteMapID).then { (_) in
                    ToastView.showWarningToast(title: "更新成功", existTime: nil, centerY: .low)
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
            }),
            .init(style: .default, text: "另存为新地图", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let alert = SweeperSelectionAlert(title: "相同环境请勿保存多张地图，有可能影响机器人的定位。", message: "我家为多楼层户型") {
                    guard self?.isCurrentMapSaved() == true else {
                        ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                        return
                    }
                    ToastView.showLoadingToast(cirleWithMessage: "正在保存")
                    SweeperService.setMultiFloorEnabled(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, enabled: true, mapID: nil).always {
                        ToastView.dismissLoadingToast()
                    }.then { _ in
                        ToastView.showWarningToast(title: "保存成功", existTime: nil, centerY: .low)
                    }.catch { (error) in
                        ToastView.showWarningToast(warningMessage: error.localizedDescription)
                    }
                } cancelHandler: { [weak self] () in
                    self?.saveMapSingleFloor()
                }
                alert.show()
            }, isPreferred: true),
            .init(style: .default, text: LocalizedString(key: notSaveMap))
        ])
    }

    private func saveMapMultiFloor() {
        showAlert(title: "地图数量已达上限，是否保存新地图？", message: "如点击“保存”，请选择新地图要覆盖哪张旧地图。", messageTextAlignment: .center, buttons: [
            .init(style: .default, text: LocalizedString(key: notSaveMap), color: .theme1),
            .init(style: .default, text: "保存", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let vc = SweeperCoverOldMapController()
                vc.sweeperControl = self?.sweeperControl
                self?.navigationController?.pushViewController(vc, animated: true)
            }, isPreferred: true)
        ])
    }

    private func isCurrentMapSaved() -> Bool {
        return map?.currentMapID == temporaryMapID
    }

    /// preMapID 为 nil，表示为第一次赋值
    private func currentMapDidChanged(preMap: SweeperMap?) {
        guard let map = map else {
            return
        }
        // 展示波纹动画条件： 1. 当前地图id为-2
        //                 2. 当前主状态为清扫中
        //                 3. 第一次进入主页面
        //                 4. 当前无地图I帧
        let needShowRobotWave = map.currentMapID == noMapID && sweeperControl?.basicState?.mainState == .cleaning && (preMap == nil || !hadStartWaveAnimation) && sweeperControl?.hadFrame == false
        if needShowRobotWave {
            startWaveAnimation()
        }
        /// preMapID 从 nil -> 0，未处理后退出主页重新进入
        /// 或 从 “-1” -> 0  表示成功创建，但还未自动保存新地图
        let preMapID = preMap?.currentMapID
        if (preMapID == nil || preMapID == isCreatingMapID) && map.currentMapID == temporaryMapID {
            ///  生成临时地图： 需要判断是多楼层还是单楼层来决定保存方式；
            guard let multiFloorEnabled = sweeperControl?.multiFloorEnabled, let maxMapNumber = sweeperControl?.capability?.maxMapNumber else {
                return
            }
            if multiFloorEnabled {
                if map.mapNumber > maxMapNumber && maxMapNumber > 0 && map.currentMapID == temporaryMapID {
                    // 地图已达上限且能力集中多楼层地图上限不为0，且当前地图是临时地图时，展示多楼层地图上限弹窗
                    needShowSaveMapMultiFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            } else {
                if map.mapNumber > 1 && map.currentMapID == temporaryMapID {
                    // 已经有一张地图且当前地图时临时地图时，展示单楼层地图上限弹窗。
                    needShowSaveMapSingleFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            }
            return
        }

        /// 成功创建，mapID 从 “-1” -> 大于0
        if preMapID == isCreatingMapID && map.currentMapID != noMapID && map.currentMapID != temporaryMapID && map.allMapNames.count == (preMap?.allMapNames.count ?? 0) + 1 {
            ///  生成完整地图：直接进入“已自动保存逻辑”
            needShowMapHasSavedTip = true
        }
    }

    private func showMapNotCompletedAlert(alertMessage: String, cancelHandler: ((UIAlertAction) -> Void)? = nil, defaultHandler: (() -> Void)? = nil) {
        showAlertWith(title: alertMessage, message: nil, messageTextAlignment: nil, defaultButtonTitle: "查看帮助", defaultButtonColor: .theme1, cancelButtonTitle: "关闭", cancelButtonColor: .theme1, cancelButtonHandler: cancelHandler, defaultButtonHandler: { [weak self] (_) in
            let vc = SweeperMapHelpViewController(type: .incomplete)
            self?.navigationController?.pushViewController(vc, animated: true)
            defaultHandler?()
        })
    }

    private func showCanNotCustomCleanAlert(isCreatingMap: Bool, defaultButtonhandler: ((UIAlertAction) -> Void)? = nil) {
        if isCreatingMap {
            showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持定制清扫", defaultHandler: { [weak self] () in
                self?.configurationView?.dismiss()
            })
        } else {
            showAlertWith(title: "请创建地图后再设置定制清扫", defaultButtonTitle: SharedResource.sharedFormatString(key: commonSure), defaultButtonColor: UIColor.black, cancelButtonTitle: nil, defaultButtonHandler: defaultButtonhandler)
        }
    }

    func showFastMapGuideView() {
        if fastMapImageView == nil {
            fastMapImageView = UIImageView()
            fastMapImageView?.image = UIImage.image(named: "quick_build_map")
            fastMapImageView?.sizeToFit()
        }
        guard let imageView = fastMapImageView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            fastMapGuideView?.dismiss()
            var offset: CGFloat = defaultButtonInterval
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            fastMapGuideView = presentGuideWith(viewToPresent: imageView, size: imageView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    func showMapHasSavedTip() {
        if savedMapNoticeView == nil {
            savedMapNoticeView = UIImageView()
            savedMapNoticeView?.image = UIImage.image(named: "edit_map")
            savedMapNoticeView?.sizeToFit()
        }
        guard let noticeView = savedMapNoticeView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            saveMapGuideView?.dismiss()
            var offset: CGFloat = 0
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            saveMapGuideView = presentGuideWith(viewToPresent: noticeView, size: noticeView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    override func collectionViewCell(_ cell: SweeperGlobalCleaningConfigurationCollectionViewCell, didSelectItemAt indexPath: IndexPath) {
        super.collectionViewCell(cell, didSelectItemAt: indexPath)

        let itemIndex = indexPath.section
        let row = indexPath.row
        let parameter = settingItems[itemIndex].paramters[row].type
        if parameter == .suctionForce(.none) {
            showAlertWith(title: "静音模式下吸尘能力将暂时降低，仅本次清扫任务生效。", message: nil, messageTextAlignment: nil, defaultButtonTitle: "确定", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonColor: .black, cancelButtonHandler: nil) { [weak self] (_) in
                self?.setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
            }
        } else {
            setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
        }
    }

    func setGlobalConfig(parameter: SweeperGlobalConfigurationType, itemIndex: Int) {
        var pendingConfig = sweeperControl?.globalCleaningConfig

        switch parameter {
        case .suctionForce(_):
            pendingConfig?.suction = parameter
        case .waterYield(_):
            pendingConfig?.waterYield = parameter
        case .sweepTimes(_):
            pendingConfig?.cleanTimes = parameter
        case .cleanMethod(_):
            pendingConfig?.cleanMethod = parameter
        case .mopMode(_):
            pendingConfig?.mopMode = parameter
        }


        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setGlobalCleaningConfig(device: deviceID, channel: channel, listType: listType, config: pendingConfig).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.then { [weak self] (_) in
            self?.sweeperControl?.globalCleaningConfig = pendingConfig
            self?.configurationView?.collectionView.reloadData()
            self?.updateParamUI()
        }
    }

    func startWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        let animationView = SweeperStartCleanAnimationView(frame: .zero)
        view.addSubview(animationView)

        animationView.snp.makeConstraints { make in
            make.centerX.equalToSuperview().offset(28)
            make.centerY.equalToSuperview().multipliedBy(0.764).offset(28)
            make.width.height.equalTo(56)
        }
        self.startCleanAnimationView = animationView
        animationView.startAnimation()
        hadStartWaveAnimation = true
    }

    func stopWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        startCleanAnimationView = nil
        hadStartWaveAnimation = false
    }

    private func cleanAllFlag() {
        needEntrySaveMapLogic = true
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true
        needShowMapHasSavedTip = false
        needShowSaveMapMultiFloor = false
        needShowSaveMapSingleFloor = false
        needEntrySaveMapLogicAfterBasicStateChanged = false
    }
}

// MARK: Button Action
private extension SweeperMainViewController {
    @objc func paramterButtonDidClick() {
        configurationView?.isSetSeq = isSetSweepSeq()
        configurationView?.isSetPreference = isSetPreference()
        configurationView?.show(view: self.navigationController?.view)
    }

    @objc func clearAreaButtonDidClick() {
        sweepAreaPopView = SweeperClearAreaPopView(type: cleaningModeType)
        sweepAreaPopView?.delegate = self
        sweepAreaPopView?.show()
    }

    @objc func startButtonDidClick() {
        guard (map?.currentMapID) != nil  else {
            return
        }
        if sweeperControl?.dataLoadingState == .success {
            setCleaningMode(type: .sweeping)
        } else {
            showAlertWithWholeHouseClean()
        }
    }

    @objc func stopButtonDidClick() {
        if status == .fastMapPause || status == .fastMap {
            showAlertWithFastMapEnd()
        } else {
            setCleaningMode(type: .stop)
        }
    }

    @objc func pasueButtonDidClick() {
        if status == .sweepingPause {
            setCleaningMode(type: .sweeping)
        } else if status == .fastMapPause {
            setCleaningMode(type: .fastMap)
        } else {
            setCleaningMode(type: .sweepingPause)
        }
    }

    @objc func previewButtonDidClick() {
        guard let mediaState = sweeperControl?.mediaState, checkEntryCondition() else {
            return
        }
        checkMediaStateAndJump(state: mediaState)
    }

    func checkMediaStateAndJump(state: SweeperMediaState) {
        // 若为被分享端，则不判断，直接进入人工驾驶页面
        if isSharedDevice {
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            vc.needShowSettingButton = false
            navigationController?.pushViewController(vc, animated: true)
            return
        }

        switch state {
        case .closed, .open:
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        case .openWithPermission:
            if sweeperControl?.mediaEncryptEnabled == true {
                // 视频加密开启，直接验证密码
                checkUnAuthenticated()
                return
            }
            // 视频加密关闭，需要检测设备空密码
            ToastView.showLoadingToast(cirleWithMessage: nil)
            requestCheckEmptyPassword {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func checkEntryCondition() -> Bool {
        if state?.collectDust == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterCollectionDust))
            return false
        }
        if state?.mopWashState == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterWashingMop))
            return false
        }
        return true
    }

    @objc func baseStationButtonDidClick() {
        if sweeperControl?.basicState?.cleanSinkState != .stop {
            let vc = SweeperBaseStationCleanSinkViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        } else {
            let vc = SweeperBaseStationMainViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func moreButtonDidClick() {
        let vc = SweeperMoreActionViewController(deviceID: deviceID, listType: listType)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    @objc func editButtonDidClick() {
        // 大于0的地图数量为0时(无已保存地图)并且没有地图，不允许进入，若mapID为“-1”允许进入
        if sweeperControl?.mapWithoutZero?.count == 0 && sweeperControl?.map?.currentMapID == noMapID {
            // 若扫地机在清扫、建图时，展示暂无地图
            if (state?.cleanFinished ?? true) {
                let fastMapGuideSheet = SweeperFastMapSheet()
                fastMapGuideSheet.delegate = self
                fastMapGuideSheet.show()
            } else {
                ToastView.showWarningToast(title: "暂无地图", existTime: nil, centerY: .low)
            }
            return
        }

        let alertActionSheet = TPActionSheet.init(title: nil)
        let setRigionAction = TPActionSheetAction.init(title: "设置禁区/虚拟墙", detail: "设置不允许扫地机器人进入的区域", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }

            // 清扫过程中进入编辑禁区页面需要暂停扫地机
            if self.status == .sweeping || self.status == .fastMap {
                self.setCleaningMode(type: .sweepingPause)
            }
            // 回充过程中进入编辑进去页面需要设置为待机
            if self.state?.mainState == .recharge {
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setStandBy(deviceID: self.deviceID, listType: self.listType).always {
                    ToastView.dismissLoadingToast()
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }
            }
            // 指哪到哪和遥控时不允许进入禁区页面
            if self.state?.mainState == .assignLocation || self.state?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterMission))
                return
            }
            let vc = SweeperForbiddenAreaVirtualWallViewController(sweeperControl: self.sweeperControl)
            self.navigationController?.pushViewController(vc, animated: true)
        }

        let editMapAreaAction = TPActionSheetAction.init(title: "编辑地图区域", detail: "划分地图区域并进行标记", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }
            /// 清扫、快速建图中不允许进入编辑区域页面
            if self.status != .stop {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterCleaning))
                return
            }
            /// 正在创建地图中不允许进入编辑区域页面
            guard self.map?.currentMapID != isCreatingMapID else {
                self.showMapNotCompletedAlert(alertMessage: LocalizedString(key: sweeperMapIsNotCompleteForEditingArea))
                return
            }
            let vc = SweeperEditMapAreaViewController(sweeperControl: self.sweeperControl)
            vc.isSetPreferenceOrOrder = self.isSetPreference() || self.isSetSweepSeq()
            self.navigationController?.pushViewController(vc, animated: true)
        }


        let manageMapAction = TPActionSheetAction.init(title: "管理地图", style: .leftTitle) { [weak self] (_) in
            guard let self = self else {
                return
            }
            let vc = SweeperMapManagerViewController()
            vc.delegate = self
            vc.deviceID = self.deviceID
            vc.listType = self.listType
            self.navigationController?.pushViewController(vc, animated: true)
        }

        var editActionArray: [TPActionSheetAction] = []
        editActionArray = map?.currentMapID == noMapID ? [manageMapAction] : [setRigionAction, editMapAreaAction, manageMapAction]

        editActionArray.forEach { (action) in
            action.font = .projectFont(ofSize: 16)
            action.detailFont = .projectFont(ofSize: 12)
            alertActionSheet.addAction(action)
        }
        alertActionSheet.separatorColor = .cellSeparatorGray

        alertActionSheet.show()
    }

    @objc func settingBarButtonItemDidClick() {
        if let vc = SweeperSettingViewController.create() {
            vc.deviceID = deviceID
            vc.listType = listType
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func rechargeButtonDidClick() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setRechargeState(device: deviceID, channel: channel, listType: listType, enabled: !isRecharging).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperRobotOfflineViewDelegate {
    func offlineHelpButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.requiredService?.goToOfflineHelp(deviceID: sweeperControl.deviceID, cloudID: sweeperControl.cloudID, listType: sweeperControl.listType, navigator: self.navigationController)
    }

    func offlineRefreshButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
        SweeperModule.shared.refreshSweeperControl()
    }
}

extension SweeperMainViewController: SweeperClearAreaPopViewDelegate {
    func updateData(with type: CleaningModeType) {
        if map?.currentMapID == isCreatingMapID {
            switch type {
            case .areaClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持区域清扫")
            case .pointClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持选框清扫")
            case .autoClean:
                // DO NOTHING
                break
            case .partClean:
                // DO NOTHING
                break
            case .pause:
                // DO NOTHING
                break
            case .stop:
                // DO NOTHING
                break
            case .fastMap:
                // DO NOTHING
                break
            }
            sweepAreaPopView?.dismiss()
            return
        } else {
            if type == .areaClean {
                if map?.currentMapID != noMapID {
                    ToastView.showWarningToast(title: "请选择区域", existTime: nil, centerY: .low)
                }
            }
        }
        self.cleaningModeType = type
        sweepAreaPopView?.dismiss()
    }
}

// MARK: setup UI
private extension SweeperMainViewController {
    func setupNavigation() {

        navigationItem.title = deviceDetail?.alias ?? "扫地机器人"

        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
        addCustomNavigationLeftBarButtonItem(title: nil, image: SharedResource.sharedImage(named: "common_light_back_nor"))
    }

    func setupButtons() {
        var title: String
        var imageName: String
        if isSharedDevice {
            title = "遥控"
            imageName = "ptz"
        } else {
            title = "视频遥控"
            imageName = "preview_light_nor"
        }
        previewButton = SweeperButton(title: title, fontSize: 9, image: UIImage.image(named: imageName))
        let previewTap = UITapGestureRecognizer.init(target: self, action: #selector(previewButtonDidClick))
        previewButton?.addGestureRecognizer(previewTap)
        if let button = previewButton {
            self.view.bringSubviewToFront(button)
        }
        if let previewButton = previewButton {
            buttonContainerStackView.addArrangedSubview(previewButton)
        }

        editButton = SweeperButton(title: "编辑地图", fontSize: 9, image: UIImage.image(named: "map_black_nor"))

        let editTap = UITapGestureRecognizer.init(target: self, action: #selector(editButtonDidClick))
        editButton?.addGestureRecognizer(editTap)
        if let editButton = editButton {
            buttonContainerStackView.addArrangedSubview(editButton)
        }

        baseStationButton = SweeperButton(title: "基站", fontSize: 9, image: UIImage.image(named: "sweeper_home"))

        let stationTap = UITapGestureRecognizer.init(target: self, action: #selector(baseStationButtonDidClick))
        baseStationButton?.addGestureRecognizer(stationTap)
        if let baseStationButton = baseStationButton {
            buttonContainerStackView.addArrangedSubview(baseStationButton)
        }

        moreButton = SweeperButton(title: "更多", fontSize: 9, image: UIImage.image(named: "star"))

        let moreButtonTap = UITapGestureRecognizer.init(target: self, action: #selector(moreButtonDidClick))
        moreButton?.addGestureRecognizer(moreButtonTap)
        if let moreButton = moreButton {
            buttonContainerStackView.addArrangedSubview(moreButton)
        }

        [previewButton, editButton, baseStationButton, moreButton].forEach { button in
            button?.snp.makeConstraints { make in
                make.width.equalTo(44)
                make.height.equalTo(47)
            }
        }

        /* buttonContainerStackView */
        view.addSubview(buttonContainerStackView)
        buttonContainerStackView.axis = .vertical
        buttonContainerStackView.alignment = .center
        buttonContainerStackView.spacing = 12
        buttonContainerStackView.snp.makeConstraints { make in
            make.width.equalTo(44)
            make.top.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }

        /* createMapButton */
        createMapContainer = SweeperCreateMapView()
        if let createMapContainer = createMapContainer {
            view.addSubview(createMapContainer)

            let goldenRatio: CGFloat = 0.382
            createMapContainer.snp.makeConstraints { make in
                make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2).offset(-(88 * goldenRatio))
                make.centerX.equalToSuperview()
                make.width.equalTo(230)
            }
        }
        createMapContainer?.isHidden = true

        /* chargeButton */
        chargeButton = SweeperButton(title: "返回基站", fontSize: 9, image: UIImage.image(named: "robot_charger"), offsetToTop: 5)
        addContraint(for: chargeButton, trailingToSuperView: -defaultButtonPadding)
        chargeButton.isHidden = true
        chargeButton.snp.makeConstraints { make in
            if let sweeperAlarmView = sweeperAlarmViewController {
                make.bottom.equalTo(sweeperAlarmView.view.snp.top).offset(-defaultButtonPadding / 2)
            } else {
                make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding)
            }
        }
        let chargeTap = UITapGestureRecognizer.init(target: self, action: #selector(rechargeButtonDidClick))
        chargeButton.addGestureRecognizer(chargeTap)

        parameterButton = SweeperButton(title: LocalizedString(key: sweeperCleanSweepAndMop), fontSize: 9, image: UIImage.image(named: "mode_general"), offsetToTop: 5)
        addContraint(for: parameterButton, trailingToSuperView: -defaultButtonPadding, bottomToSuperView: nil)
        parameterButton.snp.makeConstraints { (make) in
            make.bottom.equalTo(chargeButton.snp.bottom)
        }

        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        parameterButton.addGestureRecognizer(paramTap)

    }

    func setupOfflineView() {
        let offlineView = SweeperRobotOfflineView(frame: .zero)
        offlineView.delegate = self
        self.view.addSubview(offlineView)

        let goldenRatio: CGFloat = 0.382
        offlineView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2)
        }
        equipmentOfflineView = offlineView
        equipmentOfflineView?.isHidden = true
    }

    func updateNavigation() {
        if firstTimeUpdateNavigationTitle {
            navigationTitleView = SweeperTitleBatteryView(title: deviceDetail?.alias ?? "扫地机器人", stateText: "", power: 0, charge: false)
            navigationTitleView.snp.remakeConstraints { make in
                make.height.equalTo(44)
                make.width.equalTo(screenWidth - 150)
            }
            navigationItem.titleView = navigationTitleView
            firstTimeUpdateNavigationTitle = false
        }

        let stateText = state?.stateDescription ?? "故障中"
        let battery = state?.battery ?? 0
        let isCharging = state?.mainState == .charging
        navigationTitleView.setState(stateText: stateText, power: battery, charge: isCharging)
    }

    func updateEnvironmentView() {
        temperatureView.text = temperatureText
        humidityView.text = humidityText
    }

    func updateChargeButton() {
        chargeButton.isHidden = !shouldShowChargeButton
        if isRecharging {
            chargeButton.setTitle(title: "停止回充", buttonImage: UIImage.image(named: "robot_charge_stop"))
        } else {
            chargeButton.setTitle(title: "返回基站", buttonImage: UIImage.image(named: "robot_charger"))
        }
        if forbiddenRechargeAndClean {
            chargeButton.titleLabel.textColor = .lightGray3Color.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = false
        } else {
            chargeButton.titleLabel.textColor = .black.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = true
        }
    }

    func setupLoadingView() {
        view.addSubview(loadingView)
        loadingView.delegate = self
        loadingView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(0.764)
        }
    }

    func setupMapView() {
        let mapSize = sweeperControl?.mapSize ?? CGSize(width: defaultMapWidth, height: defaultMapHeight)
        mapView = SweeperHomeMapView(frame: .zero, mapSize: mapSize)
        mapView.backgroundColor = UIColor.clear
        view.addSubview(mapView)
        mapView.delegate = self
        mapView.sweeperIconMapView.delegate = self
        mapView.datasource = self
        mapView.isHidden = true

        mapView.snp.makeConstraints { make in
            make.top.trailing.leading.equalToSuperview()
            make.bottom.equalTo(sweepControlView.snp.top)
        }
        setupTapGesture()
    }

    func setupTapGesture() {
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(didTaped(recognizer:)))
        self.mapView.addGestureRecognizer(tapGesture)
    }

    func setupSweeperAlarmView() {
        let sweeperAlarmViewController = SweeperAlarmBannerViewController()
        sweeperAlarmViewController.window(from: .mainPage)
        sweeperAlarmViewController.sweeperControl = self.sweeperControl

        self.addChild(sweeperAlarmViewController)
        view.addSubview(sweeperAlarmViewController.view)
        sweeperAlarmViewController.view.snp.makeConstraints { make in
            make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding / 2)
            make.leading.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }
        self.sweeperAlarmViewController = sweeperAlarmViewController
    }

    @objc func didTaped(recognizer: UITapGestureRecognizer) {
        captureBubbleViewDismiss()
    }

    func setupEnvironmentView() {
        view.addSubview(environmentView)

        environmentView.snp.makeConstraints { make in
            make.height.equalTo(36)
            make.leading.top.equalToSuperview().offset(12)
        }
        environmentView.backgroundColor = .lightGray3Color.withAlphaComponent(0.1964)
        environmentView.layer.cornerRadius = 5

        [temperatureView, humidityView].forEach { label in
            environmentView.addSubview(label)

            label.backgroundColor = .clear
            label.textColor = .black.withAlphaComponent(0.6)
            label.textAlignment = .left
            label.font = .projectFont(ofSize: 10)
            label.snp.makeConstraints { make in
                make.height.equalTo(14)
                make.trailing.equalToSuperview().offset(-8)
                make.leading.equalToSuperview().offset(8)
            }
        }

        temperatureView.snp.makeConstraints { make in
            make.top.equalToSuperview().offset(4)
        }
        temperatureView.text = temperatureText

        humidityView.snp.makeConstraints { make in
            make.top.equalTo(temperatureView.snp.bottom)
        }
        humidityView.text = humidityText
    }

    func setupControlView() {
        addConstraint(forBottomView: sweepControlView, height: nil)
        sweepControlView.isHidden = true
        sweepControlViewHeightConstraint = NSLayoutConstraint(item: sweepControlView,
                                                             attribute: .height,
                                                             relatedBy: .equal,
                                                             toItem: nil,
                                                             attribute: .notAnAttribute,
                                                             multiplier: 1.0,
                                                             constant: 0)
        sweepControlViewHeightConstraint?.isActive = true

        // button clicked
        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        sweepControlView.parameterButton?.addGestureRecognizer(paramTap)

        let clearTap = UITapGestureRecognizer.init(target: self, action: #selector(clearAreaButtonDidClick))
        sweepControlView.clearAreaButton?.addGestureRecognizer(clearTap)

        let startTap = UITapGestureRecognizer.init(target: self, action: #selector(startButtonDidClick))
        sweepControlView.startButton.addGestureRecognizer(startTap)

        let stopTap = UITapGestureRecognizer.init(target: self, action: #selector(stopButtonDidClick))
        sweepControlView.stopButton.addGestureRecognizer(stopTap)

        let pauseTap = UITapGestureRecognizer.init(target: self, action: #selector(pasueButtonDidClick))
        sweepControlView.pauseButton.addGestureRecognizer(pauseTap)

    }

    func setupUpgradingView() {
        view.addSubview(sweeperBaseUpgradingView)
        sweeperBaseUpgradingView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingUpgradingView = false
    }

    func setupMechanicalOffView() {
        view.addSubview(sweeperMechanicalOffView)
        sweeperMechanicalOffView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingMechanicalView = false
        sweeperMechanicalOffView.delegate = self
    }

    func addConstraint(forBottomView bottomView: UIView?, height: CGFloat?) {
        guard let bottomView = bottomView else {
            return
        }
        bottomView.translatesAutoresizingMaskIntoConstraints = false

        view.addSubview(bottomView)

        // UI中设置的阴影radius为12，此处设置为8，才能与UI的效果一致。
        let shadowRadius: CGFloat = 8
        bottomView.layer.shadowOffset = .init(width: 0, height: 2)
        bottomView.layer.shadowRadius = shadowRadius
        bottomView.layer.shadowColor = UIColor.black.cgColor
        bottomView.layer.shadowOpacity = 0.16

        NSLayoutConstraint(item: bottomView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .width,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        if let height = height {
            NSLayoutConstraint(item: bottomView,
                               attribute: .height,
                               relatedBy: .equal,
                               toItem: nil,
                               attribute: .notAnAttribute,
                               multiplier: 1.0,
                               constant: height).isActive = true
        }

        NSLayoutConstraint(item: bottomView,
                           attribute: .bottom,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .bottom,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        NSLayoutConstraint(item: bottomView,
                           attribute: .centerX,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .centerX,
                           multiplier: 1.0,
                           constant: 0).isActive = true
    }

    func addContraint(for subView: UIView?, trailingToSuperView: CGFloat, topToSuperView: CGFloat? = nil, bottomToSuperView: CGFloat? = nil) {
        guard let subView = subView else {
            return
        }

        view.addSubview(subView)
        subView.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint(item: subView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 44).isActive = true
        NSLayoutConstraint(item: subView,
                           attribute: .height,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 47).isActive = true
        if let topToSuperView = topToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .top,
                               relatedBy: .equal,
                               toItem: view,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: topToSuperView).isActive = true
        }

        if let bottomToSuperView = bottomToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .bottom,
                               relatedBy: .equal,
                               toItem: bottomLayoutGuide,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: bottomToSuperView).isActive = true
        }

        NSLayoutConstraint(item: subView,
                           attribute: .trailing,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .trailing,
                           multiplier: 1.0,
                           constant: trailingToSuperView).isActive = true
    }
}

/// receive bitmap data
extension SweeperMainViewController: SweeperMapMediaPlayerListener {
    func mediaPlayerConnected(connectedSuccess: Bool) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if !connectedSuccess {
            dataLoadingStateChangeAction(loadingState: .failed)
        }
    }

    func dataLoadingStateChanged(loadingState: SweeperDataLoadingState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        dataLoadingStateChangeAction(loadingState: loadingState)
    }

    func mediaPlayerBitmapDataUpdate(dataType: MapMediaPlayerFrameFormat) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        /// 对扫地机地图正处于拖动或缩放时地图的刷新进行限制，避免卡顿的情况。
        guard !mapView.isOperation else {
            return
        }
        if dataType == .map {
            // 第一次收到I帧
            if sweeperControl?.hadFrame == true {
                stopWaveAnimation()
            }
            mapView.sweeperBitmapView.refreshBitmapImage()
            mapView.sweeperAreaView.refreshAreaView()
            if needRefreshMapViewInMediaPlayer {
                needRefreshMapViewInMediaPlayer = false
                mapView.refreshView()
            }
        }

        if sweeperControl?.hadFrame == true && dataType == .path {
            mapView.sweeperRouteView.refreshRouteView()
            // refresh equipment icon and charger pile location.
            mapView.sweeperIconMapView.refreshIconView()
        }
    }

    func mediaPlayerSignalling(mapID: String, type: SweeperConfigUpdateType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if type == .cleaningState {
            updateCleaningStateUI()
        } else if type == .cleaningMode || type == .cleanParam {
            updateCleaningModeUI()
        } else if type == .areaCleaning {
            mapView.updateCustomOrAutoMode()
            mapView.refreshAreaAndLabelView()
        } else if type == .globalCleaningConfig {
            // 修改全局清扫配置
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                cleanMethodMode = mode
                configurationView?.collectionView.reloadData()
            }
        } else {
            mapView.refreshView()
            mapView.refreshAreaAndLabelView()
        }
    }

    func mediaPlayerBasicStateDidChanged(preState: SweeperState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        basicStateChangeAction(showToast: true)
        sweeperAlarmViewController?.showAlarm()
        sweeperAlarmViewController?.showNotify()

        // 当前扫地机清扫结束时，若需要进入地图保存逻辑，则重新进入
        if !preState.cleanFinished && state?.cleanFinished == true && needEntrySaveMapLogicAfterBasicStateChanged {
            currentMapDidChanged(preMap: nil)
            saveMapLogic()
            needEntrySaveMapLogicAfterBasicStateChanged = false
        }
    }

    func mediaPlayerMapIDDidChanged(preMap: SweeperMap) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        currentMapDidChanged(preMap: preMap)

        /// 每次修改current map id 后， 地图的大小都会发生变化，故需要刷新初始地图的大小以适应屏幕
        mapView.restoreInitalMapView()
        mapView.shouldRefreshSize = true
        mapView.refreshView()
        mapView.updateCleanningModeAndSweepingState()
        mapView.updateCustomOrAutoMode()
        mapView.refreshAreaAndLabelView()
    }

    func mediaPlayerAlarm(type: SweeperAlarmType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        let alarm = SweeperAlarm(type: type)

        // 当前alarm需要在主页面显示、当基站升级、开关断开时不展示
        guard alarm.window.contains(.mainPage) && sweeperMechanicalOffView.isHidden && sweeperBaseUpgradingView.isHidden else {
            return
        }

        // 展示Toast
        if alarm.rank.contains(.toast),
           let message = alarm.toastTitle {
            ToastView.showWarningToast(title: message, existTime: nil, centerY: .low)
            return
        }

        // 展示Dialog，不展示只在基站展示的dialog
        if alarm.rank.contains(.dialog),
           !SweeperAlarm.baseDialogTypes.contains(type),
           let title = alarm.toastTitle {
            showAlertWith(title: title, message: alarm.toastContent, messageTextAlignment: .center, defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil, cancelButtonHandler: nil, defaultButtonHandler: nil)
            return
        }
    }
}

extension SweeperMainViewController: SweeperMapViewDataSource {
    func area(_ view: UIView, customCleanConfigurationIn areaID: Int) -> SweeperGlobalCleaningConfiguration? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaCleaningConfiguration
    }

    func area(_ view: UIView, infomationLayerMarkIn areaID: Int) -> String? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaLabel
    }

    func areaIDSet(_ in: UIView) -> [Int]? {
        return sweeperControl?.mapModel?.areaModel.areaIDs
    }

    func areaLabelLocation(_ view: UIView, areaID: Int) -> CGPoint? {
        return sweeperControl?.mapModel?.areaModel.areaLabelLocation[areaID]
    }

    func bitmapImage(_ view: UIView) -> CGImage? {
        return sweeperControl?.mapModel?.bitmapImage()
    }

    func bitmapOffset(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.offset
    }

    func bitmapSize(_ view: UIView) -> CGSize? {
        return sweeperControl?.mapModel?.bitmapSize
    }

    func areaData(_ view: UIView) -> [UInt8]? {
        return sweeperControl?.mapModel?.areaModel.areaData
    }

    func routeAllPointArray(_ view: UIView) -> [RoutePoint]? {
        return sweeperControl?.routeModel?.routePoints
    }

    func virtualWallIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.virtualWallModel?.wallIDs
    }

    func virutalWall(_ view: UIView, wallID: Int, isInEditMap: Bool) -> (CGPoint, CGPoint)? {
        return sweeperControl?.virtualWallModel?.couplePiontDictionary[wallID]
    }

    func forbiddenAreaIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.forbiddenAreaModel?.areaIDs
    }

    func forbiddenArea(_ view: UIView, areaID: Int, isInEditMap: Bool) -> RectangleArea? {
        return sweeperControl?.forbiddenAreaModel?.couplePiontDictionary[areaID]
    }

    func equipmentLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.routeModel?.equipmenLocation
    }

    func equipmentAngle(_ view: UIView) -> CGFloat? {
        return sweeperControl?.routeModel?.equipmenOritention
    }

    func chargePileLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.chargePileLocation
    }

    func barrierIDSet(_ view: UIView) -> [Int]? {
        if let keys = sweeperControl?.barriersModel?.barrierDictionary.keys {
            return Array(keys)
        } else {
            return nil
        }
    }

    func barrier(_ view: UIView, barrierModelIn barrierID: Int) -> SweeperBarrier? {
        return sweeperControl?.barriersModel?.barrierDictionary[barrierID]
    }

    func rectClean(_ view: UIView) -> (leftTopPoint: CGPoint, rightBottomPoint: CGPoint)? {
        if cleaningMode.leftTopPoint != .zero && cleaningMode.rightBottomPoint != .zero {
            return (cleaningMode.leftTopPoint, cleaningMode.rightBottomPoint)
        } else {
            return nil
        }
    }

    func mapScale(_ view: UIView) -> CGFloat? {
        return sweeperControl?.capability?.mapScale
    }
}

extension SweeperMainViewController: SweeperHomeMapViewDelegate {
    func hadMapFrame(_ view: SweeperHomeMapView) -> Bool? {
        return sweeperControl?.hadFrame
    }

    func areaSelected(_ view: SweeperHomeMapView) -> [Int]? {
        if cleaningModeType == .areaClean {
            return selectedLayerID
        } else {
            return nil
        }
    }

    func homeMapViewIsSetPreference(_ view: SweeperHomeMapView) -> Bool {
        return isSetPreference()
    }

    func homeMapViewIsSetSeq(_ view: SweeperHomeMapView) -> Bool {
        return isSetSweepSeq()
    }

    func layer(_ view: SweeperHomeMapView, layerSelectedSequence layerID: Int) -> Int? {
        if cleaningModeType == .areaClean, let orderID = selectedLayerID.firstIndex(of: layerID) {
            return orderID
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, layerCleaningOrder layerID: Int) -> Int? {
        if let order = sweeperControl?.mapModel?.areaModel.areaCleaningOrder,
           let orderID = order.firstIndex(of: layerID) {
            return orderID + 1
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, selectedLayer layerID: Int) {
        if let index = selectedLayerID.firstIndex(of: layerID) {
            selectedLayerID.remove(at: index)
        } else {
            selectedLayerID.append(layerID)
        }
        if cleaningModeType == .areaClean && !selectedLayerID.isEmpty {
            ToastView.showWarningToast(title: "已选择(selectedLayerID.count)个区域", existTime: nil, centerY: .low)
        }
        updateClearingAreaButton()
        mapView.refreshAreaAndLabelView()
    }
}

extension SweeperMainViewController {

    // 物体抓拍气泡展示
    private func captureBubbleViewShow(captureView: UIImageView, titleText: String, iconImage: UIImage, status: CaptureImageLoadingStatus, obstacleID: Int, thumbnail: UIImage? = nil) {
        sweepCaptureView.removeFromSuperview()
        captureBubbleViewLayout(captureView: captureView)
        sweepCaptureView.delegate = self

        // 更新障碍物抓拍气泡的展示
        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: thumbnail, obstacleID: obstacleID)

        // 更新障碍物抓拍是否有缩略图以及缩略图状态
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl?.barrierRecognitionEnabled ?? false, captureImageStatus: status)

        self.view.layoutIfNeeded()
        self.autoSuitPosition()
    }

    private func captureBubbleViewLayout(captureView: UIImageView) {
        self.mapView.addSubview(sweepCaptureView)
        sweepCaptureView.snp.remakeConstraints { make in
            make.centerX.equalTo(captureView.snp.centerX)
            make.bottom.equalTo(captureView.snp.top).offset(-12)
            make.width.equalTo(159)
            if sweeperControl?.barrierRecognitionEnabled ?? false {
                make.height.equalTo(128)
            } else {
                make.height.equalTo(40)
            }
        }
    }

    // 物体抓拍气泡隐藏
    private func captureBubbleViewDismiss() {
        sweepCaptureView.dismiss()
    }

    private func autoSuitPosition() {
        var offsetX: CGFloat = 0
        var offsetY: CGFloat = 0
        let maxXCoordinate = mapView.frame.width - sweepCaptureView.frame.width - 16
        if sweepCaptureView.frame.origin.x < 16 {
            offsetX = 16 - sweepCaptureView.frame.origin.x
        } else if sweepCaptureView.frame.origin.x > maxXCoordinate {
            offsetX = maxXCoordinate - sweepCaptureView.frame.origin.x
        }

        if sweepCaptureView.frame.origin.y < 16 {
            offsetY = 16 - sweepCaptureView.frame.origin.y
        }
        // 不用考虑底部超出边界，因为弹窗从顶部出现

        mapView.moveBy(x: offsetX, y: offsetY)
    }

    /// 刷新当前正在展示的气泡及其内容
    private func refreshBubbleView() {
        guard let sweeperControl = sweeperControl,
              let obstacleID = obstacleID,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              let iconImage = barrier.type.bigImage,
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            captureBubbleViewDismiss()
            return
        }
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
            return
        }

        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: .loading)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { [weak self] (status, image) in
            self?.sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: image, obstacleID: obstacleID)
            self?.sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: status)
        }
    }

}

extension SweeperMainViewController: SweeperMapManagerViewControllerDelegate {
    func mapManagerBeginSweep(_ controller: SweeperMapManagerViewController) {
        // 强制扫地机进入新建地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .autoClean)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    func mapManagerFastMap(_ controller: SweeperMapManagerViewController) {
        // 开始快速建图
        startFastMapAlert()
    }
}

extension SweeperMainViewController: SweeperCaptureBubbleViewDelegate {
    func captureNextButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.titleLabel.textColor = UIColor.black.withAlphaComponent(0.5)
        // 获取全部障碍物的详情页
        let sweepCaptureNextPageViewController = SweeperCaptureNextPageViewController(deviceID: deviceID, listType: listType)
        sweepCaptureNextPageViewController.delegate = self

        // 更新详情页跳转到具体哪个页面
        sweepCaptureNextPageViewController.obstacleID = captureView.obstacleID
        self.navigationController?.pushViewController(sweepCaptureNextPageViewController, animated: true)
    }

    func reloadButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.imageStatus = .loading
        let barrierID = captureView.obstacleID
        guard let fileID = sweeperControl?.barriersModel?.barrierDictionary[barrierID]?.fileID else {
            return captureView.imageStatus = .loadNoImage
        }

        SweeperDownloader.downloadObstacleImage(forDevice: deviceID, listType: listType, fileID: fileID) { status, image in
            captureView.imageStatus = status
            captureView.titleImageView.image = image
        }
    }

    func handleGestures(enable: Bool) {
        mapView.isGestureEnable = enable
    }
}

extension SweeperMainViewController: SweeperMainMapLoadingViewDelegate {
    func reloadButtonDidClick(_ UIView: SweeperMainMapLoadingView) {
        refreshMediaPlayerAndSweeperControl()
    }
}

extension SweeperMainViewController: SweeperIconMapViewDelegate {
    func didTapBaseStation(in view: SweeperIconMapView) {
        baseStationButtonDidClick()
    }

    func iconMap(_ view: SweeperIconMapView, transforToScreenPointFrom realPoint: CGPoint) -> CGPoint? {
        // 之前未调用
        return nil
    }

    func didTapObstacle(in view: UIImageView, obstacleID: Int) {

        guard let sweeperControl = sweeperControl,
              let iconImage = sweeperControl.barriersModel?.barrierDictionary[obstacleID]?.type.bigImage,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            return
        }
        self.obstacleID = obstacleID
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loadNoImage, obstacleID: obstacleID)
            return
        }

        self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loading, obstacleID: obstacleID)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { status, image in
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: status, obstacleID: obstacleID, thumbnail: image)
        }
    }
}

extension SweeperMainViewController: SweeperNewPasswordProtocol {
    func checkUnAuthenticated() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperModule.shared.requiredService?.checkUserInfo(deviceID: deviceID, listType: listType, completion: { [weak self] (success, errorCode) in
            ToastView.dismissLoadingToast()
            guard let self = self else {
                return
            }
            if success {
                self.goToPreview()
                return
            }

            if errorCode == TPSS_ASYNC_EC_TIMEOUT || errorCode == TPSS_COMM_EC_SYSTEM {
                /* 请求超时 */
                ToastView.showWarningToast(warningMessage: "网络错误")
                return
            }

            /* 设备锁定 */
            if errorCode == TPSS_COMM_EC_PREVIEW_LOCKED {
                self.showAlertWith(title: SharedResource.sharedString(key: sweeperPreviewLockedAlertTitle), defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil)
                return
            }

            /* 鉴权失败,弹出密码输入框 */
            self.presentInputPasswordVC(deviceID: self.deviceID, listType: self.listType)

        })
    }
}

extension SweeperMainViewController: SweeperVerifyPasswordProtocol {
    func verifySuccessHandler() {
        goToPreview()
    }
}

extension SweeperMainViewController: SweeperCaptureNextPageViewControllerDelegate {
    func ignoreButtonDidClick(sweeperCaptureNextPageViewController: SweeperCaptureNextPageViewController, barrierID: Int) {
        // 点击障碍物抓拍详情页的“忽略”所对应的障碍物Id
        guard let mapID = map?.currentMapID else {
             return
        }
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestIgnoreBarrier(device: deviceID, channel: channel, listType: listType, barrierID: "(barrierID)", mapID: mapID).always {
            ToastView.dismissLoadingToast()
        }.then { [weak self] (_) in
            ToastView.showWarningToast(warningMessage: "已忽略该物体")
            self?.sweepCaptureView.dismiss()
            self?.goBackToSweeperMainViewController()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperMechanicalOffViewDelegate {
    func refreshButtonDidClick(in: SweeperMechanicalOffView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        sweeperMechanicalOffView.refreshLoadingUI(connectedState: .loading)
        view.bringSubviewToFront(sweeperMechanicalOffView)
        SweeperService.getSweeperState(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType).then { [weak self] (state) in
            guard let state = state else {
                return
            }
            self?.showMechanicalOffView(switchOn: state.mechanicalSwitchOn)
        }
    }

    func showMechanicalOffView(switchOn: Bool) {
        // 若开关关闭
        if !switchOn {
            isShowingMechanicalView = true
            sweeperMechanicalOffView.refreshLoadingUI(connectedState: .off)
        } else {
            isShowingMechanicalView = false
        }
    }
}

extension SweeperMainViewController: SweeperMoreActionViewControllerDelegate {
    func cleanWholeHouse(in vc: SweeperMoreActionViewController) {
        showSweepTipsAlert()
    }
}

extension SweeperMainViewController: SweeperFastMapSheetDelegate {
    func startFastMap(view: SweeperFastMapSheet) {
        startFastMapAlert()
    }
}

extension String {
    func separatedBySemiColon(isAutoFill: Bool = true) -> (String, String?) {
        let seperator = self.contains(":") ? ":" : "："
        let separatedTexts: [String] = self.components(separatedBy: seperator)
        if !isAutoFill && separatedTexts.count == 1 {
            return (separatedTexts[0], nil)
        } else {
            return (separatedTexts.count >= 1 ? separatedTexts[0] : "", separatedTexts.count >= 2 ? separatedTexts[1] : "")
        }
    }
}
//
//  OnlineDeviceListMasterViewController.swift
//  SurveillanceHome
//
//  Created by Li Linfeng on 2019/12/9.
//  Copyright © 2019 tplink. All rights reserved.
//

import UIKit
import SurveillanceHomeBase
import SharedResource
import TPFoundation
import DeviceDetailModule
import NetService

private var pageIndexAssociatedObjectHandle: UInt8 = 0

final class OnlineDeviceListMasterViewController: BaseViewController {
    @IBOutlet private weak var groupCollectionView: UICollectionView!
    @IBOutlet private weak var groupToolbarShadowView: UIView!
    @IBOutlet private weak var groupToolbarContainer: UIView!
    @IBOutlet private weak var groupToolbarDropMenuButton: UIButton!
    @IBOutlet private weak var recentPreviewView: RecentPreviewView!
    @IBOutlet private weak var containerViewBottom2SuperViewBottomConstraint: NSLayoutConstraint!
    @IBOutlet private weak var containerViewTop2TopLayoutGuideBottomConstraint: NSLayoutConstraint!

    override var navigationBarTraits: [NavigationBarTrait] {
        return NavigationBarTrait.noSeparator
    }

    private var deviceGroups: [TPSSDeviceGroup] = []
    private var currentGroupIndex: Int = 0

    private var newCreateGroupName = ""

    private var pageController: UIPageViewController!
    private var deviceListVCCacheDictionary = [TPSSDeviceGroupID: OnlineDeviceListViewController]()
    private var transitionVCForPageController = UIViewController()
    lazy private var loginCacheVC = DeviceListLoginViewController.create()

    private var firstAppear = true
    private var shouldRecreate: Bool = false

    /// for routers' entry
    private var isLoginBefore = false

    var sdCardStatusShowed: SDCardStatusShowed = .none
    var diskStatusShowed: SDCardStatusShowed = .none

    // camera display
    private var shouldShowCameraDisplayNoActiveChannelAlert = false
    private var addChannelCameraDisplay: TPSSDeviceForDeviceList?

    // navigation
    private lazy var moreToolBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(moreToolsButtonClicked(_:)))
    }()

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_add_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(addDeviceButtonClicked(_:)))
    }()

    // MARK: guides and overlays
    private weak var addDeviceGuideView: GuidePresentationView?
    private weak var moreToolsPopoverView: GuidePresentationView?

    private lazy var groupPresenter = GroupListPresentationManager()
    private var presentedGroupList: GroupListViewController? {
        return presentedViewController as? GroupListViewController
    }

    private var currentList: OnlineDeviceListViewController {
        if let viewControllers = pageController.viewControllers, let firstViewController = viewControllers.first as? OnlineDeviceListViewController {
            return firstViewController
        }
        return OnlineDeviceListViewController()
    }

    private var isCloudLogin: Bool {
        return DeviceListModule.shared.requiredService?.isCloudLogin ?? false
    }

    private var isReordering = false                // 是否正在处于排序模式
    private var shouldToggleGroupModeAfterGetList = false   // 是否需要在获取列表结束后切换防护模式，仅在列表还未获取完时触发防护模式切换使用

    private var isShowing: Bool {
        return isShowing(ignorePresentedClasses: [UIAlertController.classForCoder()])
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        setupView()

        NotificationCenter.default.addObserver(self, selector: #selector(handleShowCameraDisplayNoActiveChannelAlertNotification(_:)), name: .ShowCameraDisplayNoActiveChannelAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleShowStorageDetectAlertNotification(_:)), name: .ShowStorageDetectAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListInvalidated), name: .DeviceListInvalidated, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListUpdated), name: .DeviceListUpdated, object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderBegined(_:)),
                                               name: .DeviceListReorderBegined,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderEnded(_:)),
                                               name: .DeviceListReorderEnded,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupAndDeviceList(_:)),
                                               name: .UpdateGroupAndDeviceListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: DeviceListNetworkObserver.localDeviceRefreshed,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupList(_:)),
                                               name: .UpdateGroupListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: .unbindDiscoveryFinished,
                                               object: nil)

        _ = DeviceListModule.shared.requiredService?.addEntrustObserver(observeTypes: [.entrustmentStop, .entrustmentExitByTrustee], { (_, _) in
            DeviceListManager.shared.updateDeviceList(of: DeviceListManager.shared.defaultGroupID).always {
                self.currentList.reload()
            }
        })
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        showGroupAndNavigationButton(true)
        if !isCloudLogin {
            showEmpty()
        } else if firstAppear {
            firstAppear = false
            restore()
        } else if shouldRecreate {
            shouldRecreate = false
            reload()
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        checkUpdateIfNeeded()

        if isCloudLogin {
            showPopoverGuideIfNeeded()
        }

        if shouldShowCameraDisplayNoActiveChannelAlert {
            shouldShowCameraDisplayNoActiveChannelAlert = false
            showCameraDisplayNoActiveChannelAlert()
        }
        updateGroupShadow()
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)

        dismissPresentedViews()
    }

    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let vc = segue.destination as? UIPageViewController {
            pageController = vc
            pageController.dataSource = self
            pageController.delegate = self
        }
    }

    private func refreshAfterGroupUpdated() {
        guard !isReordering else {
            return
        }

        guard isShowing else {
            // 如果分组刷新完，此时页面不是正在显示，则不进行页面刷新，仅记录状态，等回到本页面才统一进行刷新。
            // 需要注意通过记录状态后续回到页面才处理的逻辑，要与本方法后续处理逻辑要保持一致
            shouldRecreate = true
            return
        }

        reload()
    }

    private func showEmpty() {
        deviceGroups = []
        currentGroupIndex = -1

        showGroupAndNavigationButton(false)

        let emptyVC: UIViewController?
        // 有发现出来的/已绑定到局域网的设备时显示带登陆按钮的设备列表；没有则显示普通的登陆提示页
        if DeviceListManager.shared.unbindDetailDeviceList().count > 0 {
            emptyVC = createUnloginPage()
        } else {
            emptyVC = loginCacheVC
        }
        if let emptyVC = emptyVC {
            pageController.setViewControllers([emptyVC], direction: .forward, animated: false, completion: nil)
        }
        groupCollectionView.reloadData()
    }

    private func showGroupAndNavigationButton(_ shouldShow: Bool) {
        if shouldShow {
            navigationItem.leftBarButtonItem = moreToolBarButtonItem
            groupToolbarDropMenuButton.isHidden = false
        } else {
            navigationItem.leftBarButtonItem = nil
            groupToolbarDropMenuButton.isHidden = true
        }
    }

    private func restore() {
        deviceGroups = DeviceListManager.shared.groupList

        loadGroup(with: DeviceListManager.shared.lastSelectedGroupID)
    }

    private func reload(with preferredGroupID: String? = nil) {
        let oldGroupID = preferredGroupID ?? DeviceListManager.shared.lastSelectedGroupID
        deviceGroups = DeviceListManager.shared.groupList
        presentedGroupList?.groups = deviceGroups

        loadGroup(with: oldGroupID)
    }

    private func loadGroup(with groupID: String) {
        let currentGroup = DeviceListManager.shared.group(of: groupID) ?? DeviceListManager.shared.defaultGroup

        guard let groupIndex = deviceGroups.firstIndex(where: { $0.groupID == currentGroup.groupID }) else {
            return
        }

        currentGroupIndex = groupIndex

        presentedGroupList?.currentGroupID = currentGroup.groupID
        presentedGroupList?.reload()

        commonLoad()
    }

    private func commonLoad(animated: Bool = false, recreate: Bool = true) {
        groupCollectionView.reloadData()

        guard currentGroupIndex >= 0 else {
            return
        }

        groupCollectionView.scrollToItem(at: IndexPath(item: currentGroupIndex, section: 0), at: .right, animated: false)
        updateGroupShadow()

        if recreate, let vc = createPage(for: currentGroupIndex) {
            pageController.setViewControllers([vc], direction: .forward, animated: false, completion: nil)
        }

        storeGroupParameter()
    }

    private func updateGroupShadow() {
        groupToolbarShadowView.isHidden = groupCollectionView.bounds.maxX >= (groupCollectionView.contentSize.width - 1)
    }

    private func refreshAllDeviceLists() {
        if let viewController = pageController.viewControllers {
            viewController.forEach {
                if let vc = $0 as? OnlineDeviceListViewController {
                    vc.reload()
                }
            }
        }
    }

    private func createPage(for index: Int) -> OnlineDeviceListViewController? {
        let group = deviceGroups[index]
        guard let vc = createPage(for: group.groupID as TPSSDeviceGroupID) else {
            return nil
        }
        objc_setAssociatedObject(vc, &pageIndexAssociatedObjectHandle, index, .OBJC_ASSOCIATION_COPY_NONATOMIC)
        vc.realGroup = deviceGroups[index]
        return vc
    }

    private func createUnloginPage() -> OnlineDeviceListViewController? {
        return createPage(for: "unlogin page")
    }

    private func createPage(for key: TPSSDeviceGroupID) -> OnlineDeviceListViewController? {
        let vc: OnlineDeviceListViewController?
        if let item = deviceListVCCacheDictionary[key] {
            vc = item
        } else {
            vc = OnlineDeviceListViewController.create()
            deviceListVCCacheDictionary[key] = vc
        }
        return vc
    }
}

extension OnlineDeviceListMasterViewController: DeviceListUnwindDestination {}

// MARK: Popover handler
extension OnlineDeviceListMasterViewController {
    private func updateMenu() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let networkAvailable = NetworkManager.shared.isConnected
        let isInHomeMode = deviceGroups[currentGroupIndex].activeMode != .goOut
        let isBigCardMode = deviceGroups[currentGroupIndex].displayMode != .smallCard
        let homeModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_home_active") : DeviceListModule.image(named: "devicelist_home_disabled")
        let outModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_out_active") : DeviceListModule.image(named: "devicelist_out_disabled")
        DeviceGroupMenuItem.alarmMode.image = (isInHomeMode ? homeModeImage : outModeImage)?.withRenderingMode(.alwaysOriginal)
        DeviceGroupMenuItem.alarmMode.enabled = networkAvailable
        DeviceGroupMenuItem.alarmMode.title = isInHomeMode ? LocalizedString(key: deviceListModeHome) : LocalizedString(key: deviceListModeOut)
        DeviceGroupMenuItem.alarmMode.subtitle = isInHomeMode ? LocalizedString(key: deviceListSwitchModeToOut) : LocalizedString(key: deviceListSwitchModeToHome)
        DeviceGroupMenuItem.viewMode.title = isBigCardMode ? LocalizedString(key: deviceListViewGrid) : LocalizedString(key: deviceListViewList)
        DeviceGroupMenuItem.viewMode.subtitle = isBigCardMode ? LocalizedString(key: deviceListSwitchViewToList) : LocalizedString(key: deviceListSwitchViewToGrid)
        DeviceGroupMenuItem.viewMode.image = isBigCardMode ?  DeviceListModule.image(named: "devicelist_grid")?.withRenderingMode(.alwaysOriginal) : DeviceListModule.image(named: "devicelist_list")?.withRenderingMode(.alwaysOriginal)
    }

    private func handleDeviceGroupMenu(item: DeviceGroupMenuView.Item) {
        switch item {
        case .alarmMode:
            toggleGroupMode()
        case .search:
            navigateToSearch()
        case .viewMode:
            toggleDisplayMode()
        }
    }

    private func toggleGroupMode() {
        dismissPresentedViews()

        let deviceListUpdateStatus = DeviceListManager.shared.deviceListUpdateStatus
        if !deviceListUpdateStatus.cloudUpdateNecessaryInfoFinished {
            // 列表必要信息没获取到，此时若需要改变防护模式，就先请求获取数据并且loading，等所有信息获取完处理，避免数据不完整导致处理出错
            if !deviceListUpdateStatus.isUpdatingList {
                DeviceListManager.shared.updateGroupAndDeviceList()
            }
            shouldToggleGroupModeAfterGetList = true
            ToastView.showLoadingToast(cirleWithMessage: nil)
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.activeMode
        let newMode = group.activeMode == .goOut ? TPSSDeviceGroupMode.atHome : .goOut
        group.activeMode = newMode
        ToastView.showLoadingToast(cirleWithMessage: nil)
        DeviceListManager.shared.changeActiveMode(with: deviceGroups[currentGroupIndex]).then { () in
            self.currentList.reload()
            self.currentList.showToastForActiveMode(newMode)
        }.catch { (_) in
            group.activeMode = originalMode
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func toggleDisplayMode() {
        dismissPresentedViews()

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.displayMode
        let newMode = originalMode == .bigCard ? DeviceUIDisplayType.smallCard : .bigCard

        DeviceListManager.shared.changeDisplayMode(for: group.groupID, with: newMode)

        for section in 0..<currentList.collectionView.numberOfSections {
            for item in 0..<currentList.collectionView.numberOfItems(inSection: section) {
                if newMode == .smallCard {
                    currentList.fold(at: IndexPath(row: item, section: section))
                } else {
                    currentList.unfold(at: IndexPath(row: item, section: section))
                }
            }
        }

        currentList.reload()
    }

    private func navigateToSearch() {
        dismissPresentedViews()
        let allDevices = DeviceListManager.shared.allDetailDevices
        let allGroups = DeviceListManager.shared.groupList
        let vc = RemoteDeviceListSearchViewController(devices: allDevices, groups: allGroups)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }
}

extension OnlineDeviceListMasterViewController {
    // MARK: Popover
    private func showPopoverGuideIfNeeded() {
        // add device popover
        if UserDefaults.standard.object(forKey: deviceListLaunchKey) == nil {
            showAddDevicePopover()
            UserDefaults.standard.set(true, forKey: deviceListLaunchKey)
        }
    }

    private func showAddDevicePopover() {
        if !isShowing() {
            /* 如果界面切换了不要加载 */
            return
        }
        if let source = (navigationItem.rightBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            navigationController?.navigationBar.layoutIfNeeded()
            dismissPresentedViews()
            addDeviceGuideView = presentGuideWith(viewToPresent: TutorialGuideView.addDevice, size: TutorialGuideView.addDevice.frame.size, source: source, clickThrough: true)
            addDeviceGuideView?.delegate = self
        }
    }
}

extension OnlineDeviceListMasterViewController: GuidePresentationViewDelegate {
    func guidePresentationViewDidDismiss(_ view: GuidePresentationView) {
        if view == moreToolsPopoverView {
            navigationItem.leftBarButtonItem?.tintColor = UIColor(white: 0, alpha: 0.8)
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        }
    }
}

// MARK: - util
extension OnlineDeviceListMasterViewController {
    private func storeGroupParameter() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        DeviceListManager.shared.updateLastSelectGroupID(deviceGroups[currentGroupIndex].groupID)
    }
}

extension OnlineDeviceListMasterViewController {

    private func presentUpgradeInfo(appVersionInfo: AppUpgradeModuleBaseUpgradeInfo) {
        let alertViewController = DeviceListUpgradeAlertController(versionInfo: appVersionInfo)
        present(alertViewController, animated: true, completion: nil)
    }

    private func checkUpdateIfNeeded() {
        let requiredService = DeviceListModule.shared.requiredService
        guard requiredService?.shouldShowNewAppVersion() ?? false else {
            return
        }

        // 仅跳转至需要更新的包中（若对应版本的升级包needNotify为false，而另外版本的needNotify为true，会跳转至另一版本）
        if TPAppUtils.isTestFlightBeta() {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, appVersionInfo.needNotify, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        } else {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo, appVersionInfo.needNotify {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        }

    }
}

extension OnlineDeviceListMasterViewController: DeviceListSearchViewControllerDelegate {
    func navigateToGroup(group: TPSSDeviceGroup) {
        navigationController?.popViewController(animated: true)
        DispatchQueue.main.async {
            self.loadGroup(with: group.groupID)
        }
    }

    func navigateToSyncPreviewViewController(device: DeviceDetail) {
        goToSyncPreview(ipc: device, listType: device.listType)
    }

    func navigateToPreviewViewController(device: DeviceDetail, channel: TPSSChannelInfo?) {
        if device.deviceType == .smartLock {
            DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
            return
        }
        goToPreview(device: device, channel: channel)
    }

    func navigateToBatteryDoorbellViewController(device: DeviceDetail, fromNVR nvr: (deviceID: TPSSDeviceIdentifier, channel: UInt)?) {
        DeviceListModule.shared.requiredService?.navigateToBatteryDoorbellViewController(for: device.identifier, group: DeviceListManager.shared.defaultGroupID, listType: device.listType, navigator: navigationController, from: nvr?.deviceID, channelInNVR: nvr?.channel.intValue)
    }

    func navigateToNVRViewController(nvr: DeviceDetail) {
        var groupId = DeviceListManager.shared.defaultGroup.groupID
        if currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex {
            groupId  = deviceGroups[currentGroupIndex].groupID
        }
        goToNVR(nvr: nvr, groupID: groupId)
    }

    func navigateToSolarControllerManagerViewController(device: DeviceDetail) {
        goToSolarController(solarController: device)
    }

    func navigateToRouterManagerViewController(device: DeviceDetail) {
        goToRouter(device: device)
    }

    func navigateToSmartLockViewController(device: DeviceDetail) {
        DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
    }
}

// MARK: Navigation
extension OnlineDeviceListMasterViewController: PreviewControllerEntrance {
    func goToPreview(device: DeviceDetail, channel: TPSSChannelInfo?) {
        goToPreview(deviceID: device.identifier, channelID: channel?.channelId.intValue ?? -1, listType: device.listType)
    }

    func goToNVR(nvr: DeviceDetail, groupID: String? = nil) {
        let vc = NVRTabViewController()
        vc.cloudIdentifier = nvr.cloudDeviceID
        vc.deviceIdentifier = nvr.identifier
        vc.listType = nvr.listType
        vc.groupId = groupID
        navigationController?.pushViewController(vc, animated: true)
    }

    func goToSolarController(solarController: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToSolarControllerManagerViewController(deviceID: solarController.identifier, listType: solarController.listType, navigator: navigationController)
    }

    func goToRouter(device: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToRouterDefault(mac: device.mac, listType: device.listType, isOnline: device.online, navigator: navigationController)
    }
}

// MARK: Actions
extension OnlineDeviceListMasterViewController {
    private func dismissPresentedViews() {
        addDeviceGuideView?.dismiss()
        moreToolsPopoverView?.dismiss()

        presentedGroupList?.dismiss(animated: true, completion: nil)

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }

    @IBAction private func addDeviceButtonClicked(_ sender: Any) {
        guard isCloudLogin else {
            showAlertWith(title: LocalizedString(key: deviceListNotLogin), defaultButtonTitle: LocalizedString(key: deviceListLogin), defaultButtonHandler: { (_) in
                DeviceListModule.shared.requiredService?.navigateToLoginViewController(navigator: self.navigationController)
            })
            return
        }
        dismissPresentedViews()

        DeviceListModule.shared.requiredService?.presentDeviceAddViewController(viewController: self, listType: listType)
    }

    @IBAction private func moreToolsButtonClicked(_ sender: Any) {
        guard isCloudLogin else { return }

        if moreToolsPopoverView != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let size = CGSize(width: 212, height: 16 + DeviceGroupMenuView.Item.allCases.count * 44)
        let menuView = DeviceGroupMenuView(frame: CGRect(origin: .zero, size: size))
        menuView.action = handleDeviceGroupMenu

        dismissPresentedViews()

        updateMenu()

        if let source = (navigationItem.leftBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
            menuView.configurePopoverShadow(cornerRadius: 8)
            moreToolsPopoverView = presentGuideWith(viewToPresent: menuView, size: size, backgroundColor: .clear, source: source, offset: CGPoint(x: -12, y: 4))
            moreToolsPopoverView?.delegate = self
        }
        navigationItem.leftBarButtonItem?.tintColor = .theme1
    }

    @IBAction private func groupMenuToggled(_ sender: UIButton) {
        guard isCloudLogin else { return }

        if presentedViewController != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_up_small_normal"), for: .normal)

        let groups = DeviceListManager.shared.groupList
        guard let vc = GroupListViewController.create() else {
            return
        }
        let height = CGFloat(groups.count) * 52 + 72
        vc.preferredContentSize = CGSize(width: UIScreen.main.bounds.width, height: height)
        vc.modalPresentationStyle = .custom
        vc.transitioningDelegate = groupPresenter
        vc.groups = groups
        vc.currentGroupID = deviceGroups[currentGroupIndex].groupID
        vc.delegate = self
        present(vc, animated: true, completion: nil)
    }

    @IBAction private func recentPreviewClicked(_ sender: Any) {
        // 不会用到此按钮，但暂时保留
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDataSource {
    private func groupInformation(at index: Int) -> (String, Bool) {
        if deviceGroups.isEmpty { return (LocalizedString(key: deviceListMyDevice), true) }
        return (deviceGroups[index].groupName, index == currentGroupIndex)
    }

    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }

    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return max(1, deviceGroups.count)
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        return collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)
    }
}

extension OnlineDeviceListMasterViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        updateGroupShadow()
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDelegate {
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        if deviceGroups.isEmpty { return }
        dismissPresentedViews()
        loadGroup(with: deviceGroups[indexPath.item].groupID)
    }
}

extension OnlineDeviceListMasterViewController: DeviceGroupNameLayoutDelegate {
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, groupForItemAt indexPath: IndexPath) -> (name: String, selected: Bool) {
        return groupInformation(at: indexPath.item)
    }
}

// MARK: Page Management
extension OnlineDeviceListMasterViewController: UIPageViewControllerDataSource {
    func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex > 0 && currentGroupIndex < deviceGroups.count else { return nil }
        return createPage(for: currentGroupIndex - 1)
    }

    func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex >= 0 && currentGroupIndex < deviceGroups.count - 1 else { return nil }
        return createPage(for: currentGroupIndex + 1)
    }
}

extension OnlineDeviceListMasterViewController: UIPageViewControllerDelegate {
    func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
        if completed {
            if let viewControllers = pageViewController.viewControllers, let firtViewController = viewControllers.first {
                if let currentGroupIndex = objc_getAssociatedObject(firtViewController, &pageIndexAssociatedObjectHandle) as? Int {
                    self.currentGroupIndex = currentGroupIndex
                    commonLoad(animated: true, recreate: false)
                }
            }
        }
    }
}

// MARK: Group Management
extension OnlineDeviceListMasterViewController: GroupListViewControllerDelegate {
    func groupListViewController(_ groupListViewController: GroupListViewController, canMoveGroupTo destinationIndex: Int) -> Bool {
        guard deviceGroups.count > destinationIndex else {
            return false
        }
        let group = deviceGroups[destinationIndex]
        return !group.isDefaultGroup
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didMoveGroupAt sourceIndex: Int, to destinationIndex: Int) {
        // check if current group index has changed
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let originalGroup = deviceGroups[currentGroupIndex]
        deviceGroups.swapAt(sourceIndex, destinationIndex)
        if let newIndex = deviceGroups.firstIndex(of: originalGroup), currentGroupIndex != newIndex {
            currentGroupIndex = newIndex
        }
        // always invalidate page controller cache
        pageController.setViewControllers([currentList], direction: .forward, animated: false, completion: nil)
        groupCollectionView.moveItem(at: IndexPath(item: sourceIndex, section: 0), to: IndexPath(item: destinationIndex, section: 0))
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didSelectGroupAt index: Int) {
        dismissPresentedViews()
        loadGroup(with: deviceGroups[index].groupID)
    }

    func groupListViewControllerDidSelectCreatingNewGroup(_ groupListViewController: GroupListViewController) {
        dismissPresentedViews()
        guard let vc = CommonNameInputViewController.create() else {
            return
        }
        vc.navigationTitle = LocalizedString(key: deviceListSetGroupNameTitle)
        vc.doneButtonTitle = LocalizedString(key: commonNextStep)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didRequestEditingGroupAt index: Int) {
        dismissPresentedViews()
        guard let vc = GroupSettingViewController.create() else {
            return
        }
        vc.group = deviceGroups[index]
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewControllerDidDismiss(_ groupListViewController: GroupListViewController) {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
        _ = DeviceListManager.shared.updateGroupOrder(newGroup: deviceGroups)
    }
}

extension OnlineDeviceListMasterViewController: CommonNameInputViewControllerDelegate {
    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didCancelWith text: String) {
        navigationController?.popViewController(animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didFinishWith text: String) {
        guard deviceGroups.count > 0 else {
            navigationController?.popToViewController(self, animated: true)
            return
        }
        newCreateGroupName = text
        let vc = DeviceSelectionViewController(entry: .groupAddIndependent, group: DeviceListManager.shared.defaultGroupID, canProceedWithNoSelection: true)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, errorMessageFor text: String) -> (allowed: Bool, message: String?) {
        let error = TPSSDeviceListValidate.validateDeviceGroupName(text)
        if error != nil {
            return (true, error?.message)
        }

        if DeviceListManager.shared.groupList.contains(where: { $0.groupName == text }) {
            return (true, LocalizedString(key: deviceListNameExists))
        }
        return (true, nil)
    }

    func placeholderForNameInputViewController(_ nameInputViewController: CommonNameInputViewController) -> String? {
        return SharedResource.sharedString(key: shareStringLengthConstraint)
    }
}

extension OnlineDeviceListMasterViewController {
    @objc func handleShowCameraDisplayNoActiveChannelAlertNotification(_ noti: NSNotification) {
        if let (device, listType) = noti.object as? (DeviceDetail, TPSSDeviceListType), listType == .remote {
            shouldShowCameraDisplayNoActiveChannelAlert = true
            addChannelCameraDisplay = DeviceListManager.shared.device(with: device.identifier)
        }
    }

    @objc func handleShowStorageDetectAlertNotification(_ noti: NSNotification) {
        diskStatusShowed = .none
        sdCardStatusShowed = .none
    }

    private func showCameraDisplayNoActiveChannelAlert() {
        showAlertWith(title: LocalizedString(key: deviceAddCameraDisplayNoActiveChannelsTitle), defaultButtonTitle: LocalizedString(key: deviceAddAddNext), cancelButtonTitle: LocalizedString(key: commonNotNow), cancelButtonHandler: nil) { (_) in
            if let cameraDisplay = self.addChannelCameraDisplay {
                DeviceListModule.shared.requiredService?.navigateToCameraDisplayDiscoverViewController(deviceID: cameraDisplay.identifier, discoverType: .cameraDisplay, listType: self.listType, navigator: self.navigationController)
                // 需要在中间插一个ViewController
                let vc = NVRTabViewController()
                vc.cloudIdentifier = cameraDisplay.cloudDeviceId
                vc.deviceIdentifier = cameraDisplay.identifier
                vc.listType = .remote
                vc.hidesBottomBarWhenPushed = true
                if var tmpViewControllers = self.tpNavigationController?.viewControllers {
                    tmpViewControllers.insert(vc, at: tmpViewControllers.count - 1)
                    self.tpNavigationController?.setViewControllers(tmpViewControllers, animated: true)
                }
            }
        }
    }
}

extension OnlineDeviceListMasterViewController: DeviceSDCardStatusChecker {
    var listType: TPSSDeviceListType { return .remote }

    func formatProcessDidFinish() {
        currentList.reload()
    }
}

extension OnlineDeviceListMasterViewController: DeviceSelectionViewControllerDelegate {
    func deviceSelectionViewController(_ deviceSelectionViewController: DeviceSelectionViewController, didPressRightBarButtonItemWithDeviceChannels selectedDeviceChannels: [DeviceDetail: [ChannelId]]) {
        switch deviceSelectionViewController.entryType {
        case .groupAddIndependent:
            ToastView.showLoadingToast(cirleWithMessage: nil)

            let targetDeviceChannels = DeviceSelectionViewController.covertDeviceChannel(selectedDeviceChannels)
            DeviceListManager.shared.createGroup(name: newCreateGroupName, deviceChannelMap: targetDeviceChannels).always {
                ToastView.dismissLoadingToast()
            }.then { (groupID) in
                self.navigationController?.popToViewController(self, animated: true)
                self.reload(with: groupID)
            }.catch { (error) in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }
        default:
            break
        }
    }
}

// MARK: - notification
extension OnlineDeviceListMasterViewController {
    @objc private func handleDeviceListInvalidated() {
        shouldRecreate = true
        deviceListVCCacheDictionary.removeAll()
    }

    @objc private func handleDeviceListUpdated() {
        showUpdateAlertIfAny()
    }

    @objc private func handleReorderBegined(_ notification: Notification) {
        enterReorderMode()
    }

    @objc private func handleReorderEnded(_ notification: Notification) {
        exitReorderMode()
    }

    @objc private func handleUpdateGroupAndDeviceList(_ notification: Notification) {
        if isCloudLogin {
            handleGroupModeToggleAfterGetList(notification)
        } else if isShowing {
            // 处理非登录场景

            // 仅页面正在显示才处理数据获取结果更新页面状态，否则等viewWillAppear再处理。避免正在获取列表
            // 时切换到其它页面，列表获取有结果后触发本逻辑使得子VC触发viewWillAppear，后续真正展示页面时
            // 就不再触发viewWillAppear导致数据异常
            showEmpty()
        }
    }

    @objc private func handleLocalDeviceRefreshed(_ notification: Notification) {
        if !isCloudLogin && isShowing {
            // 非登录且页面正在显示时才需要处理因网络状态变化重新发现完的通知，因为此时可能需要在有/无设备的页面之间切换。
            // 如果页面没有在显示则不需要处理，因为viewWillAppear会触发该逻辑
            showEmpty()
        }
    }

    @objc private func handleUpdateGroupList(_ notification: Notification) {
        if let dic = notification.object as? [String: Any],
           let error = dic[DeviceListManager.notificationKeyError] as? Error {
            ToastView.showWarningToast(title: error.localizedDescription, existTime: nil, centerY: .lowest)
            return
        }
        // 失败也更新，此时显示默认分组
        refreshAfterGroupUpdated()
    }

    private func handleGroupModeToggleAfterGetList(_ notification: Notification) {
        let finishHandler: (() -> Void) = {
            if self.shouldToggleGroupModeAfterGetList {
                ToastView.dismissLoadingToast()
                self.shouldToggleGroupModeAfterGetList = false
                self.toggleGroupMode()
            }
        }

        guard let dic = notification.object as? [String: Any],
              let status = dic[DeviceListManager.notificationKeyListUpdateStatus] as? DeviceListUpdateStatus else {
            finishHandler()
            return
        }

        if status.cloudUpdateNecessaryInfoFinished {
            finishHandler()
        }
    }
}

extension OnlineDeviceListMasterViewController: Storyboarded {
    static var storyboardName: String { return "DeviceList" }
    static var storyboardBundle: Bundle? { return Bundle.deviceListModuelBundle }
}

extension Notification.Name {
    static var DeviceListUpdated: Notification.Name { return Notification.Name("DeviceListUpdated") }
}

// MARK: - setup
extension OnlineDeviceListMasterViewController {
    private func setupView() {
        setupBarButtonItems()
        setupButtons()
    }

    private func setupBarButtonItems() {
        navigationItem.leftBarButtonItem = moreToolBarButtonItem
        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
    }

    private func setupButtons() {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }
}

// MARK: - reorder
extension OnlineDeviceListMasterViewController {
    // 本vc不会主动进入排序模式，而是依赖于OnlineDeviceListViewController的通知
    private func enterReorderMode() {
        isReordering = true
        tabBarController?.tabBar.isUserInteractionEnabled = false
        groupToolbarContainer.isUserInteractionEnabled = false

        pageController.scrollEnable = false

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
    }

    private func showUpdateAlertIfAny() {
        if DeviceListManager.shared.allDetailDevices.contains(where: {(DeviceListModule.shared.requiredService?.onboardingTypeFromQRCode(qrCode: $0.qrCode) ?? 0) == TPSS_EC_GENERAL} ) || DeviceListManager.shared.hasUnsupportedDevice {
            // 二维码获取不支持的设备或者读取设备列表中有不支持的设备时，弹出升级提示
            let lastVersion: (isShow: Bool, versionCode: Int) = DeviceListModule.shared.requiredService?.checkShowUpdateAlert() ?? (false, 0)
            if lastVersion.isShow {
                showAlertWith(title: LocalizedString(key: commonNoticeUpdateAPP), message: nil, messageTextAlignment: nil,
                              defaultButtonTitle: LocalizedString(key: commonUpdateNow), defaultButtonColor: .theme1,
                              cancelButtonTitle: LocalizedString(key: commonIgnoreNotice), cancelButtonColor: .black.withAlphaComponent(0.8),
                              cancelButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.updateUserNoMoreNotify(version: lastVersion.versionCode)
                    self.showDiskAlertIfAny()
                }, defaultButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.jumpAndCheckAppVersion()
                    self.showDiskAlertIfAny()
                })
            } else {
                showDiskAlertIfAny()
            }
        } else {
            showDiskAlertIfAny()
        }
    }

    private func exitReorderMode() {
        tabBarController?.tabBar.isUserInteractionEnabled = true
        groupToolbarContainer.isUserInteractionEnabled = true

        pageController.scrollEnable = true

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }

        isReordering = false
    }
}
//
//  SweeperMainViewController.swift
//  Pods
//
//  Created by 爱迪生 on 2021/8/2.
//

import UIKit
import SurveillanceHomeBase
import Promises
import SwiftyJSON
import SharedResource
import TPFoundation
import SimplePlayer
import DeviceDetailModule
import SnapKit
import NetService
import ThemeTool

enum CaptureImageLoadingStatus: Equatable {
    case loadSuccess
    case failure
    case loading
    case loadNoImage
    case model(SweeperBarrierType)
}

enum MainMapLoadingState {
    case loading
    case failure
    case noMap
    case hasMap
}

class SweeperMainViewController: SweeperGlobalConfigurationViewController {
    var needShowFastMapGuide: Bool = false
    // MARK: subviews
    private var previewButton: SweeperButton?
    weak var inputPasswordVC: UIViewController?
    var inputPassword: String?
    private var editButton: SweeperButton?
    private var baseStationButton: SweeperButton?
    private var moreButton: SweeperButton?
    private var parameterButton = SweeperButton()
    private var navigationTitleView = SweeperTitleBatteryView()
    private var chargeButton = SweeperButton()
    private var createMapContainer: SweeperCreateMapView?
    private var sweepAreaPopView: SweeperClearAreaPopView?
    private var sweeperAlarmViewController: (UIViewController & SweeperAlarmWindowSuitable)?
    private var startCleanAnimationView: SweeperStartCleanAnimationView?
    private var mapView = SweeperHomeMapView(frame: .zero, mapSize: .init(width: 1200, height: 1200))
    private var loadingView = SweeperMainMapLoadingView(frame: .zero)
    private var buttonContainerStackView = UIStackView()
    private var environmentView = UIView(frame: .zero)
    private var temperatureView = UILabel(frame: .zero)
    private var humidityView = UILabel(frame: .zero)
    private var equipmentOfflineView: SweeperRobotOfflineView?

    private var sweepControlView = SweeperControlView()
    private var sweepCaptureView = SweeperCaptureBubbleView()
    private var sweeperBaseUpgradingView = SweeperBaseStationUpgradingView()
    private var sweeperMechanicalOffView = SweeperMechanicalOffView()

    private var sweepControlViewHeightConstraint: NSLayoutConstraint?
    private var heightForControlView: CGFloat {
        switch status {
        case .stop:
            return 88 + bottomSafeAreaInset
        case .fastMap, .fastMapPause:
            return 69 + bottomSafeAreaInset
        case .sweepingPause, .sweeping:
            return 143 + bottomSafeAreaInset
        }
    }

    enum AlarmButtonClickMode {
        case exit
        case more
        case none
    }
    private var alarmButtonClickMode: AlarmButtonClickMode = .exit

    // 快速建图引导view
    private var fastMapImageView: UIImageView?
    private var fastMapGuideView: GuidePresentationView?


    // 地图已自动保存通知
    private var savedMapNoticeView: UIImageView?
    private var saveMapGuideView: GuidePresentationView?
    // 存储设备详细信息
    private var deviceDetail: DeviceDetail?
    private var isSharedDevice: Bool {
        return deviceDetail?.isSharedDevice ?? false
    }

    private var robotOffline = false
    private var hadStartWaveAnimation = false

    /// 首次载入
    /// 第一帧地图帧/路径帧到来时刷新所有界面
    private var needRefreshMapViewInMediaPlayer = true
    private var needEntrySaveMapLogic = true
    private var needShowCleaningLog = true

    /// 该属性用于，当前保存地图弹窗弹出时，扫地机正在清扫。保存该弹出状态，在清扫结束后再进入一遍保存地图逻辑。
    private var needEntrySaveMapLogicAfterBasicStateChanged = false


    /// 在地图变化时，将下列是否需要展示“地图保存”弹窗标识为true
    /// 在dataloading成功时，进行展示
    private var needShowSaveMapMultiFloor = false
    private var needShowSaveMapSingleFloor = false
    private var needShowMapHasSavedTip = false

    /// 基站升级与关机页面展示
    private var isShowingUpgradingView: Bool {
        get {
            return !sweeperBaseUpgradingView.isHidden
        }
        set {
            sweeperBaseUpgradingView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var isShowingMechanicalView: Bool {
        get {
            return !sweeperMechanicalOffView.isHidden
        }
        set {
            sweeperMechanicalOffView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var shouldShowChargeButton: Bool {
        get {
            guard let state = state else {
                return false
            }
            // 清扫完成并且不在基站上
            return state.cleanFinished && !state.onboard
        }
    }

    private var firstTimeUpdateNavigationTitle: Bool = true

    private var cleaningMode: SweeperCleaningMode {
        get {
            return sweeperControl?.cleaningMode ?? SweeperCleaningMode.init(type: .autoClean)
        }
        set {
            sweeperControl?.cleaningMode = newValue
            updateCleaningModeUI()
        }
    }

    private var cleaningModeType: CleaningModeType {
        get {
            return cleaningMode.type
        }
        set {
            cleaningMode.type = newValue
        }
    }

    override var sweeperCustomOrAutoMode: SweeperCustomOrAutoMode {
        get {
            return (sweeperControl?.customCleanEnabled ?? false) ? .custom : .auto
        }
        set { }
    }

    private var map: SweeperMap? {
        get {
            return sweeperControl?.map
        }
        set {
            let preMap = map
            sweeperControl?.map = newValue
            currentMapDidChanged(preMap: preMap)
        }
    }

    private var status: SweeperProcedure = .stop

    private var state: SweeperState? {
        get {
            return sweeperControl?.basicState
        }

        set {
            sweeperControl?.basicState = newValue
            basicStateChangeAction(showToast: true)
        }
    }

    private var temperatureText: String {
        get {
            var text = "环境温度："
            if let temperature = state?.temperature {
                let temperatureValue = Int(temperature)
                if temperatureValue == 127 || temperatureValue < -40 {
                    text += "--"
                } else {
                    text += "(Int(temperature))℃"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var humidityText: String {
        get {
            var text = "环境湿度："
            if let humidity = state?.humidity {
                let humidityValue = Int(humidity)
                if humidityValue < 0 || humidityValue > 100 {
                    text += "--"
                } else {
                    text += "(Int(humidity))%"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var cleaningState: SweeperCleaningState? {
        get {
            return sweeperControl?.cleaningState
        }

        set {
            sweeperControl?.cleaningState = newValue
            updateCleaningStateUI()
        }
    }

    private var isRecharging: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .recharge
    }

    private var forbiddenRechargeAndClean: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .assignLocation || state.mainState == .remoteControl
    }

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = SharedResource.sharedImage(named: "shared_setting_icon_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(settingBarButtonItemDidClick))
    }()

    // selected layerID backup
    private var selectedLayerID = [Int]()

    // 当前展示的障碍物ID
    private var obstacleID: Int?

    override var navigationBarTraits: [NavigationBarTrait] {
        return [.hidden(on: false), .style(style: .default), .translucent(on: false), .barTint(color: .init(hexString: lightGray10Color)), .separatorStyle(color: .clear, height: 0.0), .backgroundImage(image: UIImage())]
    }

    // MARK: - Constants
    private let chargeButtonPadding = 8.0
    private let defaultButtonPadding = 12.0
    private let defaultButtonInterval = 59.0
    private let battreyThreshold = 20
    private let bottomSafeAreaInset = TPUIUtils.safeAreaInsets().bottom

    override init(deviceID: TPSSDeviceIdentifier, listType: TPSSDeviceListType) {
        super.init(deviceID: deviceID, listType: listType)

        SweeperModule.shared.registerControlListener(listener: self, deviceID: deviceID, listType: listType)
        SweeperModule.shared.registerMapListener(mapListener: self)
        NotificationCenter.default.addObserver(self, selector: #selector(willEnterForeground), name: UIApplication.willEnterForegroundNotification, object: nil)
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        view.backgroundColor = .init(hexString: lightGray10Color)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        setupNavigation()
        setupControlView()
        setupMapView()
        setupSweeperAlarmView()
        setupButtons()
        setupOfflineView()
        setupEnvironmentView()
        setupLoadingView()
        setupUpgradingView()
        setupMechanicalOffView()
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true

        // 离开当前页面时，会使动画失效，若正在展示动画，再重新进入时，需要重新开始动画
        if hadStartWaveAnimation {
            startWaveAnimation()
        }

        if let loadingState = sweeperControl?.dataLoadingState {
            dataLoadingStateChangeAction(loadingState: loadingState)
        } else {
            updateViewShowState(state: .failed)
        }
        captureBubbleViewDismiss()
        // 横幅始终展示在最前方
        if let alarmView = sweeperAlarmViewController?.view {
            view.bringSubviewToFront(alarmView)
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        if needShowFastMapGuide {
            showFastMapGuideView()
            needShowFastMapGuide = false
        }
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        savedMapNoticeView?.removeFromSuperview()
    }

    deinit {
        SweeperModule.shared.removeControlListener(listener: self)
        SweeperModule.shared.removeMapListener(mapListener: self)
        NotificationCenter.default.removeObserver(self)
    }

    // 将从后台切换到前台，看作视图willAppear，方法作相同处理
    @objc func willEnterForeground() {
        cleanAllFlag()

        // 若当前的载入状态为loading时，对UI进行loading状态的刷新。
        // 否则等待dataLoadingStateDidChanged方法回调(从 loading -> 其他状态)。
        // 注：dataLoadingStateDidChanged方法在 loading -> loading 时不会被调用。
        if sweeperControl?.dataLoadingState == .loading {
            dataLoadingStateChanged(loadingState: .loading)
        }
    }

    /// 根据载入状态更新主页面View的展示情况
    /// -主页面加载状态 -
    /// 需要管理的控件：创建地图按钮、主页面地图、载入（载入失败）页面、编辑地图按钮、边扫边拖（定制清扫）悬浮按钮
    private func updateViewShowState(state: SweeperDataLoadingState) {
        switch state {
            case .loading:
                loadingView.isHidden = false
                loadingView.isLoadingFailure = false
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
            case .failed:
                loadingView.isLoadingFailure = true
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
                // 若扫地机离线，则展示离线页面，否则展示加载失败页面
                loadingView.isHidden = robotOffline
                equipmentOfflineView?.isHidden = !robotOffline
            case .noMap:
                createMapContainer?.isHidden = false
                loadingView.isHidden = true
                mapView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                parameterButton.isHidden = false
                moreButton?.isHidden = false
                editButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
            case .success:
                loadingView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                mapView.isHidden = false
                createMapContainer?.isHidden = true
                parameterButton.isHidden = false
                editButton?.isHidden = false
                moreButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
        }
    }

    override func willUpdateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode, showAlert: Bool) -> Bool {
        /// 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            if showAlert {
                showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap)
            }
            return false
        }
        return super.willUpdateSweeperCustomOrAutoMode(newMode: newMode, showAlert: showAlert)
    }

    override func updateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode) {
        /// 1. 若切换时当前清扫模式与newMode相同，则无需进入后续逻辑
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap,
              let sweeperControl = sweeperControl,
              let mapID = sweeperControl.map?.currentMapID,
              newMode != sweeperCustomOrAutoMode else {
            return
        }

        /// 2. 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap) { [weak self] (_) in
                self?.configurationView?.selectSegment(type: .auto)
            }
            return
        }

        /// 3. 切换为定制清扫时，无设置清扫顺序与清扫偏好，则不向设备发送请求（并在退出弹窗时（configurationFinished）切换回变扫边拖）
        if newMode == .custom && !isSetPreference() && !isSetSweepSeq() {
            return
        }

        /// 4. 发送切换清扫模式的接口，并修改主页面UI
        let customCleanEnabled = newMode == .custom
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestSetCleaningParam(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: mapID, customEnabled: customCleanEnabled).always {
            ToastView.dismissLoadingToast()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }

    override func configurationFinished() {
        /// 若configurationView当前处于定制清扫页面（“1”状态），则判断是否已设置定制清扫，若否切回边扫边拖。
        if !isSetPreference() && !isSetSweepSeq() && !settingButtonDidClickFlag && configurationView?.segmentedControl.selectedSegmentIndex == 1 {
            ToastView.showWarningToast(title: "未设置定制清扫，只能使用普通清扫", existTime: nil, centerY: .low)
            // 0 - means auto cleaning
            configurationView?.selectSegment(type: .auto)
        }
    }

    override func preferenceButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.preferenceButtonClickOperation()
    }

    override func sweepOrderButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.sweepOrderButtonClickOperation()
    }

    private func refreshMediaPlayerAndSweeperControl() {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.refreshSweeperControl()
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
    }

    private func updateConfigurationView() {
        configurationView?.selectSegment(type: sweeperCustomOrAutoMode)
        if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
            cleanMethodMode = mode
        }
    }

    private func updateClearingAreaButton() {
        var text = "全屋"
        var imagePath = "sweep_home"
        var title = text
        switch cleaningModeType {
        case .pointClean:
            text = "选框"
            title = text
            imagePath = "sweep_frame"
        case .areaClean:
            text = "区域"
            title = text
            imagePath = "sweep_region"
        case .autoClean:
            text = "全屋"
            title = text
            imagePath = "sweep_home"
        case .partClean:
            // 仅在sweepControlView的RangeTitle中修改
            updateData(with: .autoClean)
            title = "局部"
        case .fastMap:
            // DO NOTHING
            return
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
        sweepControlView.clearAreaButton?.titleLabel.text = text
        sweepControlView.clearAreaButton?.titleImageView.image = UIImage.image(named: imagePath)
        sweepControlView.rangeTitleLabel.text = title
        sweepControlView.clearAreaButton?.selectedAreaNumber = cleaningModeType == .areaClean ? selectedLayerID.count : 0
    }

    private func updateSweeperHomeMapViewCleanMode() {
        switch cleaningModeType {
        case .pointClean:
            mapView.cleaningModeType = .pointClean
        case .areaClean:
            mapView.cleaningModeType = .areaClean
        case .autoClean:
            mapView.cleaningModeType = .autoClean
        case .partClean:
            mapView.cleaningModeType = .partClean
        case .fastMap:
            mapView.cleaningModeType = .fastMap
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
    }

    private func updateSelectedLayerID() {
        if let seq = sweeperControl?.cleaningMode.areaIDs {
            selectedLayerID = seq
        }
    }

    private func updateParamUI() {
        var text = ""
        var imagePath = ""
        switch sweeperCustomOrAutoMode {
        case .auto:
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                switch mode {
                case .sweep:
                    text = LocalizedString(key: sweeperCleanOnlySweep)
                    imagePath = "mode_sweep"
                case .mop:
                    text = LocalizedString(key: sweeperCleanOnlyMop)
                    imagePath = "mode_mop"
                case .both:
                    text = LocalizedString(key: sweeperCleanSweepAndMop)
                    imagePath = "mode_sweep_mop"
                }
            }
        case .custom:
            text = LocalizedString(key: sweeperCustomClean)
            imagePath = "mode_diy"
        }
        let image = UIImage.image(named: imagePath)
        // 控制栏的参数按钮
        sweepControlView.parameterButton?.titleLabel.text = text
        sweepControlView.parameterButton?.titleImageView.image = image

        // 悬浮的参数按钮
        parameterButton.titleLabel.text = text
        parameterButton.titleImageView.image = image
    }

    private func updateSweeperHomeMapViewCustomOrAutoMode() {
        switch sweeperCustomOrAutoMode {
        case .auto:
            mapView.sweeperCustomOrAutoMode = .auto
        case .custom:
            mapView.sweeperCustomOrAutoMode = .custom
        }
    }

    private func dataLoadingStateChangeAction(loadingState: SweeperDataLoadingState) {
        // 1. 判断设备是否离线（deviceDetail.online）
        if loadingState == .failed {
            robotOffline = !(deviceDetail?.online ?? false)
        }

        // 2. 判断基站是否升级，若是，则不展示所有UI（除了导航栏）
        if state?.chargeBaseUpgrading == true {
            isShowingUpgradingView = true
            updateNavigation()
            return
        }

        if let switchOn = state?.mechanicalSwitchOn {
            showMechanicalOffView(switchOn: switchOn)
        }

        // 3. 刷新UI状态(是否hidden)
        updateViewShowState(state: loadingState)

        // 4. 载入成功（success or nomap）按照其他状态展示UI
        if loadingState == .success {
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            mapView.updateCleanningModeAndSweepingState()
            mapView.updateCustomOrAutoMode()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            sweeperAlarmViewController?.showAlarm()
            sweeperAlarmViewController?.showNotify()
            if needShowCleaningLog {
                sweeperAlarmViewController?.showCleaningLog()
                needShowCleaningLog = false
            }
            if needEntrySaveMapLogic {
                currentMapDidChanged(preMap: nil)
                needEntrySaveMapLogic = false
            }
            saveMapLogic()
        } else if loadingState == .noMap {
            // 尽管当前map id 为-2，但当设备发送地图帧过来时，仍然需要展示地图，故仍然需要刷新mapView
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            sweeperAlarmViewController?.showCleaningLog()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            // 用户未进入引导页，且当前不在清扫、建图中，需要进入快速建图引导页
            if UserDefaults.standard.shouldShowGuideForFastMap(for: deviceID) && (state?.cleanFinished ?? true) {
                let vc = SweeperFastMapGuideViewController(deviceID: deviceID, listType: listType)
                navigationController?.pushViewController(vc, animated: true)
            }
        }
    }

    private func saveMapLogic() {
        // 若需要展示弹窗，但当前在清扫中，则将弹窗状态保存起来，待扫地机状态变化时重新进入。
        if state?.cleanFinished == false && (needShowSaveMapSingleFloor || needShowSaveMapMultiFloor) {
            needEntrySaveMapLogicAfterBasicStateChanged = true
            return
        }
        if needShowMapHasSavedTip {
            showMapHasSavedTip()
            needShowMapHasSavedTip = false
        }
        if needShowSaveMapSingleFloor {
            saveMapSingleFloor()
            needShowSaveMapSingleFloor = false
        }
        if needShowSaveMapMultiFloor {
            saveMapMultiFloor()
            needShowSaveMapMultiFloor = false
        }
    }

    private func basicStateChangeAction(showToast: Bool) {
        // 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 展示波纹动画: 1. 当前地图ID为-2；
        //             2. 当前在清扫中；
        //             3. 未展示过动画
        //             4. 无地图帧
        if map?.currentMapID == noMapID
            && state?.cleanFinished == false && !hadStartWaveAnimation && sweeperControl?.hadFrame == false {
            startWaveAnimation()
        }
        if (state?.cleanFinished == true) {
            stopWaveAnimation()
        }
        // 特殊情况处理，当扫地机进入清扫状态时
        // 且当前处于无地图时，需要显示地图（而非等到map更改的信令进行变化）
        // 再次变为非清扫状态，且无地图时，需要展示无地图Image
        if map?.currentMapID == noMapID && state?.cleanFinished == false {
            updateViewShowState(state: .success)
        } else if map?.currentMapID == noMapID && state?.cleanFinished == true {
            updateViewShowState(state: .noMap)
        }

        // 扫地机关机状态更新
        showMechanicalOffView(switchOn: state?.mechanicalSwitchOn ?? false)

        if showToast {
            updateBasicStateToastView()
        }
        // 更新扫地机当前的清扫状态（将扫地机状态分为清扫中、暂停中、未清扫，后续根据该status更新清扫UI）
        updateSweepProduce()

        updateUI()
    }

    /// 使用Clean Finished，fast Map  字段与 basic state字段联合判断当前清扫是否结束
    private func updateSweepProduce() {
        guard let state = state else {
            status = .stop
            return
        }
        if state.cleanFinished && state.mainState != .paused && state.mainState != .cleaning {
            // 若设备清扫完成且设备主状态不在清扫、暂停时
            status = .stop
        } else {
            if state.fastMap {
                // 若为快速建图
                if state.mainState == .cleaning {
                    status = .fastMap
                } else {
                    status = .fastMapPause
                }
            } else {
                // 若不为快速建图，则展示正常清扫UI
                if state.mainState == .cleaning {
                   status = .sweeping
                } else {
                   status = .sweepingPause
                }
            }
        }
    }

    // 根据信令展示ToastView
    private func updateBasicStateToastView() {
        guard let state = state else {
            return
        }
        // 主状态为回充，遥控，清扫时候，主页均需展示loading
        if ((state.mainState == .cleaning || state.mainState == .recharge || state.mainState == .remoteControl) && state.subState == .relocate) {
            ToastView.showLoadingToast(cirleWithMessage: "定位中...", existTime: 60, existMessage: nil)
        } else {
            ToastView.dismissLoadingToast()
        }
    }

    /// 根据status更新：清扫面板、清扫参数、导航栏里扫地机的状态、回充按钮、提示栏的位置；
    /// status:     sweeping：当cleanFinished为false，且mainState为Cleaning，subState为Sweeping；
    ///        pause：当cleanFinished为false，
    private func updateUI() {
        // 只当地图数据载入完成之后，更新信令收到后的UI
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 每次收到信令后，获取设备状态，更新设备状态同时更新界面UI

        // 控制面板
        sweepControlView.status = status
        sweepControlViewHeightConstraint?.constant = heightForControlView
        if status == .stop {
            // 清扫参数按钮
            parameterButton.isHidden = true
            // 地图控件
            mapView.isSweeping = false
        } else if status == .fastMap || status == .fastMapPause {
            mapView.isSweeping = true
            parameterButton.isHidden = true
        } else {
            parameterButton.isHidden = false
            mapView.isSweeping = true
        }
        // 导航栏的状态和电量
        updateNavigation()
        // 温度湿度更新
        updateEnvironmentView()
        // 充电按钮
        updateChargeButton()
        refreshBubbleView()
    }

    private func updateCleaningStateUI() {
        guard let state = cleaningState else {
            return
        }
        sweepControlView.areaTitleLabel.text = "(state.cleaningArea)㎡"
        sweepControlView.timeTitleLabel.text = "(state.cleaningTime)min"
    }

    private func updateCleaningModeUI() {
        /// 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        /// 修改设置清扫模式（cleaningMode）按钮的样式
        updateClearingAreaButton()
        /// 修改地图的清扫模式
        updateSweeperHomeMapViewCleanMode()
        /// 根据获取到的cleaningMode中区域清扫的ID，更新地图区域的清扫顺序数组
        updateSelectedLayerID()
        /// 修改定制清扫/边扫边拖属性 - 通过回调去更新该属性更新后主页后续的UI。回调中调用的方法 - updateSweeperCustomOrAutoMode()
        updateConfigurationView()
        /// 修改定制清扫/边扫边拖按钮的样式
        updateParamUI()
        /// 修改定制清扫/边扫边拖地图的样式
        updateSweeperHomeMapViewCustomOrAutoMode()
    }

    private func showAlertWithWholeHouseClean() {
        showAlertWith(title: "进行一次全屋清扫", message: "清扫完成后，将建立家居地图。", messageTextAlignment: .center, defaultButtonTitle: "进行全屋清扫", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonHandler: nil) { [weak self] (_) in
            self?.showSweepTipsAlert()
        }
    }

    private func startFastMap() {
        if sweeperControl?.basicState?.mainState == .remoteControl {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFastMapDuringRemoteControl))
            return
        }
        if sweeperControl?.basicState?.mainState == .assignLocation {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFAstMapDuringAssignLocation))
            return
        }
        // 强制扫地机进入新建快速地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .fastMap)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: self.deviceID, channel: self.channel, listType: self.listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func startFastMapAlert() {
        let alert = SweeperTipsAlert(type: .fastMap) { [weak self] () in
            guard let self = self else { return }
            self.startFastMap()
        }
        alert.show()
    }

    private func showAlertWithFastMapEnd() {
        showAlertWith(title: "尚未得到完整地图，确定要结束吗？", message: nil, messageTextAlignment: .center, defaultButtonTitle: "结束建图", defaultButtonColor: .theme1, cancelButtonTitle: "继续", cancelButtonHandler: nil) { [weak self] (_) in
            self?.setCleaningMode(type: .stop)
        }
    }

    private func showSweepTipsAlert() {
        let alert = SweeperTipsAlert(type: .clean) { [weak self] () in
            self?.setCleaningMode(type: .sweeping)
        }
        alert.show()
    }

    private func setCleaningMode(type: SweeperProcedure) {
        switch type {
        case .sweeping:
            if sweeperControl?.basicState?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringRemoteControl))
                return
            }
            if sweeperControl?.basicState?.mainState == .assignLocation {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringAssignLocation))
                return
            }
            // 若扫地机当前无地图，则所有“清扫”操作为全屋清扫。
            if map?.currentMapID == noMapID {
                self.cleaningMode = SweeperCleaningMode.init(type: .autoClean)
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: SweeperCleaningMode.init(type: .autoClean)).catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
                return
            }

            if cleaningModeType == .areaClean {
                if selectedLayerID.count == 0 {
                    ToastView.showWarningToast(title: "请选择需要清扫的区域", existTime: nil, centerY: .low)
                    return
                }
                sweeperControl?.cleaningMode.areaIDs = selectedLayerID
            } else if cleaningModeType == .pointClean,
                      let partArea = mapView.getSelectionRect() {
                // 若能够从SelectionRect获取到数据，则修改cleaningMode的PointRect
                sweeperControl?.cleaningMode.leftTopPoint = partArea.leftTopPoint
                sweeperControl?.cleaningMode.rightBottomPoint = partArea.rightBottomPoint
            } else {
                sweeperControl?.cleaningMode = .init(type: .autoClean)
            }

            ToastView.showLoadingToast(cirleWithMessage: nil)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: sweeperControl?.cleaningMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .sweepingPause, .fastMapPause:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .pause)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .stop:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .stop)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .fastMap:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .fastMap)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func saveMapSingleFloor() {
        let deleteMapID = map?.allMapNames.keys.first(where: { (mapID) -> Bool in
                  return mapID != temporaryMapID
              })
        guard let sweeperControl = sweeperControl,
              let deleteMapID = deleteMapID,
              let deleteMapName = map?.allMapNames[deleteMapID] else {
            return
        }
        showAlert(title: "是否保存新地图?", buttons: [
            .init(style: .default, text: "更新“(deleteMapName)”", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                ToastView.showLoadingToast(cirleWithMessage: "正在更新")
                SweeperService.deleteMap(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: deleteMapID).then { (_) in
                    ToastView.showWarningToast(title: "更新成功", existTime: nil, centerY: .low)
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
            }),
            .init(style: .default, text: "另存为新地图", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let alert = SweeperSelectionAlert(title: "相同环境请勿保存多张地图，有可能影响机器人的定位。", message: "我家为多楼层户型") {
                    guard self?.isCurrentMapSaved() == true else {
                        ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                        return
                    }
                    ToastView.showLoadingToast(cirleWithMessage: "正在保存")
                    SweeperService.setMultiFloorEnabled(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, enabled: true, mapID: nil).always {
                        ToastView.dismissLoadingToast()
                    }.then { _ in
                        ToastView.showWarningToast(title: "保存成功", existTime: nil, centerY: .low)
                    }.catch { (error) in
                        ToastView.showWarningToast(warningMessage: error.localizedDescription)
                    }
                } cancelHandler: { [weak self] () in
                    self?.saveMapSingleFloor()
                }
                alert.show()
            }, isPreferred: true),
            .init(style: .default, text: LocalizedString(key: notSaveMap))
        ])
    }

    private func saveMapMultiFloor() {
        showAlert(title: "地图数量已达上限，是否保存新地图？", message: "如点击“保存”，请选择新地图要覆盖哪张旧地图。", messageTextAlignment: .center, buttons: [
            .init(style: .default, text: LocalizedString(key: notSaveMap), color: .theme1),
            .init(style: .default, text: "保存", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let vc = SweeperCoverOldMapController()
                vc.sweeperControl = self?.sweeperControl
                self?.navigationController?.pushViewController(vc, animated: true)
            }, isPreferred: true)
        ])
    }

    private func isCurrentMapSaved() -> Bool {
        return map?.currentMapID == temporaryMapID
    }

    /// preMapID 为 nil，表示为第一次赋值
    private func currentMapDidChanged(preMap: SweeperMap?) {
        guard let map = map else {
            return
        }
        // 展示波纹动画条件： 1. 当前地图id为-2
        //                 2. 当前主状态为清扫中
        //                 3. 第一次进入主页面
        //                 4. 当前无地图I帧
        let needShowRobotWave = map.currentMapID == noMapID && sweeperControl?.basicState?.mainState == .cleaning && (preMap == nil || !hadStartWaveAnimation) && sweeperControl?.hadFrame == false
        if needShowRobotWave {
            startWaveAnimation()
        }
        /// preMapID 从 nil -> 0，未处理后退出主页重新进入
        /// 或 从 “-1” -> 0  表示成功创建，但还未自动保存新地图
        let preMapID = preMap?.currentMapID
        if (preMapID == nil || preMapID == isCreatingMapID) && map.currentMapID == temporaryMapID {
            ///  生成临时地图： 需要判断是多楼层还是单楼层来决定保存方式；
            guard let multiFloorEnabled = sweeperControl?.multiFloorEnabled, let maxMapNumber = sweeperControl?.capability?.maxMapNumber else {
                return
            }
            if multiFloorEnabled {
                if map.mapNumber > maxMapNumber && maxMapNumber > 0 && map.currentMapID == temporaryMapID {
                    // 地图已达上限且能力集中多楼层地图上限不为0，且当前地图是临时地图时，展示多楼层地图上限弹窗
                    needShowSaveMapMultiFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            } else {
                if map.mapNumber > 1 && map.currentMapID == temporaryMapID {
                    // 已经有一张地图且当前地图时临时地图时，展示单楼层地图上限弹窗。
                    needShowSaveMapSingleFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            }
            return
        }

        /// 成功创建，mapID 从 “-1” -> 大于0
        if preMapID == isCreatingMapID && map.currentMapID != noMapID && map.currentMapID != temporaryMapID && map.allMapNames.count == (preMap?.allMapNames.count ?? 0) + 1 {
            ///  生成完整地图：直接进入“已自动保存逻辑”
            needShowMapHasSavedTip = true
        }
    }

    private func showMapNotCompletedAlert(alertMessage: String, cancelHandler: ((UIAlertAction) -> Void)? = nil, defaultHandler: (() -> Void)? = nil) {
        showAlertWith(title: alertMessage, message: nil, messageTextAlignment: nil, defaultButtonTitle: "查看帮助", defaultButtonColor: .theme1, cancelButtonTitle: "关闭", cancelButtonColor: .theme1, cancelButtonHandler: cancelHandler, defaultButtonHandler: { [weak self] (_) in
            let vc = SweeperMapHelpViewController(type: .incomplete)
            self?.navigationController?.pushViewController(vc, animated: true)
            defaultHandler?()
        })
    }

    private func showCanNotCustomCleanAlert(isCreatingMap: Bool, defaultButtonhandler: ((UIAlertAction) -> Void)? = nil) {
        if isCreatingMap {
            showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持定制清扫", defaultHandler: { [weak self] () in
                self?.configurationView?.dismiss()
            })
        } else {
            showAlertWith(title: "请创建地图后再设置定制清扫", defaultButtonTitle: SharedResource.sharedFormatString(key: commonSure), defaultButtonColor: UIColor.black, cancelButtonTitle: nil, defaultButtonHandler: defaultButtonhandler)
        }
    }

    func showFastMapGuideView() {
        if fastMapImageView == nil {
            fastMapImageView = UIImageView()
            fastMapImageView?.image = UIImage.image(named: "quick_build_map")
            fastMapImageView?.sizeToFit()
        }
        guard let imageView = fastMapImageView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            fastMapGuideView?.dismiss()
            var offset: CGFloat = defaultButtonInterval
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            fastMapGuideView = presentGuideWith(viewToPresent: imageView, size: imageView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    func showMapHasSavedTip() {
        if savedMapNoticeView == nil {
            savedMapNoticeView = UIImageView()
            savedMapNoticeView?.image = UIImage.image(named: "edit_map")
            savedMapNoticeView?.sizeToFit()
        }
        guard let noticeView = savedMapNoticeView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            saveMapGuideView?.dismiss()
            var offset: CGFloat = 0
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            saveMapGuideView = presentGuideWith(viewToPresent: noticeView, size: noticeView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    override func collectionViewCell(_ cell: SweeperGlobalCleaningConfigurationCollectionViewCell, didSelectItemAt indexPath: IndexPath) {
        super.collectionViewCell(cell, didSelectItemAt: indexPath)

        let itemIndex = indexPath.section
        let row = indexPath.row
        let parameter = settingItems[itemIndex].paramters[row].type
        if parameter == .suctionForce(.none) {
            showAlertWith(title: "静音模式下吸尘能力将暂时降低，仅本次清扫任务生效。", message: nil, messageTextAlignment: nil, defaultButtonTitle: "确定", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonColor: .black, cancelButtonHandler: nil) { [weak self] (_) in
                self?.setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
            }
        } else {
            setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
        }
    }

    func setGlobalConfig(parameter: SweeperGlobalConfigurationType, itemIndex: Int) {
        var pendingConfig = sweeperControl?.globalCleaningConfig

        switch parameter {
        case .suctionForce(_):
            pendingConfig?.suction = parameter
        case .waterYield(_):
            pendingConfig?.waterYield = parameter
        case .sweepTimes(_):
            pendingConfig?.cleanTimes = parameter
        case .cleanMethod(_):
            pendingConfig?.cleanMethod = parameter
        case .mopMode(_):
            pendingConfig?.mopMode = parameter
        }


        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setGlobalCleaningConfig(device: deviceID, channel: channel, listType: listType, config: pendingConfig).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.then { [weak self] (_) in
            self?.sweeperControl?.globalCleaningConfig = pendingConfig
            self?.configurationView?.collectionView.reloadData()
            self?.updateParamUI()
        }
    }

    func startWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        let animationView = SweeperStartCleanAnimationView(frame: .zero)
        view.addSubview(animationView)

        animationView.snp.makeConstraints { make in
            make.centerX.equalToSuperview().offset(28)
            make.centerY.equalToSuperview().multipliedBy(0.764).offset(28)
            make.width.height.equalTo(56)
        }
        self.startCleanAnimationView = animationView
        animationView.startAnimation()
        hadStartWaveAnimation = true
    }

    func stopWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        startCleanAnimationView = nil
        hadStartWaveAnimation = false
    }

    private func cleanAllFlag() {
        needEntrySaveMapLogic = true
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true
        needShowMapHasSavedTip = false
        needShowSaveMapMultiFloor = false
        needShowSaveMapSingleFloor = false
        needEntrySaveMapLogicAfterBasicStateChanged = false
    }
}

// MARK: Button Action
private extension SweeperMainViewController {
    @objc func paramterButtonDidClick() {
        configurationView?.isSetSeq = isSetSweepSeq()
        configurationView?.isSetPreference = isSetPreference()
        configurationView?.show(view: self.navigationController?.view)
    }

    @objc func clearAreaButtonDidClick() {
        sweepAreaPopView = SweeperClearAreaPopView(type: cleaningModeType)
        sweepAreaPopView?.delegate = self
        sweepAreaPopView?.show()
    }

    @objc func startButtonDidClick() {
        guard (map?.currentMapID) != nil  else {
            return
        }
        if sweeperControl?.dataLoadingState == .success {
            setCleaningMode(type: .sweeping)
        } else {
            showAlertWithWholeHouseClean()
        }
    }

    @objc func stopButtonDidClick() {
        if status == .fastMapPause || status == .fastMap {
            showAlertWithFastMapEnd()
        } else {
            setCleaningMode(type: .stop)
        }
    }

    @objc func pasueButtonDidClick() {
        if status == .sweepingPause {
            setCleaningMode(type: .sweeping)
        } else if status == .fastMapPause {
            setCleaningMode(type: .fastMap)
        } else {
            setCleaningMode(type: .sweepingPause)
        }
    }

    @objc func previewButtonDidClick() {
        guard let mediaState = sweeperControl?.mediaState, checkEntryCondition() else {
            return
        }
        checkMediaStateAndJump(state: mediaState)
    }

    func checkMediaStateAndJump(state: SweeperMediaState) {
        // 若为被分享端，则不判断，直接进入人工驾驶页面
        if isSharedDevice {
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            vc.needShowSettingButton = false
            navigationController?.pushViewController(vc, animated: true)
            return
        }

        switch state {
        case .closed, .open:
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        case .openWithPermission:
            if sweeperControl?.mediaEncryptEnabled == true {
                // 视频加密开启，直接验证密码
                checkUnAuthenticated()
                return
            }
            // 视频加密关闭，需要检测设备空密码
            ToastView.showLoadingToast(cirleWithMessage: nil)
            requestCheckEmptyPassword {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func checkEntryCondition() -> Bool {
        if state?.collectDust == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterCollectionDust))
            return false
        }
        if state?.mopWashState == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterWashingMop))
            return false
        }
        return true
    }

    @objc func baseStationButtonDidClick() {
        if sweeperControl?.basicState?.cleanSinkState != .stop {
            let vc = SweeperBaseStationCleanSinkViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        } else {
            let vc = SweeperBaseStationMainViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func moreButtonDidClick() {
        let vc = SweeperMoreActionViewController(deviceID: deviceID, listType: listType)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    @objc func editButtonDidClick() {
        // 大于0的地图数量为0时(无已保存地图)并且没有地图，不允许进入，若mapID为“-1”允许进入
        if sweeperControl?.mapWithoutZero?.count == 0 && sweeperControl?.map?.currentMapID == noMapID {
            // 若扫地机在清扫、建图时，展示暂无地图
            if (state?.cleanFinished ?? true) {
                let fastMapGuideSheet = SweeperFastMapSheet()
                fastMapGuideSheet.delegate = self
                fastMapGuideSheet.show()
            } else {
                ToastView.showWarningToast(title: "暂无地图", existTime: nil, centerY: .low)
            }
            return
        }

        let alertActionSheet = TPActionSheet.init(title: nil)
        let setRigionAction = TPActionSheetAction.init(title: "设置禁区/虚拟墙", detail: "设置不允许扫地机器人进入的区域", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }

            // 清扫过程中进入编辑禁区页面需要暂停扫地机
            if self.status == .sweeping || self.status == .fastMap {
                self.setCleaningMode(type: .sweepingPause)
            }
            // 回充过程中进入编辑进去页面需要设置为待机
            if self.state?.mainState == .recharge {
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setStandBy(deviceID: self.deviceID, listType: self.listType).always {
                    ToastView.dismissLoadingToast()
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }
            }
            // 指哪到哪和遥控时不允许进入禁区页面
            if self.state?.mainState == .assignLocation || self.state?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterMission))
                return
            }
            let vc = SweeperForbiddenAreaVirtualWallViewController(sweeperControl: self.sweeperControl)
            self.navigationController?.pushViewController(vc, animated: true)
        }

        let editMapAreaAction = TPActionSheetAction.init(title: "编辑地图区域", detail: "划分地图区域并进行标记", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }
            /// 清扫、快速建图中不允许进入编辑区域页面
            if self.status != .stop {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterCleaning))
                return
            }
            /// 正在创建地图中不允许进入编辑区域页面
            guard self.map?.currentMapID != isCreatingMapID else {
                self.showMapNotCompletedAlert(alertMessage: LocalizedString(key: sweeperMapIsNotCompleteForEditingArea))
                return
            }
            let vc = SweeperEditMapAreaViewController(sweeperControl: self.sweeperControl)
            vc.isSetPreferenceOrOrder = self.isSetPreference() || self.isSetSweepSeq()
            self.navigationController?.pushViewController(vc, animated: true)
        }


        let manageMapAction = TPActionSheetAction.init(title: "管理地图", style: .leftTitle) { [weak self] (_) in
            guard let self = self else {
                return
            }
            let vc = SweeperMapManagerViewController()
            vc.delegate = self
            vc.deviceID = self.deviceID
            vc.listType = self.listType
            self.navigationController?.pushViewController(vc, animated: true)
        }

        var editActionArray: [TPActionSheetAction] = []
        editActionArray = map?.currentMapID == noMapID ? [manageMapAction] : [setRigionAction, editMapAreaAction, manageMapAction]

        editActionArray.forEach { (action) in
            action.font = .projectFont(ofSize: 16)
            action.detailFont = .projectFont(ofSize: 12)
            alertActionSheet.addAction(action)
        }
        alertActionSheet.separatorColor = .cellSeparatorGray

        alertActionSheet.show()
    }

    @objc func settingBarButtonItemDidClick() {
        if let vc = SweeperSettingViewController.create() {
            vc.deviceID = deviceID
            vc.listType = listType
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func rechargeButtonDidClick() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setRechargeState(device: deviceID, channel: channel, listType: listType, enabled: !isRecharging).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperRobotOfflineViewDelegate {
    func offlineHelpButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.requiredService?.goToOfflineHelp(deviceID: sweeperControl.deviceID, cloudID: sweeperControl.cloudID, listType: sweeperControl.listType, navigator: self.navigationController)
    }

    func offlineRefreshButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
        SweeperModule.shared.refreshSweeperControl()
    }
}

extension SweeperMainViewController: SweeperClearAreaPopViewDelegate {
    func updateData(with type: CleaningModeType) {
        if map?.currentMapID == isCreatingMapID {
            switch type {
            case .areaClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持区域清扫")
            case .pointClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持选框清扫")
            case .autoClean:
                // DO NOTHING
                break
            case .partClean:
                // DO NOTHING
                break
            case .pause:
                // DO NOTHING
                break
            case .stop:
                // DO NOTHING
                break
            case .fastMap:
                // DO NOTHING
                break
            }
            sweepAreaPopView?.dismiss()
            return
        } else {
            if type == .areaClean {
                if map?.currentMapID != noMapID {
                    ToastView.showWarningToast(title: "请选择区域", existTime: nil, centerY: .low)
                }
            }
        }
        self.cleaningModeType = type
        sweepAreaPopView?.dismiss()
    }
}

// MARK: setup UI
private extension SweeperMainViewController {
    func setupNavigation() {

        navigationItem.title = deviceDetail?.alias ?? "扫地机器人"

        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
        addCustomNavigationLeftBarButtonItem(title: nil, image: SharedResource.sharedImage(named: "common_light_back_nor"))
    }

    func setupButtons() {
        var title: String
        var imageName: String
        if isSharedDevice {
            title = "遥控"
            imageName = "ptz"
        } else {
            title = "视频遥控"
            imageName = "preview_light_nor"
        }
        previewButton = SweeperButton(title: title, fontSize: 9, image: UIImage.image(named: imageName))
        let previewTap = UITapGestureRecognizer.init(target: self, action: #selector(previewButtonDidClick))
        previewButton?.addGestureRecognizer(previewTap)
        if let button = previewButton {
            self.view.bringSubviewToFront(button)
        }
        if let previewButton = previewButton {
            buttonContainerStackView.addArrangedSubview(previewButton)
        }

        editButton = SweeperButton(title: "编辑地图", fontSize: 9, image: UIImage.image(named: "map_black_nor"))

        let editTap = UITapGestureRecognizer.init(target: self, action: #selector(editButtonDidClick))
        editButton?.addGestureRecognizer(editTap)
        if let editButton = editButton {
            buttonContainerStackView.addArrangedSubview(editButton)
        }

        baseStationButton = SweeperButton(title: "基站", fontSize: 9, image: UIImage.image(named: "sweeper_home"))

        let stationTap = UITapGestureRecognizer.init(target: self, action: #selector(baseStationButtonDidClick))
        baseStationButton?.addGestureRecognizer(stationTap)
        if let baseStationButton = baseStationButton {
            buttonContainerStackView.addArrangedSubview(baseStationButton)
        }

        moreButton = SweeperButton(title: "更多", fontSize: 9, image: UIImage.image(named: "star"))

        let moreButtonTap = UITapGestureRecognizer.init(target: self, action: #selector(moreButtonDidClick))
        moreButton?.addGestureRecognizer(moreButtonTap)
        if let moreButton = moreButton {
            buttonContainerStackView.addArrangedSubview(moreButton)
        }

        [previewButton, editButton, baseStationButton, moreButton].forEach { button in
            button?.snp.makeConstraints { make in
                make.width.equalTo(44)
                make.height.equalTo(47)
            }
        }

        /* buttonContainerStackView */
        view.addSubview(buttonContainerStackView)
        buttonContainerStackView.axis = .vertical
        buttonContainerStackView.alignment = .center
        buttonContainerStackView.spacing = 12
        buttonContainerStackView.snp.makeConstraints { make in
            make.width.equalTo(44)
            make.top.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }

        /* createMapButton */
        createMapContainer = SweeperCreateMapView()
        if let createMapContainer = createMapContainer {
            view.addSubview(createMapContainer)

            let goldenRatio: CGFloat = 0.382
            createMapContainer.snp.makeConstraints { make in
                make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2).offset(-(88 * goldenRatio))
                make.centerX.equalToSuperview()
                make.width.equalTo(230)
            }
        }
        createMapContainer?.isHidden = true

        /* chargeButton */
        chargeButton = SweeperButton(title: "返回基站", fontSize: 9, image: UIImage.image(named: "robot_charger"), offsetToTop: 5)
        addContraint(for: chargeButton, trailingToSuperView: -defaultButtonPadding)
        chargeButton.isHidden = true
        chargeButton.snp.makeConstraints { make in
            if let sweeperAlarmView = sweeperAlarmViewController {
                make.bottom.equalTo(sweeperAlarmView.view.snp.top).offset(-defaultButtonPadding / 2)
            } else {
                make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding)
            }
        }
        let chargeTap = UITapGestureRecognizer.init(target: self, action: #selector(rechargeButtonDidClick))
        chargeButton.addGestureRecognizer(chargeTap)

        parameterButton = SweeperButton(title: LocalizedString(key: sweeperCleanSweepAndMop), fontSize: 9, image: UIImage.image(named: "mode_general"), offsetToTop: 5)
        addContraint(for: parameterButton, trailingToSuperView: -defaultButtonPadding, bottomToSuperView: nil)
        parameterButton.snp.makeConstraints { (make) in
            make.bottom.equalTo(chargeButton.snp.bottom)
        }

        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        parameterButton.addGestureRecognizer(paramTap)

    }

    func setupOfflineView() {
        let offlineView = SweeperRobotOfflineView(frame: .zero)
        offlineView.delegate = self
        self.view.addSubview(offlineView)

        let goldenRatio: CGFloat = 0.382
        offlineView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2)
        }
        equipmentOfflineView = offlineView
        equipmentOfflineView?.isHidden = true
    }

    func updateNavigation() {
        if firstTimeUpdateNavigationTitle {
            navigationTitleView = SweeperTitleBatteryView(title: deviceDetail?.alias ?? "扫地机器人", stateText: "", power: 0, charge: false)
            navigationTitleView.snp.remakeConstraints { make in
                make.height.equalTo(44)
                make.width.equalTo(screenWidth - 150)
            }
            navigationItem.titleView = navigationTitleView
            firstTimeUpdateNavigationTitle = false
        }

        let stateText = state?.stateDescription ?? "故障中"
        let battery = state?.battery ?? 0
        let isCharging = state?.mainState == .charging
        navigationTitleView.setState(stateText: stateText, power: battery, charge: isCharging)
    }

    func updateEnvironmentView() {
        temperatureView.text = temperatureText
        humidityView.text = humidityText
    }

    func updateChargeButton() {
        chargeButton.isHidden = !shouldShowChargeButton
        if isRecharging {
            chargeButton.setTitle(title: "停止回充", buttonImage: UIImage.image(named: "robot_charge_stop"))
        } else {
            chargeButton.setTitle(title: "返回基站", buttonImage: UIImage.image(named: "robot_charger"))
        }
        if forbiddenRechargeAndClean {
            chargeButton.titleLabel.textColor = .lightGray3Color.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = false
        } else {
            chargeButton.titleLabel.textColor = .black.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = true
        }
    }

    func setupLoadingView() {
        view.addSubview(loadingView)
        loadingView.delegate = self
        loadingView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(0.764)
        }
    }

    func setupMapView() {
        let mapSize = sweeperControl?.mapSize ?? CGSize(width: defaultMapWidth, height: defaultMapHeight)
        mapView = SweeperHomeMapView(frame: .zero, mapSize: mapSize)
        mapView.backgroundColor = UIColor.clear
        view.addSubview(mapView)
        mapView.delegate = self
        mapView.sweeperIconMapView.delegate = self
        mapView.datasource = self
        mapView.isHidden = true

        mapView.snp.makeConstraints { make in
            make.top.trailing.leading.equalToSuperview()
            make.bottom.equalTo(sweepControlView.snp.top)
        }
        setupTapGesture()
    }

    func setupTapGesture() {
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(didTaped(recognizer:)))
        self.mapView.addGestureRecognizer(tapGesture)
    }

    func setupSweeperAlarmView() {
        let sweeperAlarmViewController = SweeperAlarmBannerViewController()
        sweeperAlarmViewController.window(from: .mainPage)
        sweeperAlarmViewController.sweeperControl = self.sweeperControl

        self.addChild(sweeperAlarmViewController)
        view.addSubview(sweeperAlarmViewController.view)
        sweeperAlarmViewController.view.snp.makeConstraints { make in
            make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding / 2)
            make.leading.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }
        self.sweeperAlarmViewController = sweeperAlarmViewController
    }

    @objc func didTaped(recognizer: UITapGestureRecognizer) {
        captureBubbleViewDismiss()
    }

    func setupEnvironmentView() {
        view.addSubview(environmentView)

        environmentView.snp.makeConstraints { make in
            make.height.equalTo(36)
            make.leading.top.equalToSuperview().offset(12)
        }
        environmentView.backgroundColor = .lightGray3Color.withAlphaComponent(0.1964)
        environmentView.layer.cornerRadius = 5

        [temperatureView, humidityView].forEach { label in
            environmentView.addSubview(label)

            label.backgroundColor = .clear
            label.textColor = .black.withAlphaComponent(0.6)
            label.textAlignment = .left
            label.font = .projectFont(ofSize: 10)
            label.snp.makeConstraints { make in
                make.height.equalTo(14)
                make.trailing.equalToSuperview().offset(-8)
                make.leading.equalToSuperview().offset(8)
            }
        }

        temperatureView.snp.makeConstraints { make in
            make.top.equalToSuperview().offset(4)
        }
        temperatureView.text = temperatureText

        humidityView.snp.makeConstraints { make in
            make.top.equalTo(temperatureView.snp.bottom)
        }
        humidityView.text = humidityText
    }

    func setupControlView() {
        addConstraint(forBottomView: sweepControlView, height: nil)
        sweepControlView.isHidden = true
        sweepControlViewHeightConstraint = NSLayoutConstraint(item: sweepControlView,
                                                             attribute: .height,
                                                             relatedBy: .equal,
                                                             toItem: nil,
                                                             attribute: .notAnAttribute,
                                                             multiplier: 1.0,
                                                             constant: 0)
        sweepControlViewHeightConstraint?.isActive = true

        // button clicked
        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        sweepControlView.parameterButton?.addGestureRecognizer(paramTap)

        let clearTap = UITapGestureRecognizer.init(target: self, action: #selector(clearAreaButtonDidClick))
        sweepControlView.clearAreaButton?.addGestureRecognizer(clearTap)

        let startTap = UITapGestureRecognizer.init(target: self, action: #selector(startButtonDidClick))
        sweepControlView.startButton.addGestureRecognizer(startTap)

        let stopTap = UITapGestureRecognizer.init(target: self, action: #selector(stopButtonDidClick))
        sweepControlView.stopButton.addGestureRecognizer(stopTap)

        let pauseTap = UITapGestureRecognizer.init(target: self, action: #selector(pasueButtonDidClick))
        sweepControlView.pauseButton.addGestureRecognizer(pauseTap)

    }

    func setupUpgradingView() {
        view.addSubview(sweeperBaseUpgradingView)
        sweeperBaseUpgradingView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingUpgradingView = false
    }

    func setupMechanicalOffView() {
        view.addSubview(sweeperMechanicalOffView)
        sweeperMechanicalOffView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingMechanicalView = false
        sweeperMechanicalOffView.delegate = self
    }

    func addConstraint(forBottomView bottomView: UIView?, height: CGFloat?) {
        guard let bottomView = bottomView else {
            return
        }
        bottomView.translatesAutoresizingMaskIntoConstraints = false

        view.addSubview(bottomView)

        // UI中设置的阴影radius为12，此处设置为8，才能与UI的效果一致。
        let shadowRadius: CGFloat = 8
        bottomView.layer.shadowOffset = .init(width: 0, height: 2)
        bottomView.layer.shadowRadius = shadowRadius
        bottomView.layer.shadowColor = UIColor.black.cgColor
        bottomView.layer.shadowOpacity = 0.16

        NSLayoutConstraint(item: bottomView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .width,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        if let height = height {
            NSLayoutConstraint(item: bottomView,
                               attribute: .height,
                               relatedBy: .equal,
                               toItem: nil,
                               attribute: .notAnAttribute,
                               multiplier: 1.0,
                               constant: height).isActive = true
        }

        NSLayoutConstraint(item: bottomView,
                           attribute: .bottom,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .bottom,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        NSLayoutConstraint(item: bottomView,
                           attribute: .centerX,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .centerX,
                           multiplier: 1.0,
                           constant: 0).isActive = true
    }

    func addContraint(for subView: UIView?, trailingToSuperView: CGFloat, topToSuperView: CGFloat? = nil, bottomToSuperView: CGFloat? = nil) {
        guard let subView = subView else {
            return
        }

        view.addSubview(subView)
        subView.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint(item: subView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 44).isActive = true
        NSLayoutConstraint(item: subView,
                           attribute: .height,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 47).isActive = true
        if let topToSuperView = topToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .top,
                               relatedBy: .equal,
                               toItem: view,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: topToSuperView).isActive = true
        }

        if let bottomToSuperView = bottomToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .bottom,
                               relatedBy: .equal,
                               toItem: bottomLayoutGuide,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: bottomToSuperView).isActive = true
        }

        NSLayoutConstraint(item: subView,
                           attribute: .trailing,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .trailing,
                           multiplier: 1.0,
                           constant: trailingToSuperView).isActive = true
    }
}

/// receive bitmap data
extension SweeperMainViewController: SweeperMapMediaPlayerListener {
    func mediaPlayerConnected(connectedSuccess: Bool) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if !connectedSuccess {
            dataLoadingStateChangeAction(loadingState: .failed)
        }
    }

    func dataLoadingStateChanged(loadingState: SweeperDataLoadingState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        dataLoadingStateChangeAction(loadingState: loadingState)
    }

    func mediaPlayerBitmapDataUpdate(dataType: MapMediaPlayerFrameFormat) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        /// 对扫地机地图正处于拖动或缩放时地图的刷新进行限制，避免卡顿的情况。
        guard !mapView.isOperation else {
            return
        }
        if dataType == .map {
            // 第一次收到I帧
            if sweeperControl?.hadFrame == true {
                stopWaveAnimation()
            }
            mapView.sweeperBitmapView.refreshBitmapImage()
            mapView.sweeperAreaView.refreshAreaView()
            if needRefreshMapViewInMediaPlayer {
                needRefreshMapViewInMediaPlayer = false
                mapView.refreshView()
            }
        }

        if sweeperControl?.hadFrame == true && dataType == .path {
            mapView.sweeperRouteView.refreshRouteView()
            // refresh equipment icon and charger pile location.
            mapView.sweeperIconMapView.refreshIconView()
        }
    }

    func mediaPlayerSignalling(mapID: String, type: SweeperConfigUpdateType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if type == .cleaningState {
            updateCleaningStateUI()
        } else if type == .cleaningMode || type == .cleanParam {
            updateCleaningModeUI()
        } else if type == .areaCleaning {
            mapView.updateCustomOrAutoMode()
            mapView.refreshAreaAndLabelView()
        } else if type == .globalCleaningConfig {
            // 修改全局清扫配置
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                cleanMethodMode = mode
                configurationView?.collectionView.reloadData()
            }
        } else {
            mapView.refreshView()
            mapView.refreshAreaAndLabelView()
        }
    }

    func mediaPlayerBasicStateDidChanged(preState: SweeperState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        basicStateChangeAction(showToast: true)
        sweeperAlarmViewController?.showAlarm()
        sweeperAlarmViewController?.showNotify()

        // 当前扫地机清扫结束时，若需要进入地图保存逻辑，则重新进入
        if !preState.cleanFinished && state?.cleanFinished == true && needEntrySaveMapLogicAfterBasicStateChanged {
            currentMapDidChanged(preMap: nil)
            saveMapLogic()
            needEntrySaveMapLogicAfterBasicStateChanged = false
        }
    }

    func mediaPlayerMapIDDidChanged(preMap: SweeperMap) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        currentMapDidChanged(preMap: preMap)

        /// 每次修改current map id 后， 地图的大小都会发生变化，故需要刷新初始地图的大小以适应屏幕
        mapView.restoreInitalMapView()
        mapView.shouldRefreshSize = true
        mapView.refreshView()
        mapView.updateCleanningModeAndSweepingState()
        mapView.updateCustomOrAutoMode()
        mapView.refreshAreaAndLabelView()
    }

    func mediaPlayerAlarm(type: SweeperAlarmType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        let alarm = SweeperAlarm(type: type)

        // 当前alarm需要在主页面显示、当基站升级、开关断开时不展示
        guard alarm.window.contains(.mainPage) && sweeperMechanicalOffView.isHidden && sweeperBaseUpgradingView.isHidden else {
            return
        }

        // 展示Toast
        if alarm.rank.contains(.toast),
           let message = alarm.toastTitle {
            ToastView.showWarningToast(title: message, existTime: nil, centerY: .low)
            return
        }

        // 展示Dialog，不展示只在基站展示的dialog
        if alarm.rank.contains(.dialog),
           !SweeperAlarm.baseDialogTypes.contains(type),
           let title = alarm.toastTitle {
            showAlertWith(title: title, message: alarm.toastContent, messageTextAlignment: .center, defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil, cancelButtonHandler: nil, defaultButtonHandler: nil)
            return
        }
    }
}

extension SweeperMainViewController: SweeperMapViewDataSource {
    func area(_ view: UIView, customCleanConfigurationIn areaID: Int) -> SweeperGlobalCleaningConfiguration? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaCleaningConfiguration
    }

    func area(_ view: UIView, infomationLayerMarkIn areaID: Int) -> String? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaLabel
    }

    func areaIDSet(_ in: UIView) -> [Int]? {
        return sweeperControl?.mapModel?.areaModel.areaIDs
    }

    func areaLabelLocation(_ view: UIView, areaID: Int) -> CGPoint? {
        return sweeperControl?.mapModel?.areaModel.areaLabelLocation[areaID]
    }

    func bitmapImage(_ view: UIView) -> CGImage? {
        return sweeperControl?.mapModel?.bitmapImage()
    }

    func bitmapOffset(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.offset
    }

    func bitmapSize(_ view: UIView) -> CGSize? {
        return sweeperControl?.mapModel?.bitmapSize
    }

    func areaData(_ view: UIView) -> [UInt8]? {
        return sweeperControl?.mapModel?.areaModel.areaData
    }

    func routeAllPointArray(_ view: UIView) -> [RoutePoint]? {
        return sweeperControl?.routeModel?.routePoints
    }

    func virtualWallIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.virtualWallModel?.wallIDs
    }

    func virutalWall(_ view: UIView, wallID: Int, isInEditMap: Bool) -> (CGPoint, CGPoint)? {
        return sweeperControl?.virtualWallModel?.couplePiontDictionary[wallID]
    }

    func forbiddenAreaIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.forbiddenAreaModel?.areaIDs
    }

    func forbiddenArea(_ view: UIView, areaID: Int, isInEditMap: Bool) -> RectangleArea? {
        return sweeperControl?.forbiddenAreaModel?.couplePiontDictionary[areaID]
    }

    func equipmentLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.routeModel?.equipmenLocation
    }

    func equipmentAngle(_ view: UIView) -> CGFloat? {
        return sweeperControl?.routeModel?.equipmenOritention
    }

    func chargePileLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.chargePileLocation
    }

    func barrierIDSet(_ view: UIView) -> [Int]? {
        if let keys = sweeperControl?.barriersModel?.barrierDictionary.keys {
            return Array(keys)
        } else {
            return nil
        }
    }

    func barrier(_ view: UIView, barrierModelIn barrierID: Int) -> SweeperBarrier? {
        return sweeperControl?.barriersModel?.barrierDictionary[barrierID]
    }

    func rectClean(_ view: UIView) -> (leftTopPoint: CGPoint, rightBottomPoint: CGPoint)? {
        if cleaningMode.leftTopPoint != .zero && cleaningMode.rightBottomPoint != .zero {
            return (cleaningMode.leftTopPoint, cleaningMode.rightBottomPoint)
        } else {
            return nil
        }
    }

    func mapScale(_ view: UIView) -> CGFloat? {
        return sweeperControl?.capability?.mapScale
    }
}

extension SweeperMainViewController: SweeperHomeMapViewDelegate {
    func hadMapFrame(_ view: SweeperHomeMapView) -> Bool? {
        return sweeperControl?.hadFrame
    }

    func areaSelected(_ view: SweeperHomeMapView) -> [Int]? {
        if cleaningModeType == .areaClean {
            return selectedLayerID
        } else {
            return nil
        }
    }

    func homeMapViewIsSetPreference(_ view: SweeperHomeMapView) -> Bool {
        return isSetPreference()
    }

    func homeMapViewIsSetSeq(_ view: SweeperHomeMapView) -> Bool {
        return isSetSweepSeq()
    }

    func layer(_ view: SweeperHomeMapView, layerSelectedSequence layerID: Int) -> Int? {
        if cleaningModeType == .areaClean, let orderID = selectedLayerID.firstIndex(of: layerID) {
            return orderID
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, layerCleaningOrder layerID: Int) -> Int? {
        if let order = sweeperControl?.mapModel?.areaModel.areaCleaningOrder,
           let orderID = order.firstIndex(of: layerID) {
            return orderID + 1
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, selectedLayer layerID: Int) {
        if let index = selectedLayerID.firstIndex(of: layerID) {
            selectedLayerID.remove(at: index)
        } else {
            selectedLayerID.append(layerID)
        }
        if cleaningModeType == .areaClean && !selectedLayerID.isEmpty {
            ToastView.showWarningToast(title: "已选择(selectedLayerID.count)个区域", existTime: nil, centerY: .low)
        }
        updateClearingAreaButton()
        mapView.refreshAreaAndLabelView()
    }
}

extension SweeperMainViewController {

    // 物体抓拍气泡展示
    private func captureBubbleViewShow(captureView: UIImageView, titleText: String, iconImage: UIImage, status: CaptureImageLoadingStatus, obstacleID: Int, thumbnail: UIImage? = nil) {
        sweepCaptureView.removeFromSuperview()
        captureBubbleViewLayout(captureView: captureView)
        sweepCaptureView.delegate = self

        // 更新障碍物抓拍气泡的展示
        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: thumbnail, obstacleID: obstacleID)

        // 更新障碍物抓拍是否有缩略图以及缩略图状态
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl?.barrierRecognitionEnabled ?? false, captureImageStatus: status)

        self.view.layoutIfNeeded()
        self.autoSuitPosition()
    }

    private func captureBubbleViewLayout(captureView: UIImageView) {
        self.mapView.addSubview(sweepCaptureView)
        sweepCaptureView.snp.remakeConstraints { make in
            make.centerX.equalTo(captureView.snp.centerX)
            make.bottom.equalTo(captureView.snp.top).offset(-12)
            make.width.equalTo(159)
            if sweeperControl?.barrierRecognitionEnabled ?? false {
                make.height.equalTo(128)
            } else {
                make.height.equalTo(40)
            }
        }
    }

    // 物体抓拍气泡隐藏
    private func captureBubbleViewDismiss() {
        sweepCaptureView.dismiss()
    }

    private func autoSuitPosition() {
        var offsetX: CGFloat = 0
        var offsetY: CGFloat = 0
        let maxXCoordinate = mapView.frame.width - sweepCaptureView.frame.width - 16
        if sweepCaptureView.frame.origin.x < 16 {
            offsetX = 16 - sweepCaptureView.frame.origin.x
        } else if sweepCaptureView.frame.origin.x > maxXCoordinate {
            offsetX = maxXCoordinate - sweepCaptureView.frame.origin.x
        }

        if sweepCaptureView.frame.origin.y < 16 {
            offsetY = 16 - sweepCaptureView.frame.origin.y
        }
        // 不用考虑底部超出边界，因为弹窗从顶部出现

        mapView.moveBy(x: offsetX, y: offsetY)
    }

    /// 刷新当前正在展示的气泡及其内容
    private func refreshBubbleView() {
        guard let sweeperControl = sweeperControl,
              let obstacleID = obstacleID,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              let iconImage = barrier.type.bigImage,
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            captureBubbleViewDismiss()
            return
        }
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
            return
        }

        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: .loading)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { [weak self] (status, image) in
            self?.sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: image, obstacleID: obstacleID)
            self?.sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: status)
        }
    }

}

extension SweeperMainViewController: SweeperMapManagerViewControllerDelegate {
    func mapManagerBeginSweep(_ controller: SweeperMapManagerViewController) {
        // 强制扫地机进入新建地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .autoClean)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    func mapManagerFastMap(_ controller: SweeperMapManagerViewController) {
        // 开始快速建图
        startFastMapAlert()
    }
}

extension SweeperMainViewController: SweeperCaptureBubbleViewDelegate {
    func captureNextButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.titleLabel.textColor = UIColor.black.withAlphaComponent(0.5)
        // 获取全部障碍物的详情页
        let sweepCaptureNextPageViewController = SweeperCaptureNextPageViewController(deviceID: deviceID, listType: listType)
        sweepCaptureNextPageViewController.delegate = self

        // 更新详情页跳转到具体哪个页面
        sweepCaptureNextPageViewController.obstacleID = captureView.obstacleID
        self.navigationController?.pushViewController(sweepCaptureNextPageViewController, animated: true)
    }

    func reloadButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.imageStatus = .loading
        let barrierID = captureView.obstacleID
        guard let fileID = sweeperControl?.barriersModel?.barrierDictionary[barrierID]?.fileID else {
            return captureView.imageStatus = .loadNoImage
        }

        SweeperDownloader.downloadObstacleImage(forDevice: deviceID, listType: listType, fileID: fileID) { status, image in
            captureView.imageStatus = status
            captureView.titleImageView.image = image
        }
    }

    func handleGestures(enable: Bool) {
        mapView.isGestureEnable = enable
    }
}

extension SweeperMainViewController: SweeperMainMapLoadingViewDelegate {
    func reloadButtonDidClick(_ UIView: SweeperMainMapLoadingView) {
        refreshMediaPlayerAndSweeperControl()
    }
}

extension SweeperMainViewController: SweeperIconMapViewDelegate {
    func didTapBaseStation(in view: SweeperIconMapView) {
        baseStationButtonDidClick()
    }

    func iconMap(_ view: SweeperIconMapView, transforToScreenPointFrom realPoint: CGPoint) -> CGPoint? {
        // 之前未调用
        return nil
    }

    func didTapObstacle(in view: UIImageView, obstacleID: Int) {

        guard let sweeperControl = sweeperControl,
              let iconImage = sweeperControl.barriersModel?.barrierDictionary[obstacleID]?.type.bigImage,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            return
        }
        self.obstacleID = obstacleID
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loadNoImage, obstacleID: obstacleID)
            return
        }

        self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loading, obstacleID: obstacleID)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { status, image in
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: status, obstacleID: obstacleID, thumbnail: image)
        }
    }
}

extension SweeperMainViewController: SweeperNewPasswordProtocol {
    func checkUnAuthenticated() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperModule.shared.requiredService?.checkUserInfo(deviceID: deviceID, listType: listType, completion: { [weak self] (success, errorCode) in
            ToastView.dismissLoadingToast()
            guard let self = self else {
                return
            }
            if success {
                self.goToPreview()
                return
            }

            if errorCode == TPSS_ASYNC_EC_TIMEOUT || errorCode == TPSS_COMM_EC_SYSTEM {
                /* 请求超时 */
                ToastView.showWarningToast(warningMessage: "网络错误")
                return
            }

            /* 设备锁定 */
            if errorCode == TPSS_COMM_EC_PREVIEW_LOCKED {
                self.showAlertWith(title: SharedResource.sharedString(key: sweeperPreviewLockedAlertTitle), defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil)
                return
            }

            /* 鉴权失败,弹出密码输入框 */
            self.presentInputPasswordVC(deviceID: self.deviceID, listType: self.listType)

        })
    }
}

extension SweeperMainViewController: SweeperVerifyPasswordProtocol {
    func verifySuccessHandler() {
        goToPreview()
    }
}

extension SweeperMainViewController: SweeperCaptureNextPageViewControllerDelegate {
    func ignoreButtonDidClick(sweeperCaptureNextPageViewController: SweeperCaptureNextPageViewController, barrierID: Int) {
        // 点击障碍物抓拍详情页的“忽略”所对应的障碍物Id
        guard let mapID = map?.currentMapID else {
             return
        }
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestIgnoreBarrier(device: deviceID, channel: channel, listType: listType, barrierID: "(barrierID)", mapID: mapID).always {
            ToastView.dismissLoadingToast()
        }.then { [weak self] (_) in
            ToastView.showWarningToast(warningMessage: "已忽略该物体")
            self?.sweepCaptureView.dismiss()
            self?.goBackToSweeperMainViewController()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperMechanicalOffViewDelegate {
    func refreshButtonDidClick(in: SweeperMechanicalOffView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        sweeperMechanicalOffView.refreshLoadingUI(connectedState: .loading)
        view.bringSubviewToFront(sweeperMechanicalOffView)
        SweeperService.getSweeperState(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType).then { [weak self] (state) in
            guard let state = state else {
                return
            }
            self?.showMechanicalOffView(switchOn: state.mechanicalSwitchOn)
        }
    }

    func showMechanicalOffView(switchOn: Bool) {
        // 若开关关闭
        if !switchOn {
            isShowingMechanicalView = true
            sweeperMechanicalOffView.refreshLoadingUI(connectedState: .off)
        } else {
            isShowingMechanicalView = false
        }
    }
}

extension SweeperMainViewController: SweeperMoreActionViewControllerDelegate {
    func cleanWholeHouse(in vc: SweeperMoreActionViewController) {
        showSweepTipsAlert()
    }
}

extension SweeperMainViewController: SweeperFastMapSheetDelegate {
    func startFastMap(view: SweeperFastMapSheet) {
        startFastMapAlert()
    }
}

extension String {
    func separatedBySemiColon(isAutoFill: Bool = true) -> (String, String?) {
        let seperator = self.contains(":") ? ":" : "："
        let separatedTexts: [String] = self.components(separatedBy: seperator)
        if !isAutoFill && separatedTexts.count == 1 {
            return (separatedTexts[0], nil)
        } else {
            return (separatedTexts.count >= 1 ? separatedTexts[0] : "", separatedTexts.count >= 2 ? separatedTexts[1] : "")
        }
    }
}
//
//  OnlineDeviceListMasterViewController.swift
//  SurveillanceHome
//
//  Created by Li Linfeng on 2019/12/9.
//  Copyright © 2019 tplink. All rights reserved.
//

import UIKit
import SurveillanceHomeBase
import SharedResource
import TPFoundation
import DeviceDetailModule
import NetService

private var pageIndexAssociatedObjectHandle: UInt8 = 0

final class OnlineDeviceListMasterViewController: BaseViewController {
    @IBOutlet private weak var groupCollectionView: UICollectionView!
    @IBOutlet private weak var groupToolbarShadowView: UIView!
    @IBOutlet private weak var groupToolbarContainer: UIView!
    @IBOutlet private weak var groupToolbarDropMenuButton: UIButton!
    @IBOutlet private weak var recentPreviewView: RecentPreviewView!
    @IBOutlet private weak var containerViewBottom2SuperViewBottomConstraint: NSLayoutConstraint!
    @IBOutlet private weak var containerViewTop2TopLayoutGuideBottomConstraint: NSLayoutConstraint!

    override var navigationBarTraits: [NavigationBarTrait] {
        return NavigationBarTrait.noSeparator
    }

    private var deviceGroups: [TPSSDeviceGroup] = []
    private var currentGroupIndex: Int = 0

    private var newCreateGroupName = ""

    private var pageController: UIPageViewController!
    private var deviceListVCCacheDictionary = [TPSSDeviceGroupID: OnlineDeviceListViewController]()
    private var transitionVCForPageController = UIViewController()
    lazy private var loginCacheVC = DeviceListLoginViewController.create()

    private var firstAppear = true
    private var shouldRecreate: Bool = false

    /// for routers' entry
    private var isLoginBefore = false

    var sdCardStatusShowed: SDCardStatusShowed = .none
    var diskStatusShowed: SDCardStatusShowed = .none

    // camera display
    private var shouldShowCameraDisplayNoActiveChannelAlert = false
    private var addChannelCameraDisplay: TPSSDeviceForDeviceList?

    // navigation
    private lazy var moreToolBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(moreToolsButtonClicked(_:)))
    }()

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_add_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(addDeviceButtonClicked(_:)))
    }()

    // MARK: guides and overlays
    private weak var addDeviceGuideView: GuidePresentationView?
    private weak var moreToolsPopoverView: GuidePresentationView?

    private lazy var groupPresenter = GroupListPresentationManager()
    private var presentedGroupList: GroupListViewController? {
        return presentedViewController as? GroupListViewController
    }

    private var currentList: OnlineDeviceListViewController {
        if let viewControllers = pageController.viewControllers, let firstViewController = viewControllers.first as? OnlineDeviceListViewController {
            return firstViewController
        }
        return OnlineDeviceListViewController()
    }

    private var isCloudLogin: Bool {
        return DeviceListModule.shared.requiredService?.isCloudLogin ?? false
    }

    private var isReordering = false                // 是否正在处于排序模式
    private var shouldToggleGroupModeAfterGetList = false   // 是否需要在获取列表结束后切换防护模式，仅在列表还未获取完时触发防护模式切换使用

    private var isShowing: Bool {
        return isShowing(ignorePresentedClasses: [UIAlertController.classForCoder()])
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        setupView()

        NotificationCenter.default.addObserver(self, selector: #selector(handleShowCameraDisplayNoActiveChannelAlertNotification(_:)), name: .ShowCameraDisplayNoActiveChannelAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleShowStorageDetectAlertNotification(_:)), name: .ShowStorageDetectAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListInvalidated), name: .DeviceListInvalidated, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListUpdated), name: .DeviceListUpdated, object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderBegined(_:)),
                                               name: .DeviceListReorderBegined,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderEnded(_:)),
                                               name: .DeviceListReorderEnded,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupAndDeviceList(_:)),
                                               name: .UpdateGroupAndDeviceListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: DeviceListNetworkObserver.localDeviceRefreshed,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupList(_:)),
                                               name: .UpdateGroupListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: .unbindDiscoveryFinished,
                                               object: nil)

        _ = DeviceListModule.shared.requiredService?.addEntrustObserver(observeTypes: [.entrustmentStop, .entrustmentExitByTrustee], { (_, _) in
            DeviceListManager.shared.updateDeviceList(of: DeviceListManager.shared.defaultGroupID).always {
                self.currentList.reload()
            }
        })
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        showGroupAndNavigationButton(true)
        if !isCloudLogin {
            showEmpty()
        } else if firstAppear {
            firstAppear = false
            restore()
        } else if shouldRecreate {
            shouldRecreate = false
            reload()
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        checkUpdateIfNeeded()

        if isCloudLogin {
            showPopoverGuideIfNeeded()
        }

        if shouldShowCameraDisplayNoActiveChannelAlert {
            shouldShowCameraDisplayNoActiveChannelAlert = false
            showCameraDisplayNoActiveChannelAlert()
        }
        updateGroupShadow()
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)

        dismissPresentedViews()
    }

    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let vc = segue.destination as? UIPageViewController {
            pageController = vc
            pageController.dataSource = self
            pageController.delegate = self
        }
    }

    private func refreshAfterGroupUpdated() {
        guard !isReordering else {
            return
        }

        guard isShowing else {
            // 如果分组刷新完，此时页面不是正在显示，则不进行页面刷新，仅记录状态，等回到本页面才统一进行刷新。
            // 需要注意通过记录状态后续回到页面才处理的逻辑，要与本方法后续处理逻辑要保持一致
            shouldRecreate = true
            return
        }

        reload()
    }

    private func showEmpty() {
        deviceGroups = []
        currentGroupIndex = -1

        showGroupAndNavigationButton(false)

        let emptyVC: UIViewController?
        // 有发现出来的/已绑定到局域网的设备时显示带登陆按钮的设备列表；没有则显示普通的登陆提示页
        if DeviceListManager.shared.unbindDetailDeviceList().count > 0 {
            emptyVC = createUnloginPage()
        } else {
            emptyVC = loginCacheVC
        }
        if let emptyVC = emptyVC {
            pageController.setViewControllers([emptyVC], direction: .forward, animated: false, completion: nil)
        }
        groupCollectionView.reloadData()
    }

    private func showGroupAndNavigationButton(_ shouldShow: Bool) {
        if shouldShow {
            navigationItem.leftBarButtonItem = moreToolBarButtonItem
            groupToolbarDropMenuButton.isHidden = false
        } else {
            navigationItem.leftBarButtonItem = nil
            groupToolbarDropMenuButton.isHidden = true
        }
    }

    private func restore() {
        deviceGroups = DeviceListManager.shared.groupList

        loadGroup(with: DeviceListManager.shared.lastSelectedGroupID)
    }

    private func reload(with preferredGroupID: String? = nil) {
        let oldGroupID = preferredGroupID ?? DeviceListManager.shared.lastSelectedGroupID
        deviceGroups = DeviceListManager.shared.groupList
        presentedGroupList?.groups = deviceGroups

        loadGroup(with: oldGroupID)
    }

    private func loadGroup(with groupID: String) {
        let currentGroup = DeviceListManager.shared.group(of: groupID) ?? DeviceListManager.shared.defaultGroup

        guard let groupIndex = deviceGroups.firstIndex(where: { $0.groupID == currentGroup.groupID }) else {
            return
        }

        currentGroupIndex = groupIndex

        presentedGroupList?.currentGroupID = currentGroup.groupID
        presentedGroupList?.reload()

        commonLoad()
    }

    private func commonLoad(animated: Bool = false, recreate: Bool = true) {
        groupCollectionView.reloadData()

        guard currentGroupIndex >= 0 else {
            return
        }

        groupCollectionView.scrollToItem(at: IndexPath(item: currentGroupIndex, section: 0), at: .right, animated: false)
        updateGroupShadow()

        if recreate, let vc = createPage(for: currentGroupIndex) {
            pageController.setViewControllers([vc], direction: .forward, animated: false, completion: nil)
        }

        storeGroupParameter()
    }

    private func updateGroupShadow() {
        groupToolbarShadowView.isHidden = groupCollectionView.bounds.maxX >= (groupCollectionView.contentSize.width - 1)
    }

    private func refreshAllDeviceLists() {
        if let viewController = pageController.viewControllers {
            viewController.forEach {
                if let vc = $0 as? OnlineDeviceListViewController {
                    vc.reload()
                }
            }
        }
    }

    private func createPage(for index: Int) -> OnlineDeviceListViewController? {
        let group = deviceGroups[index]
        guard let vc = createPage(for: group.groupID as TPSSDeviceGroupID) else {
            return nil
        }
        objc_setAssociatedObject(vc, &pageIndexAssociatedObjectHandle, index, .OBJC_ASSOCIATION_COPY_NONATOMIC)
        vc.realGroup = deviceGroups[index]
        return vc
    }

    private func createUnloginPage() -> OnlineDeviceListViewController? {
        return createPage(for: "unlogin page")
    }

    private func createPage(for key: TPSSDeviceGroupID) -> OnlineDeviceListViewController? {
        let vc: OnlineDeviceListViewController?
        if let item = deviceListVCCacheDictionary[key] {
            vc = item
        } else {
            vc = OnlineDeviceListViewController.create()
            deviceListVCCacheDictionary[key] = vc
        }
        return vc
    }
}

extension OnlineDeviceListMasterViewController: DeviceListUnwindDestination {}

// MARK: Popover handler
extension OnlineDeviceListMasterViewController {
    private func updateMenu() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let networkAvailable = NetworkManager.shared.isConnected
        let isInHomeMode = deviceGroups[currentGroupIndex].activeMode != .goOut
        let isBigCardMode = deviceGroups[currentGroupIndex].displayMode != .smallCard
        let homeModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_home_active") : DeviceListModule.image(named: "devicelist_home_disabled")
        let outModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_out_active") : DeviceListModule.image(named: "devicelist_out_disabled")
        DeviceGroupMenuItem.alarmMode.image = (isInHomeMode ? homeModeImage : outModeImage)?.withRenderingMode(.alwaysOriginal)
        DeviceGroupMenuItem.alarmMode.enabled = networkAvailable
        DeviceGroupMenuItem.alarmMode.title = isInHomeMode ? LocalizedString(key: deviceListModeHome) : LocalizedString(key: deviceListModeOut)
        DeviceGroupMenuItem.alarmMode.subtitle = isInHomeMode ? LocalizedString(key: deviceListSwitchModeToOut) : LocalizedString(key: deviceListSwitchModeToHome)
        DeviceGroupMenuItem.viewMode.title = isBigCardMode ? LocalizedString(key: deviceListViewGrid) : LocalizedString(key: deviceListViewList)
        DeviceGroupMenuItem.viewMode.subtitle = isBigCardMode ? LocalizedString(key: deviceListSwitchViewToList) : LocalizedString(key: deviceListSwitchViewToGrid)
        DeviceGroupMenuItem.viewMode.image = isBigCardMode ?  DeviceListModule.image(named: "devicelist_grid")?.withRenderingMode(.alwaysOriginal) : DeviceListModule.image(named: "devicelist_list")?.withRenderingMode(.alwaysOriginal)
    }

    private func handleDeviceGroupMenu(item: DeviceGroupMenuView.Item) {
        switch item {
        case .alarmMode:
            toggleGroupMode()
        case .search:
            navigateToSearch()
        case .viewMode:
            toggleDisplayMode()
        }
    }

    private func toggleGroupMode() {
        dismissPresentedViews()

        let deviceListUpdateStatus = DeviceListManager.shared.deviceListUpdateStatus
        if !deviceListUpdateStatus.cloudUpdateNecessaryInfoFinished {
            // 列表必要信息没获取到，此时若需要改变防护模式，就先请求获取数据并且loading，等所有信息获取完处理，避免数据不完整导致处理出错
            if !deviceListUpdateStatus.isUpdatingList {
                DeviceListManager.shared.updateGroupAndDeviceList()
            }
            shouldToggleGroupModeAfterGetList = true
            ToastView.showLoadingToast(cirleWithMessage: nil)
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.activeMode
        let newMode = group.activeMode == .goOut ? TPSSDeviceGroupMode.atHome : .goOut
        group.activeMode = newMode
        ToastView.showLoadingToast(cirleWithMessage: nil)
        DeviceListManager.shared.changeActiveMode(with: deviceGroups[currentGroupIndex]).then { () in
            self.currentList.reload()
            self.currentList.showToastForActiveMode(newMode)
        }.catch { (_) in
            group.activeMode = originalMode
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func toggleDisplayMode() {
        dismissPresentedViews()

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.displayMode
        let newMode = originalMode == .bigCard ? DeviceUIDisplayType.smallCard : .bigCard

        DeviceListManager.shared.changeDisplayMode(for: group.groupID, with: newMode)

        for section in 0..<currentList.collectionView.numberOfSections {
            for item in 0..<currentList.collectionView.numberOfItems(inSection: section) {
                if newMode == .smallCard {
                    currentList.fold(at: IndexPath(row: item, section: section))
                } else {
                    currentList.unfold(at: IndexPath(row: item, section: section))
                }
            }
        }

        currentList.reload()
    }

    private func navigateToSearch() {
        dismissPresentedViews()
        let allDevices = DeviceListManager.shared.allDetailDevices
        let allGroups = DeviceListManager.shared.groupList
        let vc = RemoteDeviceListSearchViewController(devices: allDevices, groups: allGroups)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }
}

extension OnlineDeviceListMasterViewController {
    // MARK: Popover
    private func showPopoverGuideIfNeeded() {
        // add device popover
        if UserDefaults.standard.object(forKey: deviceListLaunchKey) == nil {
            showAddDevicePopover()
            UserDefaults.standard.set(true, forKey: deviceListLaunchKey)
        }
    }

    private func showAddDevicePopover() {
        if !isShowing() {
            /* 如果界面切换了不要加载 */
            return
        }
        if let source = (navigationItem.rightBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            navigationController?.navigationBar.layoutIfNeeded()
            dismissPresentedViews()
            addDeviceGuideView = presentGuideWith(viewToPresent: TutorialGuideView.addDevice, size: TutorialGuideView.addDevice.frame.size, source: source, clickThrough: true)
            addDeviceGuideView?.delegate = self
        }
    }
}

extension OnlineDeviceListMasterViewController: GuidePresentationViewDelegate {
    func guidePresentationViewDidDismiss(_ view: GuidePresentationView) {
        if view == moreToolsPopoverView {
            navigationItem.leftBarButtonItem?.tintColor = UIColor(white: 0, alpha: 0.8)
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        }
    }
}

// MARK: - util
extension OnlineDeviceListMasterViewController {
    private func storeGroupParameter() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        DeviceListManager.shared.updateLastSelectGroupID(deviceGroups[currentGroupIndex].groupID)
    }
}

extension OnlineDeviceListMasterViewController {

    private func presentUpgradeInfo(appVersionInfo: AppUpgradeModuleBaseUpgradeInfo) {
        let alertViewController = DeviceListUpgradeAlertController(versionInfo: appVersionInfo)
        present(alertViewController, animated: true, completion: nil)
    }

    private func checkUpdateIfNeeded() {
        let requiredService = DeviceListModule.shared.requiredService
        guard requiredService?.shouldShowNewAppVersion() ?? false else {
            return
        }

        // 仅跳转至需要更新的包中（若对应版本的升级包needNotify为false，而另外版本的needNotify为true，会跳转至另一版本）
        if TPAppUtils.isTestFlightBeta() {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, appVersionInfo.needNotify, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        } else {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo, appVersionInfo.needNotify {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        }

    }
}

extension OnlineDeviceListMasterViewController: DeviceListSearchViewControllerDelegate {
    func navigateToGroup(group: TPSSDeviceGroup) {
        navigationController?.popViewController(animated: true)
        DispatchQueue.main.async {
            self.loadGroup(with: group.groupID)
        }
    }

    func navigateToSyncPreviewViewController(device: DeviceDetail) {
        goToSyncPreview(ipc: device, listType: device.listType)
    }

    func navigateToPreviewViewController(device: DeviceDetail, channel: TPSSChannelInfo?) {
        if device.deviceType == .smartLock {
            DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
            return
        }
        goToPreview(device: device, channel: channel)
    }

    func navigateToBatteryDoorbellViewController(device: DeviceDetail, fromNVR nvr: (deviceID: TPSSDeviceIdentifier, channel: UInt)?) {
        DeviceListModule.shared.requiredService?.navigateToBatteryDoorbellViewController(for: device.identifier, group: DeviceListManager.shared.defaultGroupID, listType: device.listType, navigator: navigationController, from: nvr?.deviceID, channelInNVR: nvr?.channel.intValue)
    }

    func navigateToNVRViewController(nvr: DeviceDetail) {
        var groupId = DeviceListManager.shared.defaultGroup.groupID
        if currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex {
            groupId  = deviceGroups[currentGroupIndex].groupID
        }
        goToNVR(nvr: nvr, groupID: groupId)
    }

    func navigateToSolarControllerManagerViewController(device: DeviceDetail) {
        goToSolarController(solarController: device)
    }

    func navigateToRouterManagerViewController(device: DeviceDetail) {
        goToRouter(device: device)
    }

    func navigateToSmartLockViewController(device: DeviceDetail) {
        DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
    }
}

// MARK: Navigation
extension OnlineDeviceListMasterViewController: PreviewControllerEntrance {
    func goToPreview(device: DeviceDetail, channel: TPSSChannelInfo?) {
        goToPreview(deviceID: device.identifier, channelID: channel?.channelId.intValue ?? -1, listType: device.listType)
    }

    func goToNVR(nvr: DeviceDetail, groupID: String? = nil) {
        let vc = NVRTabViewController()
        vc.cloudIdentifier = nvr.cloudDeviceID
        vc.deviceIdentifier = nvr.identifier
        vc.listType = nvr.listType
        vc.groupId = groupID
        navigationController?.pushViewController(vc, animated: true)
    }

    func goToSolarController(solarController: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToSolarControllerManagerViewController(deviceID: solarController.identifier, listType: solarController.listType, navigator: navigationController)
    }

    func goToRouter(device: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToRouterDefault(mac: device.mac, listType: device.listType, isOnline: device.online, navigator: navigationController)
    }
}

// MARK: Actions
extension OnlineDeviceListMasterViewController {
    private func dismissPresentedViews() {
        addDeviceGuideView?.dismiss()
        moreToolsPopoverView?.dismiss()

        presentedGroupList?.dismiss(animated: true, completion: nil)

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }

    @IBAction private func addDeviceButtonClicked(_ sender: Any) {
        guard isCloudLogin else {
            showAlertWith(title: LocalizedString(key: deviceListNotLogin), defaultButtonTitle: LocalizedString(key: deviceListLogin), defaultButtonHandler: { (_) in
                DeviceListModule.shared.requiredService?.navigateToLoginViewController(navigator: self.navigationController)
            })
            return
        }
        dismissPresentedViews()

        DeviceListModule.shared.requiredService?.presentDeviceAddViewController(viewController: self, listType: listType)
    }

    @IBAction private func moreToolsButtonClicked(_ sender: Any) {
        guard isCloudLogin else { return }

        if moreToolsPopoverView != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let size = CGSize(width: 212, height: 16 + DeviceGroupMenuView.Item.allCases.count * 44)
        let menuView = DeviceGroupMenuView(frame: CGRect(origin: .zero, size: size))
        menuView.action = handleDeviceGroupMenu

        dismissPresentedViews()

        updateMenu()

        if let source = (navigationItem.leftBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
            menuView.configurePopoverShadow(cornerRadius: 8)
            moreToolsPopoverView = presentGuideWith(viewToPresent: menuView, size: size, backgroundColor: .clear, source: source, offset: CGPoint(x: -12, y: 4))
            moreToolsPopoverView?.delegate = self
        }
        navigationItem.leftBarButtonItem?.tintColor = .theme1
    }

    @IBAction private func groupMenuToggled(_ sender: UIButton) {
        guard isCloudLogin else { return }

        if presentedViewController != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_up_small_normal"), for: .normal)

        let groups = DeviceListManager.shared.groupList
        guard let vc = GroupListViewController.create() else {
            return
        }
        let height = CGFloat(groups.count) * 52 + 72
        vc.preferredContentSize = CGSize(width: UIScreen.main.bounds.width, height: height)
        vc.modalPresentationStyle = .custom
        vc.transitioningDelegate = groupPresenter
        vc.groups = groups
        vc.currentGroupID = deviceGroups[currentGroupIndex].groupID
        vc.delegate = self
        present(vc, animated: true, completion: nil)
    }

    @IBAction private func recentPreviewClicked(_ sender: Any) {
        // 不会用到此按钮，但暂时保留
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDataSource {
    private func groupInformation(at index: Int) -> (String, Bool) {
        if deviceGroups.isEmpty { return (LocalizedString(key: deviceListMyDevice), true) }
        return (deviceGroups[index].groupName, index == currentGroupIndex)
    }

    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }

    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return max(1, deviceGroups.count)
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        return collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)
    }
}

extension OnlineDeviceListMasterViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        updateGroupShadow()
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDelegate {
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        if deviceGroups.isEmpty { return }
        dismissPresentedViews()
        loadGroup(with: deviceGroups[indexPath.item].groupID)
    }
}

extension OnlineDeviceListMasterViewController: DeviceGroupNameLayoutDelegate {
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, groupForItemAt indexPath: IndexPath) -> (name: String, selected: Bool) {
        return groupInformation(at: indexPath.item)
    }
}

// MARK: Page Management
extension OnlineDeviceListMasterViewController: UIPageViewControllerDataSource {
    func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex > 0 && currentGroupIndex < deviceGroups.count else { return nil }
        return createPage(for: currentGroupIndex - 1)
    }

    func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex >= 0 && currentGroupIndex < deviceGroups.count - 1 else { return nil }
        return createPage(for: currentGroupIndex + 1)
    }
}

extension OnlineDeviceListMasterViewController: UIPageViewControllerDelegate {
    func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
        if completed {
            if let viewControllers = pageViewController.viewControllers, let firtViewController = viewControllers.first {
                if let currentGroupIndex = objc_getAssociatedObject(firtViewController, &pageIndexAssociatedObjectHandle) as? Int {
                    self.currentGroupIndex = currentGroupIndex
                    commonLoad(animated: true, recreate: false)
                }
            }
        }
    }
}

// MARK: Group Management
extension OnlineDeviceListMasterViewController: GroupListViewControllerDelegate {
    func groupListViewController(_ groupListViewController: GroupListViewController, canMoveGroupTo destinationIndex: Int) -> Bool {
        guard deviceGroups.count > destinationIndex else {
            return false
        }
        let group = deviceGroups[destinationIndex]
        return !group.isDefaultGroup
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didMoveGroupAt sourceIndex: Int, to destinationIndex: Int) {
        // check if current group index has changed
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let originalGroup = deviceGroups[currentGroupIndex]
        deviceGroups.swapAt(sourceIndex, destinationIndex)
        if let newIndex = deviceGroups.firstIndex(of: originalGroup), currentGroupIndex != newIndex {
            currentGroupIndex = newIndex
        }
        // always invalidate page controller cache
        pageController.setViewControllers([currentList], direction: .forward, animated: false, completion: nil)
        groupCollectionView.moveItem(at: IndexPath(item: sourceIndex, section: 0), to: IndexPath(item: destinationIndex, section: 0))
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didSelectGroupAt index: Int) {
        dismissPresentedViews()
        loadGroup(with: deviceGroups[index].groupID)
    }

    func groupListViewControllerDidSelectCreatingNewGroup(_ groupListViewController: GroupListViewController) {
        dismissPresentedViews()
        guard let vc = CommonNameInputViewController.create() else {
            return
        }
        vc.navigationTitle = LocalizedString(key: deviceListSetGroupNameTitle)
        vc.doneButtonTitle = LocalizedString(key: commonNextStep)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didRequestEditingGroupAt index: Int) {
        dismissPresentedViews()
        guard let vc = GroupSettingViewController.create() else {
            return
        }
        vc.group = deviceGroups[index]
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewControllerDidDismiss(_ groupListViewController: GroupListViewController) {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
        _ = DeviceListManager.shared.updateGroupOrder(newGroup: deviceGroups)
    }
}

extension OnlineDeviceListMasterViewController: CommonNameInputViewControllerDelegate {
    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didCancelWith text: String) {
        navigationController?.popViewController(animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didFinishWith text: String) {
        guard deviceGroups.count > 0 else {
            navigationController?.popToViewController(self, animated: true)
            return
        }
        newCreateGroupName = text
        let vc = DeviceSelectionViewController(entry: .groupAddIndependent, group: DeviceListManager.shared.defaultGroupID, canProceedWithNoSelection: true)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, errorMessageFor text: String) -> (allowed: Bool, message: String?) {
        let error = TPSSDeviceListValidate.validateDeviceGroupName(text)
        if error != nil {
            return (true, error?.message)
        }

        if DeviceListManager.shared.groupList.contains(where: { $0.groupName == text }) {
            return (true, LocalizedString(key: deviceListNameExists))
        }
        return (true, nil)
    }

    func placeholderForNameInputViewController(_ nameInputViewController: CommonNameInputViewController) -> String? {
        return SharedResource.sharedString(key: shareStringLengthConstraint)
    }
}

extension OnlineDeviceListMasterViewController {
    @objc func handleShowCameraDisplayNoActiveChannelAlertNotification(_ noti: NSNotification) {
        if let (device, listType) = noti.object as? (DeviceDetail, TPSSDeviceListType), listType == .remote {
            shouldShowCameraDisplayNoActiveChannelAlert = true
            addChannelCameraDisplay = DeviceListManager.shared.device(with: device.identifier)
        }
    }

    @objc func handleShowStorageDetectAlertNotification(_ noti: NSNotification) {
        diskStatusShowed = .none
        sdCardStatusShowed = .none
    }

    private func showCameraDisplayNoActiveChannelAlert() {
        showAlertWith(title: LocalizedString(key: deviceAddCameraDisplayNoActiveChannelsTitle), defaultButtonTitle: LocalizedString(key: deviceAddAddNext), cancelButtonTitle: LocalizedString(key: commonNotNow), cancelButtonHandler: nil) { (_) in
            if let cameraDisplay = self.addChannelCameraDisplay {
                DeviceListModule.shared.requiredService?.navigateToCameraDisplayDiscoverViewController(deviceID: cameraDisplay.identifier, discoverType: .cameraDisplay, listType: self.listType, navigator: self.navigationController)
                // 需要在中间插一个ViewController
                let vc = NVRTabViewController()
                vc.cloudIdentifier = cameraDisplay.cloudDeviceId
                vc.deviceIdentifier = cameraDisplay.identifier
                vc.listType = .remote
                vc.hidesBottomBarWhenPushed = true
                if var tmpViewControllers = self.tpNavigationController?.viewControllers {
                    tmpViewControllers.insert(vc, at: tmpViewControllers.count - 1)
                    self.tpNavigationController?.setViewControllers(tmpViewControllers, animated: true)
                }
            }
        }
    }
}

extension OnlineDeviceListMasterViewController: DeviceSDCardStatusChecker {
    var listType: TPSSDeviceListType { return .remote }

    func formatProcessDidFinish() {
        currentList.reload()
    }
}

extension OnlineDeviceListMasterViewController: DeviceSelectionViewControllerDelegate {
    func deviceSelectionViewController(_ deviceSelectionViewController: DeviceSelectionViewController, didPressRightBarButtonItemWithDeviceChannels selectedDeviceChannels: [DeviceDetail: [ChannelId]]) {
        switch deviceSelectionViewController.entryType {
        case .groupAddIndependent:
            ToastView.showLoadingToast(cirleWithMessage: nil)

            let targetDeviceChannels = DeviceSelectionViewController.covertDeviceChannel(selectedDeviceChannels)
            DeviceListManager.shared.createGroup(name: newCreateGroupName, deviceChannelMap: targetDeviceChannels).always {
                ToastView.dismissLoadingToast()
            }.then { (groupID) in
                self.navigationController?.popToViewController(self, animated: true)
                self.reload(with: groupID)
            }.catch { (error) in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }
        default:
            break
        }
    }
}

// MARK: - notification
extension OnlineDeviceListMasterViewController {
    @objc private func handleDeviceListInvalidated() {
        shouldRecreate = true
        deviceListVCCacheDictionary.removeAll()
    }

    @objc private func handleDeviceListUpdated() {
        showUpdateAlertIfAny()
    }

    @objc private func handleReorderBegined(_ notification: Notification) {
        enterReorderMode()
    }

    @objc private func handleReorderEnded(_ notification: Notification) {
        exitReorderMode()
    }

    @objc private func handleUpdateGroupAndDeviceList(_ notification: Notification) {
        if isCloudLogin {
            handleGroupModeToggleAfterGetList(notification)
        } else if isShowing {
            // 处理非登录场景

            // 仅页面正在显示才处理数据获取结果更新页面状态，否则等viewWillAppear再处理。避免正在获取列表
            // 时切换到其它页面，列表获取有结果后触发本逻辑使得子VC触发viewWillAppear，后续真正展示页面时
            // 就不再触发viewWillAppear导致数据异常
            showEmpty()
        }
    }

    @objc private func handleLocalDeviceRefreshed(_ notification: Notification) {
        if !isCloudLogin && isShowing {
            // 非登录且页面正在显示时才需要处理因网络状态变化重新发现完的通知，因为此时可能需要在有/无设备的页面之间切换。
            // 如果页面没有在显示则不需要处理，因为viewWillAppear会触发该逻辑
            showEmpty()
        }
    }

    @objc private func handleUpdateGroupList(_ notification: Notification) {
        if let dic = notification.object as? [String: Any],
           let error = dic[DeviceListManager.notificationKeyError] as? Error {
            ToastView.showWarningToast(title: error.localizedDescription, existTime: nil, centerY: .lowest)
            return
        }
        // 失败也更新，此时显示默认分组
        refreshAfterGroupUpdated()
    }

    private func handleGroupModeToggleAfterGetList(_ notification: Notification) {
        let finishHandler: (() -> Void) = {
            if self.shouldToggleGroupModeAfterGetList {
                ToastView.dismissLoadingToast()
                self.shouldToggleGroupModeAfterGetList = false
                self.toggleGroupMode()
            }
        }

        guard let dic = notification.object as? [String: Any],
              let status = dic[DeviceListManager.notificationKeyListUpdateStatus] as? DeviceListUpdateStatus else {
            finishHandler()
            return
        }

        if status.cloudUpdateNecessaryInfoFinished {
            finishHandler()
        }
    }
}

extension OnlineDeviceListMasterViewController: Storyboarded {
    static var storyboardName: String { return "DeviceList" }
    static var storyboardBundle: Bundle? { return Bundle.deviceListModuelBundle }
}

extension Notification.Name {
    static var DeviceListUpdated: Notification.Name { return Notification.Name("DeviceListUpdated") }
}

// MARK: - setup
extension OnlineDeviceListMasterViewController {
    private func setupView() {
        setupBarButtonItems()
        setupButtons()
    }

    private func setupBarButtonItems() {
        navigationItem.leftBarButtonItem = moreToolBarButtonItem
        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
    }

    private func setupButtons() {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }
}

// MARK: - reorder
extension OnlineDeviceListMasterViewController {
    // 本vc不会主动进入排序模式，而是依赖于OnlineDeviceListViewController的通知
    private func enterReorderMode() {
        isReordering = true
        tabBarController?.tabBar.isUserInteractionEnabled = false
        groupToolbarContainer.isUserInteractionEnabled = false

        pageController.scrollEnable = false

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
    }

    private func showUpdateAlertIfAny() {
        if DeviceListManager.shared.allDetailDevices.contains(where: {(DeviceListModule.shared.requiredService?.onboardingTypeFromQRCode(qrCode: $0.qrCode) ?? 0) == TPSS_EC_GENERAL} ) || DeviceListManager.shared.hasUnsupportedDevice {
            // 二维码获取不支持的设备或者读取设备列表中有不支持的设备时，弹出升级提示
            let lastVersion: (isShow: Bool, versionCode: Int) = DeviceListModule.shared.requiredService?.checkShowUpdateAlert() ?? (false, 0)
            if lastVersion.isShow {
                showAlertWith(title: LocalizedString(key: commonNoticeUpdateAPP), message: nil, messageTextAlignment: nil,
                              defaultButtonTitle: LocalizedString(key: commonUpdateNow), defaultButtonColor: .theme1,
                              cancelButtonTitle: LocalizedString(key: commonIgnoreNotice), cancelButtonColor: .black.withAlphaComponent(0.8),
                              cancelButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.updateUserNoMoreNotify(version: lastVersion.versionCode)
                    self.showDiskAlertIfAny()
                }, defaultButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.jumpAndCheckAppVersion()
                    self.showDiskAlertIfAny()
                })
            } else {
                showDiskAlertIfAny()
            }
        } else {
            showDiskAlertIfAny()
        }
    }

    private func exitReorderMode() {
        tabBarController?.tabBar.isUserInteractionEnabled = true
        groupToolbarContainer.isUserInteractionEnabled = true

        pageController.scrollEnable = true

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }

        isReordering = false
    }
}
//
//  SweeperMainViewController.swift
//  Pods
//
//  Created by 爱迪生 on 2021/8/2.
//

import UIKit
import SurveillanceHomeBase
import Promises
import SwiftyJSON
import SharedResource
import TPFoundation
import SimplePlayer
import DeviceDetailModule
import SnapKit
import NetService
import ThemeTool

enum CaptureImageLoadingStatus: Equatable {
    case loadSuccess
    case failure
    case loading
    case loadNoImage
    case model(SweeperBarrierType)
}

enum MainMapLoadingState {
    case loading
    case failure
    case noMap
    case hasMap
}

class SweeperMainViewController: SweeperGlobalConfigurationViewController {
    var needShowFastMapGuide: Bool = false
    // MARK: subviews
    private var previewButton: SweeperButton?
    weak var inputPasswordVC: UIViewController?
    var inputPassword: String?
    private var editButton: SweeperButton?
    private var baseStationButton: SweeperButton?
    private var moreButton: SweeperButton?
    private var parameterButton = SweeperButton()
    private var navigationTitleView = SweeperTitleBatteryView()
    private var chargeButton = SweeperButton()
    private var createMapContainer: SweeperCreateMapView?
    private var sweepAreaPopView: SweeperClearAreaPopView?
    private var sweeperAlarmViewController: (UIViewController & SweeperAlarmWindowSuitable)?
    private var startCleanAnimationView: SweeperStartCleanAnimationView?
    private var mapView = SweeperHomeMapView(frame: .zero, mapSize: .init(width: 1200, height: 1200))
    private var loadingView = SweeperMainMapLoadingView(frame: .zero)
    private var buttonContainerStackView = UIStackView()
    private var environmentView = UIView(frame: .zero)
    private var temperatureView = UILabel(frame: .zero)
    private var humidityView = UILabel(frame: .zero)
    private var equipmentOfflineView: SweeperRobotOfflineView?

    private var sweepControlView = SweeperControlView()
    private var sweepCaptureView = SweeperCaptureBubbleView()
    private var sweeperBaseUpgradingView = SweeperBaseStationUpgradingView()
    private var sweeperMechanicalOffView = SweeperMechanicalOffView()

    private var sweepControlViewHeightConstraint: NSLayoutConstraint?
    private var heightForControlView: CGFloat {
        switch status {
        case .stop:
            return 88 + bottomSafeAreaInset
        case .fastMap, .fastMapPause:
            return 69 + bottomSafeAreaInset
        case .sweepingPause, .sweeping:
            return 143 + bottomSafeAreaInset
        }
    }

    enum AlarmButtonClickMode {
        case exit
        case more
        case none
    }
    private var alarmButtonClickMode: AlarmButtonClickMode = .exit

    // 快速建图引导view
    private var fastMapImageView: UIImageView?
    private var fastMapGuideView: GuidePresentationView?


    // 地图已自动保存通知
    private var savedMapNoticeView: UIImageView?
    private var saveMapGuideView: GuidePresentationView?
    // 存储设备详细信息
    private var deviceDetail: DeviceDetail?
    private var isSharedDevice: Bool {
        return deviceDetail?.isSharedDevice ?? false
    }

    private var robotOffline = false
    private var hadStartWaveAnimation = false

    /// 首次载入
    /// 第一帧地图帧/路径帧到来时刷新所有界面
    private var needRefreshMapViewInMediaPlayer = true
    private var needEntrySaveMapLogic = true
    private var needShowCleaningLog = true

    /// 该属性用于，当前保存地图弹窗弹出时，扫地机正在清扫。保存该弹出状态，在清扫结束后再进入一遍保存地图逻辑。
    private var needEntrySaveMapLogicAfterBasicStateChanged = false


    /// 在地图变化时，将下列是否需要展示“地图保存”弹窗标识为true
    /// 在dataloading成功时，进行展示
    private var needShowSaveMapMultiFloor = false
    private var needShowSaveMapSingleFloor = false
    private var needShowMapHasSavedTip = false

    /// 基站升级与关机页面展示
    private var isShowingUpgradingView: Bool {
        get {
            return !sweeperBaseUpgradingView.isHidden
        }
        set {
            sweeperBaseUpgradingView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var isShowingMechanicalView: Bool {
        get {
            return !sweeperMechanicalOffView.isHidden
        }
        set {
            sweeperMechanicalOffView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var shouldShowChargeButton: Bool {
        get {
            guard let state = state else {
                return false
            }
            // 清扫完成并且不在基站上
            return state.cleanFinished && !state.onboard
        }
    }

    private var firstTimeUpdateNavigationTitle: Bool = true

    private var cleaningMode: SweeperCleaningMode {
        get {
            return sweeperControl?.cleaningMode ?? SweeperCleaningMode.init(type: .autoClean)
        }
        set {
            sweeperControl?.cleaningMode = newValue
            updateCleaningModeUI()
        }
    }

    private var cleaningModeType: CleaningModeType {
        get {
            return cleaningMode.type
        }
        set {
            cleaningMode.type = newValue
        }
    }

    override var sweeperCustomOrAutoMode: SweeperCustomOrAutoMode {
        get {
            return (sweeperControl?.customCleanEnabled ?? false) ? .custom : .auto
        }
        set { }
    }

    private var map: SweeperMap? {
        get {
            return sweeperControl?.map
        }
        set {
            let preMap = map
            sweeperControl?.map = newValue
            currentMapDidChanged(preMap: preMap)
        }
    }

    private var status: SweeperProcedure = .stop

    private var state: SweeperState? {
        get {
            return sweeperControl?.basicState
        }

        set {
            sweeperControl?.basicState = newValue
            basicStateChangeAction(showToast: true)
        }
    }

    private var temperatureText: String {
        get {
            var text = "环境温度："
            if let temperature = state?.temperature {
                let temperatureValue = Int(temperature)
                if temperatureValue == 127 || temperatureValue < -40 {
                    text += "--"
                } else {
                    text += "(Int(temperature))℃"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var humidityText: String {
        get {
            var text = "环境湿度："
            if let humidity = state?.humidity {
                let humidityValue = Int(humidity)
                if humidityValue < 0 || humidityValue > 100 {
                    text += "--"
                } else {
                    text += "(Int(humidity))%"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var cleaningState: SweeperCleaningState? {
        get {
            return sweeperControl?.cleaningState
        }

        set {
            sweeperControl?.cleaningState = newValue
            updateCleaningStateUI()
        }
    }

    private var isRecharging: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .recharge
    }

    private var forbiddenRechargeAndClean: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .assignLocation || state.mainState == .remoteControl
    }

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = SharedResource.sharedImage(named: "shared_setting_icon_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(settingBarButtonItemDidClick))
    }()

    // selected layerID backup
    private var selectedLayerID = [Int]()

    // 当前展示的障碍物ID
    private var obstacleID: Int?

    override var navigationBarTraits: [NavigationBarTrait] {
        return [.hidden(on: false), .style(style: .default), .translucent(on: false), .barTint(color: .init(hexString: lightGray10Color)), .separatorStyle(color: .clear, height: 0.0), .backgroundImage(image: UIImage())]
    }

    // MARK: - Constants
    private let chargeButtonPadding = 8.0
    private let defaultButtonPadding = 12.0
    private let defaultButtonInterval = 59.0
    private let battreyThreshold = 20
    private let bottomSafeAreaInset = TPUIUtils.safeAreaInsets().bottom

    override init(deviceID: TPSSDeviceIdentifier, listType: TPSSDeviceListType) {
        super.init(deviceID: deviceID, listType: listType)

        SweeperModule.shared.registerControlListener(listener: self, deviceID: deviceID, listType: listType)
        SweeperModule.shared.registerMapListener(mapListener: self)
        NotificationCenter.default.addObserver(self, selector: #selector(willEnterForeground), name: UIApplication.willEnterForegroundNotification, object: nil)
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        view.backgroundColor = .init(hexString: lightGray10Color)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        setupNavigation()
        setupControlView()
        setupMapView()
        setupSweeperAlarmView()
        setupButtons()
        setupOfflineView()
        setupEnvironmentView()
        setupLoadingView()
        setupUpgradingView()
        setupMechanicalOffView()
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true

        // 离开当前页面时，会使动画失效，若正在展示动画，再重新进入时，需要重新开始动画
        if hadStartWaveAnimation {
            startWaveAnimation()
        }

        if let loadingState = sweeperControl?.dataLoadingState {
            dataLoadingStateChangeAction(loadingState: loadingState)
        } else {
            updateViewShowState(state: .failed)
        }
        captureBubbleViewDismiss()
        // 横幅始终展示在最前方
        if let alarmView = sweeperAlarmViewController?.view {
            view.bringSubviewToFront(alarmView)
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        if needShowFastMapGuide {
            showFastMapGuideView()
            needShowFastMapGuide = false
        }
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        savedMapNoticeView?.removeFromSuperview()
    }

    deinit {
        SweeperModule.shared.removeControlListener(listener: self)
        SweeperModule.shared.removeMapListener(mapListener: self)
        NotificationCenter.default.removeObserver(self)
    }

    // 将从后台切换到前台，看作视图willAppear，方法作相同处理
    @objc func willEnterForeground() {
        cleanAllFlag()

        // 若当前的载入状态为loading时，对UI进行loading状态的刷新。
        // 否则等待dataLoadingStateDidChanged方法回调(从 loading -> 其他状态)。
        // 注：dataLoadingStateDidChanged方法在 loading -> loading 时不会被调用。
        if sweeperControl?.dataLoadingState == .loading {
            dataLoadingStateChanged(loadingState: .loading)
        }
    }

    /// 根据载入状态更新主页面View的展示情况
    /// -主页面加载状态 -
    /// 需要管理的控件：创建地图按钮、主页面地图、载入（载入失败）页面、编辑地图按钮、边扫边拖（定制清扫）悬浮按钮
    private func updateViewShowState(state: SweeperDataLoadingState) {
        switch state {
            case .loading:
                loadingView.isHidden = false
                loadingView.isLoadingFailure = false
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
            case .failed:
                loadingView.isLoadingFailure = true
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
                // 若扫地机离线，则展示离线页面，否则展示加载失败页面
                loadingView.isHidden = robotOffline
                equipmentOfflineView?.isHidden = !robotOffline
            case .noMap:
                createMapContainer?.isHidden = false
                loadingView.isHidden = true
                mapView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                parameterButton.isHidden = false
                moreButton?.isHidden = false
                editButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
            case .success:
                loadingView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                mapView.isHidden = false
                createMapContainer?.isHidden = true
                parameterButton.isHidden = false
                editButton?.isHidden = false
                moreButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
        }
    }

    override func willUpdateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode, showAlert: Bool) -> Bool {
        /// 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            if showAlert {
                showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap)
            }
            return false
        }
        return super.willUpdateSweeperCustomOrAutoMode(newMode: newMode, showAlert: showAlert)
    }

    override func updateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode) {
        /// 1. 若切换时当前清扫模式与newMode相同，则无需进入后续逻辑
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap,
              let sweeperControl = sweeperControl,
              let mapID = sweeperControl.map?.currentMapID,
              newMode != sweeperCustomOrAutoMode else {
            return
        }

        /// 2. 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap) { [weak self] (_) in
                self?.configurationView?.selectSegment(type: .auto)
            }
            return
        }

        /// 3. 切换为定制清扫时，无设置清扫顺序与清扫偏好，则不向设备发送请求（并在退出弹窗时（configurationFinished）切换回变扫边拖）
        if newMode == .custom && !isSetPreference() && !isSetSweepSeq() {
            return
        }

        /// 4. 发送切换清扫模式的接口，并修改主页面UI
        let customCleanEnabled = newMode == .custom
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestSetCleaningParam(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: mapID, customEnabled: customCleanEnabled).always {
            ToastView.dismissLoadingToast()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }

    override func configurationFinished() {
        /// 若configurationView当前处于定制清扫页面（“1”状态），则判断是否已设置定制清扫，若否切回边扫边拖。
        if !isSetPreference() && !isSetSweepSeq() && !settingButtonDidClickFlag && configurationView?.segmentedControl.selectedSegmentIndex == 1 {
            ToastView.showWarningToast(title: "未设置定制清扫，只能使用普通清扫", existTime: nil, centerY: .low)
            // 0 - means auto cleaning
            configurationView?.selectSegment(type: .auto)
        }
    }

    override func preferenceButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.preferenceButtonClickOperation()
    }

    override func sweepOrderButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.sweepOrderButtonClickOperation()
    }

    private func refreshMediaPlayerAndSweeperControl() {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.refreshSweeperControl()
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
    }

    private func updateConfigurationView() {
        configurationView?.selectSegment(type: sweeperCustomOrAutoMode)
        if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
            cleanMethodMode = mode
        }
    }

    private func updateClearingAreaButton() {
        var text = "全屋"
        var imagePath = "sweep_home"
        var title = text
        switch cleaningModeType {
        case .pointClean:
            text = "选框"
            title = text
            imagePath = "sweep_frame"
        case .areaClean:
            text = "区域"
            title = text
            imagePath = "sweep_region"
        case .autoClean:
            text = "全屋"
            title = text
            imagePath = "sweep_home"
        case .partClean:
            // 仅在sweepControlView的RangeTitle中修改
            updateData(with: .autoClean)
            title = "局部"
        case .fastMap:
            // DO NOTHING
            return
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
        sweepControlView.clearAreaButton?.titleLabel.text = text
        sweepControlView.clearAreaButton?.titleImageView.image = UIImage.image(named: imagePath)
        sweepControlView.rangeTitleLabel.text = title
        sweepControlView.clearAreaButton?.selectedAreaNumber = cleaningModeType == .areaClean ? selectedLayerID.count : 0
    }

    private func updateSweeperHomeMapViewCleanMode() {
        switch cleaningModeType {
        case .pointClean:
            mapView.cleaningModeType = .pointClean
        case .areaClean:
            mapView.cleaningModeType = .areaClean
        case .autoClean:
            mapView.cleaningModeType = .autoClean
        case .partClean:
            mapView.cleaningModeType = .partClean
        case .fastMap:
            mapView.cleaningModeType = .fastMap
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
    }

    private func updateSelectedLayerID() {
        if let seq = sweeperControl?.cleaningMode.areaIDs {
            selectedLayerID = seq
        }
    }

    private func updateParamUI() {
        var text = ""
        var imagePath = ""
        switch sweeperCustomOrAutoMode {
        case .auto:
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                switch mode {
                case .sweep:
                    text = LocalizedString(key: sweeperCleanOnlySweep)
                    imagePath = "mode_sweep"
                case .mop:
                    text = LocalizedString(key: sweeperCleanOnlyMop)
                    imagePath = "mode_mop"
                case .both:
                    text = LocalizedString(key: sweeperCleanSweepAndMop)
                    imagePath = "mode_sweep_mop"
                }
            }
        case .custom:
            text = LocalizedString(key: sweeperCustomClean)
            imagePath = "mode_diy"
        }
        let image = UIImage.image(named: imagePath)
        // 控制栏的参数按钮
        sweepControlView.parameterButton?.titleLabel.text = text
        sweepControlView.parameterButton?.titleImageView.image = image

        // 悬浮的参数按钮
        parameterButton.titleLabel.text = text
        parameterButton.titleImageView.image = image
    }

    private func updateSweeperHomeMapViewCustomOrAutoMode() {
        switch sweeperCustomOrAutoMode {
        case .auto:
            mapView.sweeperCustomOrAutoMode = .auto
        case .custom:
            mapView.sweeperCustomOrAutoMode = .custom
        }
    }

    private func dataLoadingStateChangeAction(loadingState: SweeperDataLoadingState) {
        // 1. 判断设备是否离线（deviceDetail.online）
        if loadingState == .failed {
            robotOffline = !(deviceDetail?.online ?? false)
        }

        // 2. 判断基站是否升级，若是，则不展示所有UI（除了导航栏）
        if state?.chargeBaseUpgrading == true {
            isShowingUpgradingView = true
            updateNavigation()
            return
        }

        if let switchOn = state?.mechanicalSwitchOn {
            showMechanicalOffView(switchOn: switchOn)
        }

        // 3. 刷新UI状态(是否hidden)
        updateViewShowState(state: loadingState)

        // 4. 载入成功（success or nomap）按照其他状态展示UI
        if loadingState == .success {
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            mapView.updateCleanningModeAndSweepingState()
            mapView.updateCustomOrAutoMode()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            sweeperAlarmViewController?.showAlarm()
            sweeperAlarmViewController?.showNotify()
            if needShowCleaningLog {
                sweeperAlarmViewController?.showCleaningLog()
                needShowCleaningLog = false
            }
            if needEntrySaveMapLogic {
                currentMapDidChanged(preMap: nil)
                needEntrySaveMapLogic = false
            }
            saveMapLogic()
        } else if loadingState == .noMap {
            // 尽管当前map id 为-2，但当设备发送地图帧过来时，仍然需要展示地图，故仍然需要刷新mapView
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            sweeperAlarmViewController?.showCleaningLog()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            // 用户未进入引导页，且当前不在清扫、建图中，需要进入快速建图引导页
            if UserDefaults.standard.shouldShowGuideForFastMap(for: deviceID) && (state?.cleanFinished ?? true) {
                let vc = SweeperFastMapGuideViewController(deviceID: deviceID, listType: listType)
                navigationController?.pushViewController(vc, animated: true)
            }
        }
    }

    private func saveMapLogic() {
        // 若需要展示弹窗，但当前在清扫中，则将弹窗状态保存起来，待扫地机状态变化时重新进入。
        if state?.cleanFinished == false && (needShowSaveMapSingleFloor || needShowSaveMapMultiFloor) {
            needEntrySaveMapLogicAfterBasicStateChanged = true
            return
        }
        if needShowMapHasSavedTip {
            showMapHasSavedTip()
            needShowMapHasSavedTip = false
        }
        if needShowSaveMapSingleFloor {
            saveMapSingleFloor()
            needShowSaveMapSingleFloor = false
        }
        if needShowSaveMapMultiFloor {
            saveMapMultiFloor()
            needShowSaveMapMultiFloor = false
        }
    }

    private func basicStateChangeAction(showToast: Bool) {
        // 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 展示波纹动画: 1. 当前地图ID为-2；
        //             2. 当前在清扫中；
        //             3. 未展示过动画
        //             4. 无地图帧
        if map?.currentMapID == noMapID
            && state?.cleanFinished == false && !hadStartWaveAnimation && sweeperControl?.hadFrame == false {
            startWaveAnimation()
        }
        if (state?.cleanFinished == true) {
            stopWaveAnimation()
        }
        // 特殊情况处理，当扫地机进入清扫状态时
        // 且当前处于无地图时，需要显示地图（而非等到map更改的信令进行变化）
        // 再次变为非清扫状态，且无地图时，需要展示无地图Image
        if map?.currentMapID == noMapID && state?.cleanFinished == false {
            updateViewShowState(state: .success)
        } else if map?.currentMapID == noMapID && state?.cleanFinished == true {
            updateViewShowState(state: .noMap)
        }

        // 扫地机关机状态更新
        showMechanicalOffView(switchOn: state?.mechanicalSwitchOn ?? false)

        if showToast {
            updateBasicStateToastView()
        }
        // 更新扫地机当前的清扫状态（将扫地机状态分为清扫中、暂停中、未清扫，后续根据该status更新清扫UI）
        updateSweepProduce()

        updateUI()
    }

    /// 使用Clean Finished，fast Map  字段与 basic state字段联合判断当前清扫是否结束
    private func updateSweepProduce() {
        guard let state = state else {
            status = .stop
            return
        }
        if state.cleanFinished && state.mainState != .paused && state.mainState != .cleaning {
            // 若设备清扫完成且设备主状态不在清扫、暂停时
            status = .stop
        } else {
            if state.fastMap {
                // 若为快速建图
                if state.mainState == .cleaning {
                    status = .fastMap
                } else {
                    status = .fastMapPause
                }
            } else {
                // 若不为快速建图，则展示正常清扫UI
                if state.mainState == .cleaning {
                   status = .sweeping
                } else {
                   status = .sweepingPause
                }
            }
        }
    }

    // 根据信令展示ToastView
    private func updateBasicStateToastView() {
        guard let state = state else {
            return
        }
        // 主状态为回充，遥控，清扫时候，主页均需展示loading
        if ((state.mainState == .cleaning || state.mainState == .recharge || state.mainState == .remoteControl) && state.subState == .relocate) {
            ToastView.showLoadingToast(cirleWithMessage: "定位中...", existTime: 60, existMessage: nil)
        } else {
            ToastView.dismissLoadingToast()
        }
    }

    /// 根据status更新：清扫面板、清扫参数、导航栏里扫地机的状态、回充按钮、提示栏的位置；
    /// status:     sweeping：当cleanFinished为false，且mainState为Cleaning，subState为Sweeping；
    ///        pause：当cleanFinished为false，
    private func updateUI() {
        // 只当地图数据载入完成之后，更新信令收到后的UI
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 每次收到信令后，获取设备状态，更新设备状态同时更新界面UI

        // 控制面板
        sweepControlView.status = status
        sweepControlViewHeightConstraint?.constant = heightForControlView
        if status == .stop {
            // 清扫参数按钮
            parameterButton.isHidden = true
            // 地图控件
            mapView.isSweeping = false
        } else if status == .fastMap || status == .fastMapPause {
            mapView.isSweeping = true
            parameterButton.isHidden = true
        } else {
            parameterButton.isHidden = false
            mapView.isSweeping = true
        }
        // 导航栏的状态和电量
        updateNavigation()
        // 温度湿度更新
        updateEnvironmentView()
        // 充电按钮
        updateChargeButton()
        refreshBubbleView()
    }

    private func updateCleaningStateUI() {
        guard let state = cleaningState else {
            return
        }
        sweepControlView.areaTitleLabel.text = "(state.cleaningArea)㎡"
        sweepControlView.timeTitleLabel.text = "(state.cleaningTime)min"
    }

    private func updateCleaningModeUI() {
        /// 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        /// 修改设置清扫模式（cleaningMode）按钮的样式
        updateClearingAreaButton()
        /// 修改地图的清扫模式
        updateSweeperHomeMapViewCleanMode()
        /// 根据获取到的cleaningMode中区域清扫的ID，更新地图区域的清扫顺序数组
        updateSelectedLayerID()
        /// 修改定制清扫/边扫边拖属性 - 通过回调去更新该属性更新后主页后续的UI。回调中调用的方法 - updateSweeperCustomOrAutoMode()
        updateConfigurationView()
        /// 修改定制清扫/边扫边拖按钮的样式
        updateParamUI()
        /// 修改定制清扫/边扫边拖地图的样式
        updateSweeperHomeMapViewCustomOrAutoMode()
    }

    private func showAlertWithWholeHouseClean() {
        showAlertWith(title: "进行一次全屋清扫", message: "清扫完成后，将建立家居地图。", messageTextAlignment: .center, defaultButtonTitle: "进行全屋清扫", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonHandler: nil) { [weak self] (_) in
            self?.showSweepTipsAlert()
        }
    }

    private func startFastMap() {
        if sweeperControl?.basicState?.mainState == .remoteControl {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFastMapDuringRemoteControl))
            return
        }
        if sweeperControl?.basicState?.mainState == .assignLocation {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFAstMapDuringAssignLocation))
            return
        }
        // 强制扫地机进入新建快速地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .fastMap)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: self.deviceID, channel: self.channel, listType: self.listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func startFastMapAlert() {
        let alert = SweeperTipsAlert(type: .fastMap) { [weak self] () in
            guard let self = self else { return }
            self.startFastMap()
        }
        alert.show()
    }

    private func showAlertWithFastMapEnd() {
        showAlertWith(title: "尚未得到完整地图，确定要结束吗？", message: nil, messageTextAlignment: .center, defaultButtonTitle: "结束建图", defaultButtonColor: .theme1, cancelButtonTitle: "继续", cancelButtonHandler: nil) { [weak self] (_) in
            self?.setCleaningMode(type: .stop)
        }
    }

    private func showSweepTipsAlert() {
        let alert = SweeperTipsAlert(type: .clean) { [weak self] () in
            self?.setCleaningMode(type: .sweeping)
        }
        alert.show()
    }

    private func setCleaningMode(type: SweeperProcedure) {
        switch type {
        case .sweeping:
            if sweeperControl?.basicState?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringRemoteControl))
                return
            }
            if sweeperControl?.basicState?.mainState == .assignLocation {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringAssignLocation))
                return
            }
            // 若扫地机当前无地图，则所有“清扫”操作为全屋清扫。
            if map?.currentMapID == noMapID {
                self.cleaningMode = SweeperCleaningMode.init(type: .autoClean)
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: SweeperCleaningMode.init(type: .autoClean)).catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
                return
            }

            if cleaningModeType == .areaClean {
                if selectedLayerID.count == 0 {
                    ToastView.showWarningToast(title: "请选择需要清扫的区域", existTime: nil, centerY: .low)
                    return
                }
                sweeperControl?.cleaningMode.areaIDs = selectedLayerID
            } else if cleaningModeType == .pointClean,
                      let partArea = mapView.getSelectionRect() {
                // 若能够从SelectionRect获取到数据，则修改cleaningMode的PointRect
                sweeperControl?.cleaningMode.leftTopPoint = partArea.leftTopPoint
                sweeperControl?.cleaningMode.rightBottomPoint = partArea.rightBottomPoint
            } else {
                sweeperControl?.cleaningMode = .init(type: .autoClean)
            }

            ToastView.showLoadingToast(cirleWithMessage: nil)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: sweeperControl?.cleaningMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .sweepingPause, .fastMapPause:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .pause)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .stop:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .stop)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .fastMap:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .fastMap)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func saveMapSingleFloor() {
        let deleteMapID = map?.allMapNames.keys.first(where: { (mapID) -> Bool in
                  return mapID != temporaryMapID
              })
        guard let sweeperControl = sweeperControl,
              let deleteMapID = deleteMapID,
              let deleteMapName = map?.allMapNames[deleteMapID] else {
            return
        }
        showAlert(title: "是否保存新地图?", buttons: [
            .init(style: .default, text: "更新“(deleteMapName)”", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                ToastView.showLoadingToast(cirleWithMessage: "正在更新")
                SweeperService.deleteMap(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: deleteMapID).then { (_) in
                    ToastView.showWarningToast(title: "更新成功", existTime: nil, centerY: .low)
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
            }),
            .init(style: .default, text: "另存为新地图", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let alert = SweeperSelectionAlert(title: "相同环境请勿保存多张地图，有可能影响机器人的定位。", message: "我家为多楼层户型") {
                    guard self?.isCurrentMapSaved() == true else {
                        ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                        return
                    }
                    ToastView.showLoadingToast(cirleWithMessage: "正在保存")
                    SweeperService.setMultiFloorEnabled(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, enabled: true, mapID: nil).always {
                        ToastView.dismissLoadingToast()
                    }.then { _ in
                        ToastView.showWarningToast(title: "保存成功", existTime: nil, centerY: .low)
                    }.catch { (error) in
                        ToastView.showWarningToast(warningMessage: error.localizedDescription)
                    }
                } cancelHandler: { [weak self] () in
                    self?.saveMapSingleFloor()
                }
                alert.show()
            }, isPreferred: true),
            .init(style: .default, text: LocalizedString(key: notSaveMap))
        ])
    }

    private func saveMapMultiFloor() {
        showAlert(title: "地图数量已达上限，是否保存新地图？", message: "如点击“保存”，请选择新地图要覆盖哪张旧地图。", messageTextAlignment: .center, buttons: [
            .init(style: .default, text: LocalizedString(key: notSaveMap), color: .theme1),
            .init(style: .default, text: "保存", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let vc = SweeperCoverOldMapController()
                vc.sweeperControl = self?.sweeperControl
                self?.navigationController?.pushViewController(vc, animated: true)
            }, isPreferred: true)
        ])
    }

    private func isCurrentMapSaved() -> Bool {
        return map?.currentMapID == temporaryMapID
    }

    /// preMapID 为 nil，表示为第一次赋值
    private func currentMapDidChanged(preMap: SweeperMap?) {
        guard let map = map else {
            return
        }
        // 展示波纹动画条件： 1. 当前地图id为-2
        //                 2. 当前主状态为清扫中
        //                 3. 第一次进入主页面
        //                 4. 当前无地图I帧
        let needShowRobotWave = map.currentMapID == noMapID && sweeperControl?.basicState?.mainState == .cleaning && (preMap == nil || !hadStartWaveAnimation) && sweeperControl?.hadFrame == false
        if needShowRobotWave {
            startWaveAnimation()
        }
        /// preMapID 从 nil -> 0，未处理后退出主页重新进入
        /// 或 从 “-1” -> 0  表示成功创建，但还未自动保存新地图
        let preMapID = preMap?.currentMapID
        if (preMapID == nil || preMapID == isCreatingMapID) && map.currentMapID == temporaryMapID {
            ///  生成临时地图： 需要判断是多楼层还是单楼层来决定保存方式；
            guard let multiFloorEnabled = sweeperControl?.multiFloorEnabled, let maxMapNumber = sweeperControl?.capability?.maxMapNumber else {
                return
            }
            if multiFloorEnabled {
                if map.mapNumber > maxMapNumber && maxMapNumber > 0 && map.currentMapID == temporaryMapID {
                    // 地图已达上限且能力集中多楼层地图上限不为0，且当前地图是临时地图时，展示多楼层地图上限弹窗
                    needShowSaveMapMultiFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            } else {
                if map.mapNumber > 1 && map.currentMapID == temporaryMapID {
                    // 已经有一张地图且当前地图时临时地图时，展示单楼层地图上限弹窗。
                    needShowSaveMapSingleFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            }
            return
        }

        /// 成功创建，mapID 从 “-1” -> 大于0
        if preMapID == isCreatingMapID && map.currentMapID != noMapID && map.currentMapID != temporaryMapID && map.allMapNames.count == (preMap?.allMapNames.count ?? 0) + 1 {
            ///  生成完整地图：直接进入“已自动保存逻辑”
            needShowMapHasSavedTip = true
        }
    }

    private func showMapNotCompletedAlert(alertMessage: String, cancelHandler: ((UIAlertAction) -> Void)? = nil, defaultHandler: (() -> Void)? = nil) {
        showAlertWith(title: alertMessage, message: nil, messageTextAlignment: nil, defaultButtonTitle: "查看帮助", defaultButtonColor: .theme1, cancelButtonTitle: "关闭", cancelButtonColor: .theme1, cancelButtonHandler: cancelHandler, defaultButtonHandler: { [weak self] (_) in
            let vc = SweeperMapHelpViewController(type: .incomplete)
            self?.navigationController?.pushViewController(vc, animated: true)
            defaultHandler?()
        })
    }

    private func showCanNotCustomCleanAlert(isCreatingMap: Bool, defaultButtonhandler: ((UIAlertAction) -> Void)? = nil) {
        if isCreatingMap {
            showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持定制清扫", defaultHandler: { [weak self] () in
                self?.configurationView?.dismiss()
            })
        } else {
            showAlertWith(title: "请创建地图后再设置定制清扫", defaultButtonTitle: SharedResource.sharedFormatString(key: commonSure), defaultButtonColor: UIColor.black, cancelButtonTitle: nil, defaultButtonHandler: defaultButtonhandler)
        }
    }

    func showFastMapGuideView() {
        if fastMapImageView == nil {
            fastMapImageView = UIImageView()
            fastMapImageView?.image = UIImage.image(named: "quick_build_map")
            fastMapImageView?.sizeToFit()
        }
        guard let imageView = fastMapImageView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            fastMapGuideView?.dismiss()
            var offset: CGFloat = defaultButtonInterval
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            fastMapGuideView = presentGuideWith(viewToPresent: imageView, size: imageView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    func showMapHasSavedTip() {
        if savedMapNoticeView == nil {
            savedMapNoticeView = UIImageView()
            savedMapNoticeView?.image = UIImage.image(named: "edit_map")
            savedMapNoticeView?.sizeToFit()
        }
        guard let noticeView = savedMapNoticeView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            saveMapGuideView?.dismiss()
            var offset: CGFloat = 0
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            saveMapGuideView = presentGuideWith(viewToPresent: noticeView, size: noticeView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    override func collectionViewCell(_ cell: SweeperGlobalCleaningConfigurationCollectionViewCell, didSelectItemAt indexPath: IndexPath) {
        super.collectionViewCell(cell, didSelectItemAt: indexPath)

        let itemIndex = indexPath.section
        let row = indexPath.row
        let parameter = settingItems[itemIndex].paramters[row].type
        if parameter == .suctionForce(.none) {
            showAlertWith(title: "静音模式下吸尘能力将暂时降低，仅本次清扫任务生效。", message: nil, messageTextAlignment: nil, defaultButtonTitle: "确定", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonColor: .black, cancelButtonHandler: nil) { [weak self] (_) in
                self?.setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
            }
        } else {
            setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
        }
    }

    func setGlobalConfig(parameter: SweeperGlobalConfigurationType, itemIndex: Int) {
        var pendingConfig = sweeperControl?.globalCleaningConfig

        switch parameter {
        case .suctionForce(_):
            pendingConfig?.suction = parameter
        case .waterYield(_):
            pendingConfig?.waterYield = parameter
        case .sweepTimes(_):
            pendingConfig?.cleanTimes = parameter
        case .cleanMethod(_):
            pendingConfig?.cleanMethod = parameter
        case .mopMode(_):
            pendingConfig?.mopMode = parameter
        }


        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setGlobalCleaningConfig(device: deviceID, channel: channel, listType: listType, config: pendingConfig).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.then { [weak self] (_) in
            self?.sweeperControl?.globalCleaningConfig = pendingConfig
            self?.configurationView?.collectionView.reloadData()
            self?.updateParamUI()
        }
    }

    func startWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        let animationView = SweeperStartCleanAnimationView(frame: .zero)
        view.addSubview(animationView)

        animationView.snp.makeConstraints { make in
            make.centerX.equalToSuperview().offset(28)
            make.centerY.equalToSuperview().multipliedBy(0.764).offset(28)
            make.width.height.equalTo(56)
        }
        self.startCleanAnimationView = animationView
        animationView.startAnimation()
        hadStartWaveAnimation = true
    }

    func stopWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        startCleanAnimationView = nil
        hadStartWaveAnimation = false
    }

    private func cleanAllFlag() {
        needEntrySaveMapLogic = true
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true
        needShowMapHasSavedTip = false
        needShowSaveMapMultiFloor = false
        needShowSaveMapSingleFloor = false
        needEntrySaveMapLogicAfterBasicStateChanged = false
    }
}

// MARK: Button Action
private extension SweeperMainViewController {
    @objc func paramterButtonDidClick() {
        configurationView?.isSetSeq = isSetSweepSeq()
        configurationView?.isSetPreference = isSetPreference()
        configurationView?.show(view: self.navigationController?.view)
    }

    @objc func clearAreaButtonDidClick() {
        sweepAreaPopView = SweeperClearAreaPopView(type: cleaningModeType)
        sweepAreaPopView?.delegate = self
        sweepAreaPopView?.show()
    }

    @objc func startButtonDidClick() {
        guard (map?.currentMapID) != nil  else {
            return
        }
        if sweeperControl?.dataLoadingState == .success {
            setCleaningMode(type: .sweeping)
        } else {
            showAlertWithWholeHouseClean()
        }
    }

    @objc func stopButtonDidClick() {
        if status == .fastMapPause || status == .fastMap {
            showAlertWithFastMapEnd()
        } else {
            setCleaningMode(type: .stop)
        }
    }

    @objc func pasueButtonDidClick() {
        if status == .sweepingPause {
            setCleaningMode(type: .sweeping)
        } else if status == .fastMapPause {
            setCleaningMode(type: .fastMap)
        } else {
            setCleaningMode(type: .sweepingPause)
        }
    }

    @objc func previewButtonDidClick() {
        guard let mediaState = sweeperControl?.mediaState, checkEntryCondition() else {
            return
        }
        checkMediaStateAndJump(state: mediaState)
    }

    func checkMediaStateAndJump(state: SweeperMediaState) {
        // 若为被分享端，则不判断，直接进入人工驾驶页面
        if isSharedDevice {
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            vc.needShowSettingButton = false
            navigationController?.pushViewController(vc, animated: true)
            return
        }

        switch state {
        case .closed, .open:
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        case .openWithPermission:
            if sweeperControl?.mediaEncryptEnabled == true {
                // 视频加密开启，直接验证密码
                checkUnAuthenticated()
                return
            }
            // 视频加密关闭，需要检测设备空密码
            ToastView.showLoadingToast(cirleWithMessage: nil)
            requestCheckEmptyPassword {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func checkEntryCondition() -> Bool {
        if state?.collectDust == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterCollectionDust))
            return false
        }
        if state?.mopWashState == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterWashingMop))
            return false
        }
        return true
    }

    @objc func baseStationButtonDidClick() {
        if sweeperControl?.basicState?.cleanSinkState != .stop {
            let vc = SweeperBaseStationCleanSinkViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        } else {
            let vc = SweeperBaseStationMainViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func moreButtonDidClick() {
        let vc = SweeperMoreActionViewController(deviceID: deviceID, listType: listType)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    @objc func editButtonDidClick() {
        // 大于0的地图数量为0时(无已保存地图)并且没有地图，不允许进入，若mapID为“-1”允许进入
        if sweeperControl?.mapWithoutZero?.count == 0 && sweeperControl?.map?.currentMapID == noMapID {
            // 若扫地机在清扫、建图时，展示暂无地图
            if (state?.cleanFinished ?? true) {
                let fastMapGuideSheet = SweeperFastMapSheet()
                fastMapGuideSheet.delegate = self
                fastMapGuideSheet.show()
            } else {
                ToastView.showWarningToast(title: "暂无地图", existTime: nil, centerY: .low)
            }
            return
        }

        let alertActionSheet = TPActionSheet.init(title: nil)
        let setRigionAction = TPActionSheetAction.init(title: "设置禁区/虚拟墙", detail: "设置不允许扫地机器人进入的区域", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }

            // 清扫过程中进入编辑禁区页面需要暂停扫地机
            if self.status == .sweeping || self.status == .fastMap {
                self.setCleaningMode(type: .sweepingPause)
            }
            // 回充过程中进入编辑进去页面需要设置为待机
            if self.state?.mainState == .recharge {
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setStandBy(deviceID: self.deviceID, listType: self.listType).always {
                    ToastView.dismissLoadingToast()
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }
            }
            // 指哪到哪和遥控时不允许进入禁区页面
            if self.state?.mainState == .assignLocation || self.state?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterMission))
                return
            }
            let vc = SweeperForbiddenAreaVirtualWallViewController(sweeperControl: self.sweeperControl)
            self.navigationController?.pushViewController(vc, animated: true)
        }

        let editMapAreaAction = TPActionSheetAction.init(title: "编辑地图区域", detail: "划分地图区域并进行标记", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }
            /// 清扫、快速建图中不允许进入编辑区域页面
            if self.status != .stop {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterCleaning))
                return
            }
            /// 正在创建地图中不允许进入编辑区域页面
            guard self.map?.currentMapID != isCreatingMapID else {
                self.showMapNotCompletedAlert(alertMessage: LocalizedString(key: sweeperMapIsNotCompleteForEditingArea))
                return
            }
            let vc = SweeperEditMapAreaViewController(sweeperControl: self.sweeperControl)
            vc.isSetPreferenceOrOrder = self.isSetPreference() || self.isSetSweepSeq()
            self.navigationController?.pushViewController(vc, animated: true)
        }


        let manageMapAction = TPActionSheetAction.init(title: "管理地图", style: .leftTitle) { [weak self] (_) in
            guard let self = self else {
                return
            }
            let vc = SweeperMapManagerViewController()
            vc.delegate = self
            vc.deviceID = self.deviceID
            vc.listType = self.listType
            self.navigationController?.pushViewController(vc, animated: true)
        }

        var editActionArray: [TPActionSheetAction] = []
        editActionArray = map?.currentMapID == noMapID ? [manageMapAction] : [setRigionAction, editMapAreaAction, manageMapAction]

        editActionArray.forEach { (action) in
            action.font = .projectFont(ofSize: 16)
            action.detailFont = .projectFont(ofSize: 12)
            alertActionSheet.addAction(action)
        }
        alertActionSheet.separatorColor = .cellSeparatorGray

        alertActionSheet.show()
    }

    @objc func settingBarButtonItemDidClick() {
        if let vc = SweeperSettingViewController.create() {
            vc.deviceID = deviceID
            vc.listType = listType
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func rechargeButtonDidClick() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setRechargeState(device: deviceID, channel: channel, listType: listType, enabled: !isRecharging).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperRobotOfflineViewDelegate {
    func offlineHelpButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.requiredService?.goToOfflineHelp(deviceID: sweeperControl.deviceID, cloudID: sweeperControl.cloudID, listType: sweeperControl.listType, navigator: self.navigationController)
    }

    func offlineRefreshButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
        SweeperModule.shared.refreshSweeperControl()
    }
}

extension SweeperMainViewController: SweeperClearAreaPopViewDelegate {
    func updateData(with type: CleaningModeType) {
        if map?.currentMapID == isCreatingMapID {
            switch type {
            case .areaClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持区域清扫")
            case .pointClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持选框清扫")
            case .autoClean:
                // DO NOTHING
                break
            case .partClean:
                // DO NOTHING
                break
            case .pause:
                // DO NOTHING
                break
            case .stop:
                // DO NOTHING
                break
            case .fastMap:
                // DO NOTHING
                break
            }
            sweepAreaPopView?.dismiss()
            return
        } else {
            if type == .areaClean {
                if map?.currentMapID != noMapID {
                    ToastView.showWarningToast(title: "请选择区域", existTime: nil, centerY: .low)
                }
            }
        }
        self.cleaningModeType = type
        sweepAreaPopView?.dismiss()
    }
}

// MARK: setup UI
private extension SweeperMainViewController {
    func setupNavigation() {

        navigationItem.title = deviceDetail?.alias ?? "扫地机器人"

        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
        addCustomNavigationLeftBarButtonItem(title: nil, image: SharedResource.sharedImage(named: "common_light_back_nor"))
    }

    func setupButtons() {
        var title: String
        var imageName: String
        if isSharedDevice {
            title = "遥控"
            imageName = "ptz"
        } else {
            title = "视频遥控"
            imageName = "preview_light_nor"
        }
        previewButton = SweeperButton(title: title, fontSize: 9, image: UIImage.image(named: imageName))
        let previewTap = UITapGestureRecognizer.init(target: self, action: #selector(previewButtonDidClick))
        previewButton?.addGestureRecognizer(previewTap)
        if let button = previewButton {
            self.view.bringSubviewToFront(button)
        }
        if let previewButton = previewButton {
            buttonContainerStackView.addArrangedSubview(previewButton)
        }

        editButton = SweeperButton(title: "编辑地图", fontSize: 9, image: UIImage.image(named: "map_black_nor"))

        let editTap = UITapGestureRecognizer.init(target: self, action: #selector(editButtonDidClick))
        editButton?.addGestureRecognizer(editTap)
        if let editButton = editButton {
            buttonContainerStackView.addArrangedSubview(editButton)
        }

        baseStationButton = SweeperButton(title: "基站", fontSize: 9, image: UIImage.image(named: "sweeper_home"))

        let stationTap = UITapGestureRecognizer.init(target: self, action: #selector(baseStationButtonDidClick))
        baseStationButton?.addGestureRecognizer(stationTap)
        if let baseStationButton = baseStationButton {
            buttonContainerStackView.addArrangedSubview(baseStationButton)
        }

        moreButton = SweeperButton(title: "更多", fontSize: 9, image: UIImage.image(named: "star"))

        let moreButtonTap = UITapGestureRecognizer.init(target: self, action: #selector(moreButtonDidClick))
        moreButton?.addGestureRecognizer(moreButtonTap)
        if let moreButton = moreButton {
            buttonContainerStackView.addArrangedSubview(moreButton)
        }

        [previewButton, editButton, baseStationButton, moreButton].forEach { button in
            button?.snp.makeConstraints { make in
                make.width.equalTo(44)
                make.height.equalTo(47)
            }
        }

        /* buttonContainerStackView */
        view.addSubview(buttonContainerStackView)
        buttonContainerStackView.axis = .vertical
        buttonContainerStackView.alignment = .center
        buttonContainerStackView.spacing = 12
        buttonContainerStackView.snp.makeConstraints { make in
            make.width.equalTo(44)
            make.top.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }

        /* createMapButton */
        createMapContainer = SweeperCreateMapView()
        if let createMapContainer = createMapContainer {
            view.addSubview(createMapContainer)

            let goldenRatio: CGFloat = 0.382
            createMapContainer.snp.makeConstraints { make in
                make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2).offset(-(88 * goldenRatio))
                make.centerX.equalToSuperview()
                make.width.equalTo(230)
            }
        }
        createMapContainer?.isHidden = true

        /* chargeButton */
        chargeButton = SweeperButton(title: "返回基站", fontSize: 9, image: UIImage.image(named: "robot_charger"), offsetToTop: 5)
        addContraint(for: chargeButton, trailingToSuperView: -defaultButtonPadding)
        chargeButton.isHidden = true
        chargeButton.snp.makeConstraints { make in
            if let sweeperAlarmView = sweeperAlarmViewController {
                make.bottom.equalTo(sweeperAlarmView.view.snp.top).offset(-defaultButtonPadding / 2)
            } else {
                make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding)
            }
        }
        let chargeTap = UITapGestureRecognizer.init(target: self, action: #selector(rechargeButtonDidClick))
        chargeButton.addGestureRecognizer(chargeTap)

        parameterButton = SweeperButton(title: LocalizedString(key: sweeperCleanSweepAndMop), fontSize: 9, image: UIImage.image(named: "mode_general"), offsetToTop: 5)
        addContraint(for: parameterButton, trailingToSuperView: -defaultButtonPadding, bottomToSuperView: nil)
        parameterButton.snp.makeConstraints { (make) in
            make.bottom.equalTo(chargeButton.snp.bottom)
        }

        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        parameterButton.addGestureRecognizer(paramTap)

    }

    func setupOfflineView() {
        let offlineView = SweeperRobotOfflineView(frame: .zero)
        offlineView.delegate = self
        self.view.addSubview(offlineView)

        let goldenRatio: CGFloat = 0.382
        offlineView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2)
        }
        equipmentOfflineView = offlineView
        equipmentOfflineView?.isHidden = true
    }

    func updateNavigation() {
        if firstTimeUpdateNavigationTitle {
            navigationTitleView = SweeperTitleBatteryView(title: deviceDetail?.alias ?? "扫地机器人", stateText: "", power: 0, charge: false)
            navigationTitleView.snp.remakeConstraints { make in
                make.height.equalTo(44)
                make.width.equalTo(screenWidth - 150)
            }
            navigationItem.titleView = navigationTitleView
            firstTimeUpdateNavigationTitle = false
        }

        let stateText = state?.stateDescription ?? "故障中"
        let battery = state?.battery ?? 0
        let isCharging = state?.mainState == .charging
        navigationTitleView.setState(stateText: stateText, power: battery, charge: isCharging)
    }

    func updateEnvironmentView() {
        temperatureView.text = temperatureText
        humidityView.text = humidityText
    }

    func updateChargeButton() {
        chargeButton.isHidden = !shouldShowChargeButton
        if isRecharging {
            chargeButton.setTitle(title: "停止回充", buttonImage: UIImage.image(named: "robot_charge_stop"))
        } else {
            chargeButton.setTitle(title: "返回基站", buttonImage: UIImage.image(named: "robot_charger"))
        }
        if forbiddenRechargeAndClean {
            chargeButton.titleLabel.textColor = .lightGray3Color.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = false
        } else {
            chargeButton.titleLabel.textColor = .black.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = true
        }
    }

    func setupLoadingView() {
        view.addSubview(loadingView)
        loadingView.delegate = self
        loadingView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(0.764)
        }
    }

    func setupMapView() {
        let mapSize = sweeperControl?.mapSize ?? CGSize(width: defaultMapWidth, height: defaultMapHeight)
        mapView = SweeperHomeMapView(frame: .zero, mapSize: mapSize)
        mapView.backgroundColor = UIColor.clear
        view.addSubview(mapView)
        mapView.delegate = self
        mapView.sweeperIconMapView.delegate = self
        mapView.datasource = self
        mapView.isHidden = true

        mapView.snp.makeConstraints { make in
            make.top.trailing.leading.equalToSuperview()
            make.bottom.equalTo(sweepControlView.snp.top)
        }
        setupTapGesture()
    }

    func setupTapGesture() {
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(didTaped(recognizer:)))
        self.mapView.addGestureRecognizer(tapGesture)
    }

    func setupSweeperAlarmView() {
        let sweeperAlarmViewController = SweeperAlarmBannerViewController()
        sweeperAlarmViewController.window(from: .mainPage)
        sweeperAlarmViewController.sweeperControl = self.sweeperControl

        self.addChild(sweeperAlarmViewController)
        view.addSubview(sweeperAlarmViewController.view)
        sweeperAlarmViewController.view.snp.makeConstraints { make in
            make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding / 2)
            make.leading.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }
        self.sweeperAlarmViewController = sweeperAlarmViewController
    }

    @objc func didTaped(recognizer: UITapGestureRecognizer) {
        captureBubbleViewDismiss()
    }

    func setupEnvironmentView() {
        view.addSubview(environmentView)

        environmentView.snp.makeConstraints { make in
            make.height.equalTo(36)
            make.leading.top.equalToSuperview().offset(12)
        }
        environmentView.backgroundColor = .lightGray3Color.withAlphaComponent(0.1964)
        environmentView.layer.cornerRadius = 5

        [temperatureView, humidityView].forEach { label in
            environmentView.addSubview(label)

            label.backgroundColor = .clear
            label.textColor = .black.withAlphaComponent(0.6)
            label.textAlignment = .left
            label.font = .projectFont(ofSize: 10)
            label.snp.makeConstraints { make in
                make.height.equalTo(14)
                make.trailing.equalToSuperview().offset(-8)
                make.leading.equalToSuperview().offset(8)
            }
        }

        temperatureView.snp.makeConstraints { make in
            make.top.equalToSuperview().offset(4)
        }
        temperatureView.text = temperatureText

        humidityView.snp.makeConstraints { make in
            make.top.equalTo(temperatureView.snp.bottom)
        }
        humidityView.text = humidityText
    }

    func setupControlView() {
        addConstraint(forBottomView: sweepControlView, height: nil)
        sweepControlView.isHidden = true
        sweepControlViewHeightConstraint = NSLayoutConstraint(item: sweepControlView,
                                                             attribute: .height,
                                                             relatedBy: .equal,
                                                             toItem: nil,
                                                             attribute: .notAnAttribute,
                                                             multiplier: 1.0,
                                                             constant: 0)
        sweepControlViewHeightConstraint?.isActive = true

        // button clicked
        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        sweepControlView.parameterButton?.addGestureRecognizer(paramTap)

        let clearTap = UITapGestureRecognizer.init(target: self, action: #selector(clearAreaButtonDidClick))
        sweepControlView.clearAreaButton?.addGestureRecognizer(clearTap)

        let startTap = UITapGestureRecognizer.init(target: self, action: #selector(startButtonDidClick))
        sweepControlView.startButton.addGestureRecognizer(startTap)

        let stopTap = UITapGestureRecognizer.init(target: self, action: #selector(stopButtonDidClick))
        sweepControlView.stopButton.addGestureRecognizer(stopTap)

        let pauseTap = UITapGestureRecognizer.init(target: self, action: #selector(pasueButtonDidClick))
        sweepControlView.pauseButton.addGestureRecognizer(pauseTap)

    }

    func setupUpgradingView() {
        view.addSubview(sweeperBaseUpgradingView)
        sweeperBaseUpgradingView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingUpgradingView = false
    }

    func setupMechanicalOffView() {
        view.addSubview(sweeperMechanicalOffView)
        sweeperMechanicalOffView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingMechanicalView = false
        sweeperMechanicalOffView.delegate = self
    }

    func addConstraint(forBottomView bottomView: UIView?, height: CGFloat?) {
        guard let bottomView = bottomView else {
            return
        }
        bottomView.translatesAutoresizingMaskIntoConstraints = false

        view.addSubview(bottomView)

        // UI中设置的阴影radius为12，此处设置为8，才能与UI的效果一致。
        let shadowRadius: CGFloat = 8
        bottomView.layer.shadowOffset = .init(width: 0, height: 2)
        bottomView.layer.shadowRadius = shadowRadius
        bottomView.layer.shadowColor = UIColor.black.cgColor
        bottomView.layer.shadowOpacity = 0.16

        NSLayoutConstraint(item: bottomView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .width,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        if let height = height {
            NSLayoutConstraint(item: bottomView,
                               attribute: .height,
                               relatedBy: .equal,
                               toItem: nil,
                               attribute: .notAnAttribute,
                               multiplier: 1.0,
                               constant: height).isActive = true
        }

        NSLayoutConstraint(item: bottomView,
                           attribute: .bottom,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .bottom,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        NSLayoutConstraint(item: bottomView,
                           attribute: .centerX,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .centerX,
                           multiplier: 1.0,
                           constant: 0).isActive = true
    }

    func addContraint(for subView: UIView?, trailingToSuperView: CGFloat, topToSuperView: CGFloat? = nil, bottomToSuperView: CGFloat? = nil) {
        guard let subView = subView else {
            return
        }

        view.addSubview(subView)
        subView.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint(item: subView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 44).isActive = true
        NSLayoutConstraint(item: subView,
                           attribute: .height,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 47).isActive = true
        if let topToSuperView = topToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .top,
                               relatedBy: .equal,
                               toItem: view,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: topToSuperView).isActive = true
        }

        if let bottomToSuperView = bottomToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .bottom,
                               relatedBy: .equal,
                               toItem: bottomLayoutGuide,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: bottomToSuperView).isActive = true
        }

        NSLayoutConstraint(item: subView,
                           attribute: .trailing,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .trailing,
                           multiplier: 1.0,
                           constant: trailingToSuperView).isActive = true
    }
}

/// receive bitmap data
extension SweeperMainViewController: SweeperMapMediaPlayerListener {
    func mediaPlayerConnected(connectedSuccess: Bool) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if !connectedSuccess {
            dataLoadingStateChangeAction(loadingState: .failed)
        }
    }

    func dataLoadingStateChanged(loadingState: SweeperDataLoadingState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        dataLoadingStateChangeAction(loadingState: loadingState)
    }

    func mediaPlayerBitmapDataUpdate(dataType: MapMediaPlayerFrameFormat) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        /// 对扫地机地图正处于拖动或缩放时地图的刷新进行限制，避免卡顿的情况。
        guard !mapView.isOperation else {
            return
        }
        if dataType == .map {
            // 第一次收到I帧
            if sweeperControl?.hadFrame == true {
                stopWaveAnimation()
            }
            mapView.sweeperBitmapView.refreshBitmapImage()
            mapView.sweeperAreaView.refreshAreaView()
            if needRefreshMapViewInMediaPlayer {
                needRefreshMapViewInMediaPlayer = false
                mapView.refreshView()
            }
        }

        if sweeperControl?.hadFrame == true && dataType == .path {
            mapView.sweeperRouteView.refreshRouteView()
            // refresh equipment icon and charger pile location.
            mapView.sweeperIconMapView.refreshIconView()
        }
    }

    func mediaPlayerSignalling(mapID: String, type: SweeperConfigUpdateType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if type == .cleaningState {
            updateCleaningStateUI()
        } else if type == .cleaningMode || type == .cleanParam {
            updateCleaningModeUI()
        } else if type == .areaCleaning {
            mapView.updateCustomOrAutoMode()
            mapView.refreshAreaAndLabelView()
        } else if type == .globalCleaningConfig {
            // 修改全局清扫配置
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                cleanMethodMode = mode
                configurationView?.collectionView.reloadData()
            }
        } else {
            mapView.refreshView()
            mapView.refreshAreaAndLabelView()
        }
    }

    func mediaPlayerBasicStateDidChanged(preState: SweeperState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        basicStateChangeAction(showToast: true)
        sweeperAlarmViewController?.showAlarm()
        sweeperAlarmViewController?.showNotify()

        // 当前扫地机清扫结束时，若需要进入地图保存逻辑，则重新进入
        if !preState.cleanFinished && state?.cleanFinished == true && needEntrySaveMapLogicAfterBasicStateChanged {
            currentMapDidChanged(preMap: nil)
            saveMapLogic()
            needEntrySaveMapLogicAfterBasicStateChanged = false
        }
    }

    func mediaPlayerMapIDDidChanged(preMap: SweeperMap) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        currentMapDidChanged(preMap: preMap)

        /// 每次修改current map id 后， 地图的大小都会发生变化，故需要刷新初始地图的大小以适应屏幕
        mapView.restoreInitalMapView()
        mapView.shouldRefreshSize = true
        mapView.refreshView()
        mapView.updateCleanningModeAndSweepingState()
        mapView.updateCustomOrAutoMode()
        mapView.refreshAreaAndLabelView()
    }

    func mediaPlayerAlarm(type: SweeperAlarmType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        let alarm = SweeperAlarm(type: type)

        // 当前alarm需要在主页面显示、当基站升级、开关断开时不展示
        guard alarm.window.contains(.mainPage) && sweeperMechanicalOffView.isHidden && sweeperBaseUpgradingView.isHidden else {
            return
        }

        // 展示Toast
        if alarm.rank.contains(.toast),
           let message = alarm.toastTitle {
            ToastView.showWarningToast(title: message, existTime: nil, centerY: .low)
            return
        }

        // 展示Dialog，不展示只在基站展示的dialog
        if alarm.rank.contains(.dialog),
           !SweeperAlarm.baseDialogTypes.contains(type),
           let title = alarm.toastTitle {
            showAlertWith(title: title, message: alarm.toastContent, messageTextAlignment: .center, defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil, cancelButtonHandler: nil, defaultButtonHandler: nil)
            return
        }
    }
}

extension SweeperMainViewController: SweeperMapViewDataSource {
    func area(_ view: UIView, customCleanConfigurationIn areaID: Int) -> SweeperGlobalCleaningConfiguration? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaCleaningConfiguration
    }

    func area(_ view: UIView, infomationLayerMarkIn areaID: Int) -> String? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaLabel
    }

    func areaIDSet(_ in: UIView) -> [Int]? {
        return sweeperControl?.mapModel?.areaModel.areaIDs
    }

    func areaLabelLocation(_ view: UIView, areaID: Int) -> CGPoint? {
        return sweeperControl?.mapModel?.areaModel.areaLabelLocation[areaID]
    }

    func bitmapImage(_ view: UIView) -> CGImage? {
        return sweeperControl?.mapModel?.bitmapImage()
    }

    func bitmapOffset(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.offset
    }

    func bitmapSize(_ view: UIView) -> CGSize? {
        return sweeperControl?.mapModel?.bitmapSize
    }

    func areaData(_ view: UIView) -> [UInt8]? {
        return sweeperControl?.mapModel?.areaModel.areaData
    }

    func routeAllPointArray(_ view: UIView) -> [RoutePoint]? {
        return sweeperControl?.routeModel?.routePoints
    }

    func virtualWallIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.virtualWallModel?.wallIDs
    }

    func virutalWall(_ view: UIView, wallID: Int, isInEditMap: Bool) -> (CGPoint, CGPoint)? {
        return sweeperControl?.virtualWallModel?.couplePiontDictionary[wallID]
    }

    func forbiddenAreaIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.forbiddenAreaModel?.areaIDs
    }

    func forbiddenArea(_ view: UIView, areaID: Int, isInEditMap: Bool) -> RectangleArea? {
        return sweeperControl?.forbiddenAreaModel?.couplePiontDictionary[areaID]
    }

    func equipmentLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.routeModel?.equipmenLocation
    }

    func equipmentAngle(_ view: UIView) -> CGFloat? {
        return sweeperControl?.routeModel?.equipmenOritention
    }

    func chargePileLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.chargePileLocation
    }

    func barrierIDSet(_ view: UIView) -> [Int]? {
        if let keys = sweeperControl?.barriersModel?.barrierDictionary.keys {
            return Array(keys)
        } else {
            return nil
        }
    }

    func barrier(_ view: UIView, barrierModelIn barrierID: Int) -> SweeperBarrier? {
        return sweeperControl?.barriersModel?.barrierDictionary[barrierID]
    }

    func rectClean(_ view: UIView) -> (leftTopPoint: CGPoint, rightBottomPoint: CGPoint)? {
        if cleaningMode.leftTopPoint != .zero && cleaningMode.rightBottomPoint != .zero {
            return (cleaningMode.leftTopPoint, cleaningMode.rightBottomPoint)
        } else {
            return nil
        }
    }

    func mapScale(_ view: UIView) -> CGFloat? {
        return sweeperControl?.capability?.mapScale
    }
}

extension SweeperMainViewController: SweeperHomeMapViewDelegate {
    func hadMapFrame(_ view: SweeperHomeMapView) -> Bool? {
        return sweeperControl?.hadFrame
    }

    func areaSelected(_ view: SweeperHomeMapView) -> [Int]? {
        if cleaningModeType == .areaClean {
            return selectedLayerID
        } else {
            return nil
        }
    }

    func homeMapViewIsSetPreference(_ view: SweeperHomeMapView) -> Bool {
        return isSetPreference()
    }

    func homeMapViewIsSetSeq(_ view: SweeperHomeMapView) -> Bool {
        return isSetSweepSeq()
    }

    func layer(_ view: SweeperHomeMapView, layerSelectedSequence layerID: Int) -> Int? {
        if cleaningModeType == .areaClean, let orderID = selectedLayerID.firstIndex(of: layerID) {
            return orderID
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, layerCleaningOrder layerID: Int) -> Int? {
        if let order = sweeperControl?.mapModel?.areaModel.areaCleaningOrder,
           let orderID = order.firstIndex(of: layerID) {
            return orderID + 1
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, selectedLayer layerID: Int) {
        if let index = selectedLayerID.firstIndex(of: layerID) {
            selectedLayerID.remove(at: index)
        } else {
            selectedLayerID.append(layerID)
        }
        if cleaningModeType == .areaClean && !selectedLayerID.isEmpty {
            ToastView.showWarningToast(title: "已选择(selectedLayerID.count)个区域", existTime: nil, centerY: .low)
        }
        updateClearingAreaButton()
        mapView.refreshAreaAndLabelView()
    }
}

extension SweeperMainViewController {

    // 物体抓拍气泡展示
    private func captureBubbleViewShow(captureView: UIImageView, titleText: String, iconImage: UIImage, status: CaptureImageLoadingStatus, obstacleID: Int, thumbnail: UIImage? = nil) {
        sweepCaptureView.removeFromSuperview()
        captureBubbleViewLayout(captureView: captureView)
        sweepCaptureView.delegate = self

        // 更新障碍物抓拍气泡的展示
        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: thumbnail, obstacleID: obstacleID)

        // 更新障碍物抓拍是否有缩略图以及缩略图状态
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl?.barrierRecognitionEnabled ?? false, captureImageStatus: status)

        self.view.layoutIfNeeded()
        self.autoSuitPosition()
    }

    private func captureBubbleViewLayout(captureView: UIImageView) {
        self.mapView.addSubview(sweepCaptureView)
        sweepCaptureView.snp.remakeConstraints { make in
            make.centerX.equalTo(captureView.snp.centerX)
            make.bottom.equalTo(captureView.snp.top).offset(-12)
            make.width.equalTo(159)
            if sweeperControl?.barrierRecognitionEnabled ?? false {
                make.height.equalTo(128)
            } else {
                make.height.equalTo(40)
            }
        }
    }

    // 物体抓拍气泡隐藏
    private func captureBubbleViewDismiss() {
        sweepCaptureView.dismiss()
    }

    private func autoSuitPosition() {
        var offsetX: CGFloat = 0
        var offsetY: CGFloat = 0
        let maxXCoordinate = mapView.frame.width - sweepCaptureView.frame.width - 16
        if sweepCaptureView.frame.origin.x < 16 {
            offsetX = 16 - sweepCaptureView.frame.origin.x
        } else if sweepCaptureView.frame.origin.x > maxXCoordinate {
            offsetX = maxXCoordinate - sweepCaptureView.frame.origin.x
        }

        if sweepCaptureView.frame.origin.y < 16 {
            offsetY = 16 - sweepCaptureView.frame.origin.y
        }
        // 不用考虑底部超出边界，因为弹窗从顶部出现

        mapView.moveBy(x: offsetX, y: offsetY)
    }

    /// 刷新当前正在展示的气泡及其内容
    private func refreshBubbleView() {
        guard let sweeperControl = sweeperControl,
              let obstacleID = obstacleID,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              let iconImage = barrier.type.bigImage,
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            captureBubbleViewDismiss()
            return
        }
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
            return
        }

        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: .loading)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { [weak self] (status, image) in
            self?.sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: image, obstacleID: obstacleID)
            self?.sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: status)
        }
    }

}

extension SweeperMainViewController: SweeperMapManagerViewControllerDelegate {
    func mapManagerBeginSweep(_ controller: SweeperMapManagerViewController) {
        // 强制扫地机进入新建地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .autoClean)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    func mapManagerFastMap(_ controller: SweeperMapManagerViewController) {
        // 开始快速建图
        startFastMapAlert()
    }
}

extension SweeperMainViewController: SweeperCaptureBubbleViewDelegate {
    func captureNextButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.titleLabel.textColor = UIColor.black.withAlphaComponent(0.5)
        // 获取全部障碍物的详情页
        let sweepCaptureNextPageViewController = SweeperCaptureNextPageViewController(deviceID: deviceID, listType: listType)
        sweepCaptureNextPageViewController.delegate = self

        // 更新详情页跳转到具体哪个页面
        sweepCaptureNextPageViewController.obstacleID = captureView.obstacleID
        self.navigationController?.pushViewController(sweepCaptureNextPageViewController, animated: true)
    }

    func reloadButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.imageStatus = .loading
        let barrierID = captureView.obstacleID
        guard let fileID = sweeperControl?.barriersModel?.barrierDictionary[barrierID]?.fileID else {
            return captureView.imageStatus = .loadNoImage
        }

        SweeperDownloader.downloadObstacleImage(forDevice: deviceID, listType: listType, fileID: fileID) { status, image in
            captureView.imageStatus = status
            captureView.titleImageView.image = image
        }
    }

    func handleGestures(enable: Bool) {
        mapView.isGestureEnable = enable
    }
}

extension SweeperMainViewController: SweeperMainMapLoadingViewDelegate {
    func reloadButtonDidClick(_ UIView: SweeperMainMapLoadingView) {
        refreshMediaPlayerAndSweeperControl()
    }
}

extension SweeperMainViewController: SweeperIconMapViewDelegate {
    func didTapBaseStation(in view: SweeperIconMapView) {
        baseStationButtonDidClick()
    }

    func iconMap(_ view: SweeperIconMapView, transforToScreenPointFrom realPoint: CGPoint) -> CGPoint? {
        // 之前未调用
        return nil
    }

    func didTapObstacle(in view: UIImageView, obstacleID: Int) {

        guard let sweeperControl = sweeperControl,
              let iconImage = sweeperControl.barriersModel?.barrierDictionary[obstacleID]?.type.bigImage,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            return
        }
        self.obstacleID = obstacleID
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loadNoImage, obstacleID: obstacleID)
            return
        }

        self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loading, obstacleID: obstacleID)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { status, image in
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: status, obstacleID: obstacleID, thumbnail: image)
        }
    }
}

extension SweeperMainViewController: SweeperNewPasswordProtocol {
    func checkUnAuthenticated() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperModule.shared.requiredService?.checkUserInfo(deviceID: deviceID, listType: listType, completion: { [weak self] (success, errorCode) in
            ToastView.dismissLoadingToast()
            guard let self = self else {
                return
            }
            if success {
                self.goToPreview()
                return
            }

            if errorCode == TPSS_ASYNC_EC_TIMEOUT || errorCode == TPSS_COMM_EC_SYSTEM {
                /* 请求超时 */
                ToastView.showWarningToast(warningMessage: "网络错误")
                return
            }

            /* 设备锁定 */
            if errorCode == TPSS_COMM_EC_PREVIEW_LOCKED {
                self.showAlertWith(title: SharedResource.sharedString(key: sweeperPreviewLockedAlertTitle), defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil)
                return
            }

            /* 鉴权失败,弹出密码输入框 */
            self.presentInputPasswordVC(deviceID: self.deviceID, listType: self.listType)

        })
    }
}

extension SweeperMainViewController: SweeperVerifyPasswordProtocol {
    func verifySuccessHandler() {
        goToPreview()
    }
}

extension SweeperMainViewController: SweeperCaptureNextPageViewControllerDelegate {
    func ignoreButtonDidClick(sweeperCaptureNextPageViewController: SweeperCaptureNextPageViewController, barrierID: Int) {
        // 点击障碍物抓拍详情页的“忽略”所对应的障碍物Id
        guard let mapID = map?.currentMapID else {
             return
        }
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestIgnoreBarrier(device: deviceID, channel: channel, listType: listType, barrierID: "(barrierID)", mapID: mapID).always {
            ToastView.dismissLoadingToast()
        }.then { [weak self] (_) in
            ToastView.showWarningToast(warningMessage: "已忽略该物体")
            self?.sweepCaptureView.dismiss()
            self?.goBackToSweeperMainViewController()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperMechanicalOffViewDelegate {
    func refreshButtonDidClick(in: SweeperMechanicalOffView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        sweeperMechanicalOffView.refreshLoadingUI(connectedState: .loading)
        view.bringSubviewToFront(sweeperMechanicalOffView)
        SweeperService.getSweeperState(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType).then { [weak self] (state) in
            guard let state = state else {
                return
            }
            self?.showMechanicalOffView(switchOn: state.mechanicalSwitchOn)
        }
    }

    func showMechanicalOffView(switchOn: Bool) {
        // 若开关关闭
        if !switchOn {
            isShowingMechanicalView = true
            sweeperMechanicalOffView.refreshLoadingUI(connectedState: .off)
        } else {
            isShowingMechanicalView = false
        }
    }
}

extension SweeperMainViewController: SweeperMoreActionViewControllerDelegate {
    func cleanWholeHouse(in vc: SweeperMoreActionViewController) {
        showSweepTipsAlert()
    }
}

extension SweeperMainViewController: SweeperFastMapSheetDelegate {
    func startFastMap(view: SweeperFastMapSheet) {
        startFastMapAlert()
    }
}

extension String {
    func separatedBySemiColon(isAutoFill: Bool = true) -> (String, String?) {
        let seperator = self.contains(":") ? ":" : "："
        let separatedTexts: [String] = self.components(separatedBy: seperator)
        if !isAutoFill && separatedTexts.count == 1 {
            return (separatedTexts[0], nil)
        } else {
            return (separatedTexts.count >= 1 ? separatedTexts[0] : "", separatedTexts.count >= 2 ? separatedTexts[1] : "")
        }
    }
}
//
//  OnlineDeviceListMasterViewController.swift
//  SurveillanceHome
//
//  Created by Li Linfeng on 2019/12/9.
//  Copyright © 2019 tplink. All rights reserved.
//

import UIKit
import SurveillanceHomeBase
import SharedResource
import TPFoundation
import DeviceDetailModule
import NetService

private var pageIndexAssociatedObjectHandle: UInt8 = 0

final class OnlineDeviceListMasterViewController: BaseViewController {
    @IBOutlet private weak var groupCollectionView: UICollectionView!
    @IBOutlet private weak var groupToolbarShadowView: UIView!
    @IBOutlet private weak var groupToolbarContainer: UIView!
    @IBOutlet private weak var groupToolbarDropMenuButton: UIButton!
    @IBOutlet private weak var recentPreviewView: RecentPreviewView!
    @IBOutlet private weak var containerViewBottom2SuperViewBottomConstraint: NSLayoutConstraint!
    @IBOutlet private weak var containerViewTop2TopLayoutGuideBottomConstraint: NSLayoutConstraint!

    override var navigationBarTraits: [NavigationBarTrait] {
        return NavigationBarTrait.noSeparator
    }

    private var deviceGroups: [TPSSDeviceGroup] = []
    private var currentGroupIndex: Int = 0

    private var newCreateGroupName = ""

    private var pageController: UIPageViewController!
    private var deviceListVCCacheDictionary = [TPSSDeviceGroupID: OnlineDeviceListViewController]()
    private var transitionVCForPageController = UIViewController()
    lazy private var loginCacheVC = DeviceListLoginViewController.create()

    private var firstAppear = true
    private var shouldRecreate: Bool = false

    /// for routers' entry
    private var isLoginBefore = false

    var sdCardStatusShowed: SDCardStatusShowed = .none
    var diskStatusShowed: SDCardStatusShowed = .none

    // camera display
    private var shouldShowCameraDisplayNoActiveChannelAlert = false
    private var addChannelCameraDisplay: TPSSDeviceForDeviceList?

    // navigation
    private lazy var moreToolBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(moreToolsButtonClicked(_:)))
    }()

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_add_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(addDeviceButtonClicked(_:)))
    }()

    // MARK: guides and overlays
    private weak var addDeviceGuideView: GuidePresentationView?
    private weak var moreToolsPopoverView: GuidePresentationView?

    private lazy var groupPresenter = GroupListPresentationManager()
    private var presentedGroupList: GroupListViewController? {
        return presentedViewController as? GroupListViewController
    }

    private var currentList: OnlineDeviceListViewController {
        if let viewControllers = pageController.viewControllers, let firstViewController = viewControllers.first as? OnlineDeviceListViewController {
            return firstViewController
        }
        return OnlineDeviceListViewController()
    }

    private var isCloudLogin: Bool {
        return DeviceListModule.shared.requiredService?.isCloudLogin ?? false
    }

    private var isReordering = false                // 是否正在处于排序模式
    private var shouldToggleGroupModeAfterGetList = false   // 是否需要在获取列表结束后切换防护模式，仅在列表还未获取完时触发防护模式切换使用

    private var isShowing: Bool {
        return isShowing(ignorePresentedClasses: [UIAlertController.classForCoder()])
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        setupView()

        NotificationCenter.default.addObserver(self, selector: #selector(handleShowCameraDisplayNoActiveChannelAlertNotification(_:)), name: .ShowCameraDisplayNoActiveChannelAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleShowStorageDetectAlertNotification(_:)), name: .ShowStorageDetectAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListInvalidated), name: .DeviceListInvalidated, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListUpdated), name: .DeviceListUpdated, object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderBegined(_:)),
                                               name: .DeviceListReorderBegined,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderEnded(_:)),
                                               name: .DeviceListReorderEnded,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupAndDeviceList(_:)),
                                               name: .UpdateGroupAndDeviceListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: DeviceListNetworkObserver.localDeviceRefreshed,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupList(_:)),
                                               name: .UpdateGroupListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: .unbindDiscoveryFinished,
                                               object: nil)

        _ = DeviceListModule.shared.requiredService?.addEntrustObserver(observeTypes: [.entrustmentStop, .entrustmentExitByTrustee], { (_, _) in
            DeviceListManager.shared.updateDeviceList(of: DeviceListManager.shared.defaultGroupID).always {
                self.currentList.reload()
            }
        })
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        showGroupAndNavigationButton(true)
        if !isCloudLogin {
            showEmpty()
        } else if firstAppear {
            firstAppear = false
            restore()
        } else if shouldRecreate {
            shouldRecreate = false
            reload()
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        checkUpdateIfNeeded()

        if isCloudLogin {
            showPopoverGuideIfNeeded()
        }

        if shouldShowCameraDisplayNoActiveChannelAlert {
            shouldShowCameraDisplayNoActiveChannelAlert = false
            showCameraDisplayNoActiveChannelAlert()
        }
        updateGroupShadow()
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)

        dismissPresentedViews()
    }

    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let vc = segue.destination as? UIPageViewController {
            pageController = vc
            pageController.dataSource = self
            pageController.delegate = self
        }
    }

    private func refreshAfterGroupUpdated() {
        guard !isReordering else {
            return
        }

        guard isShowing else {
            // 如果分组刷新完，此时页面不是正在显示，则不进行页面刷新，仅记录状态，等回到本页面才统一进行刷新。
            // 需要注意通过记录状态后续回到页面才处理的逻辑，要与本方法后续处理逻辑要保持一致
            shouldRecreate = true
            return
        }

        reload()
    }

    private func showEmpty() {
        deviceGroups = []
        currentGroupIndex = -1

        showGroupAndNavigationButton(false)

        let emptyVC: UIViewController?
        // 有发现出来的/已绑定到局域网的设备时显示带登陆按钮的设备列表；没有则显示普通的登陆提示页
        if DeviceListManager.shared.unbindDetailDeviceList().count > 0 {
            emptyVC = createUnloginPage()
        } else {
            emptyVC = loginCacheVC
        }
        if let emptyVC = emptyVC {
            pageController.setViewControllers([emptyVC], direction: .forward, animated: false, completion: nil)
        }
        groupCollectionView.reloadData()
    }

    private func showGroupAndNavigationButton(_ shouldShow: Bool) {
        if shouldShow {
            navigationItem.leftBarButtonItem = moreToolBarButtonItem
            groupToolbarDropMenuButton.isHidden = false
        } else {
            navigationItem.leftBarButtonItem = nil
            groupToolbarDropMenuButton.isHidden = true
        }
    }

    private func restore() {
        deviceGroups = DeviceListManager.shared.groupList

        loadGroup(with: DeviceListManager.shared.lastSelectedGroupID)
    }

    private func reload(with preferredGroupID: String? = nil) {
        let oldGroupID = preferredGroupID ?? DeviceListManager.shared.lastSelectedGroupID
        deviceGroups = DeviceListManager.shared.groupList
        presentedGroupList?.groups = deviceGroups

        loadGroup(with: oldGroupID)
    }

    private func loadGroup(with groupID: String) {
        let currentGroup = DeviceListManager.shared.group(of: groupID) ?? DeviceListManager.shared.defaultGroup

        guard let groupIndex = deviceGroups.firstIndex(where: { $0.groupID == currentGroup.groupID }) else {
            return
        }

        currentGroupIndex = groupIndex

        presentedGroupList?.currentGroupID = currentGroup.groupID
        presentedGroupList?.reload()

        commonLoad()
    }

    private func commonLoad(animated: Bool = false, recreate: Bool = true) {
        groupCollectionView.reloadData()

        guard currentGroupIndex >= 0 else {
            return
        }

        groupCollectionView.scrollToItem(at: IndexPath(item: currentGroupIndex, section: 0), at: .right, animated: false)
        updateGroupShadow()

        if recreate, let vc = createPage(for: currentGroupIndex) {
            pageController.setViewControllers([vc], direction: .forward, animated: false, completion: nil)
        }

        storeGroupParameter()
    }

    private func updateGroupShadow() {
        groupToolbarShadowView.isHidden = groupCollectionView.bounds.maxX >= (groupCollectionView.contentSize.width - 1)
    }

    private func refreshAllDeviceLists() {
        if let viewController = pageController.viewControllers {
            viewController.forEach {
                if let vc = $0 as? OnlineDeviceListViewController {
                    vc.reload()
                }
            }
        }
    }

    private func createPage(for index: Int) -> OnlineDeviceListViewController? {
        let group = deviceGroups[index]
        guard let vc = createPage(for: group.groupID as TPSSDeviceGroupID) else {
            return nil
        }
        objc_setAssociatedObject(vc, &pageIndexAssociatedObjectHandle, index, .OBJC_ASSOCIATION_COPY_NONATOMIC)
        vc.realGroup = deviceGroups[index]
        return vc
    }

    private func createUnloginPage() -> OnlineDeviceListViewController? {
        return createPage(for: "unlogin page")
    }

    private func createPage(for key: TPSSDeviceGroupID) -> OnlineDeviceListViewController? {
        let vc: OnlineDeviceListViewController?
        if let item = deviceListVCCacheDictionary[key] {
            vc = item
        } else {
            vc = OnlineDeviceListViewController.create()
            deviceListVCCacheDictionary[key] = vc
        }
        return vc
    }
}

extension OnlineDeviceListMasterViewController: DeviceListUnwindDestination {}

// MARK: Popover handler
extension OnlineDeviceListMasterViewController {
    private func updateMenu() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let networkAvailable = NetworkManager.shared.isConnected
        let isInHomeMode = deviceGroups[currentGroupIndex].activeMode != .goOut
        let isBigCardMode = deviceGroups[currentGroupIndex].displayMode != .smallCard
        let homeModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_home_active") : DeviceListModule.image(named: "devicelist_home_disabled")
        let outModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_out_active") : DeviceListModule.image(named: "devicelist_out_disabled")
        DeviceGroupMenuItem.alarmMode.image = (isInHomeMode ? homeModeImage : outModeImage)?.withRenderingMode(.alwaysOriginal)
        DeviceGroupMenuItem.alarmMode.enabled = networkAvailable
        DeviceGroupMenuItem.alarmMode.title = isInHomeMode ? LocalizedString(key: deviceListModeHome) : LocalizedString(key: deviceListModeOut)
        DeviceGroupMenuItem.alarmMode.subtitle = isInHomeMode ? LocalizedString(key: deviceListSwitchModeToOut) : LocalizedString(key: deviceListSwitchModeToHome)
        DeviceGroupMenuItem.viewMode.title = isBigCardMode ? LocalizedString(key: deviceListViewGrid) : LocalizedString(key: deviceListViewList)
        DeviceGroupMenuItem.viewMode.subtitle = isBigCardMode ? LocalizedString(key: deviceListSwitchViewToList) : LocalizedString(key: deviceListSwitchViewToGrid)
        DeviceGroupMenuItem.viewMode.image = isBigCardMode ?  DeviceListModule.image(named: "devicelist_grid")?.withRenderingMode(.alwaysOriginal) : DeviceListModule.image(named: "devicelist_list")?.withRenderingMode(.alwaysOriginal)
    }

    private func handleDeviceGroupMenu(item: DeviceGroupMenuView.Item) {
        switch item {
        case .alarmMode:
            toggleGroupMode()
        case .search:
            navigateToSearch()
        case .viewMode:
            toggleDisplayMode()
        }
    }

    private func toggleGroupMode() {
        dismissPresentedViews()

        let deviceListUpdateStatus = DeviceListManager.shared.deviceListUpdateStatus
        if !deviceListUpdateStatus.cloudUpdateNecessaryInfoFinished {
            // 列表必要信息没获取到，此时若需要改变防护模式，就先请求获取数据并且loading，等所有信息获取完处理，避免数据不完整导致处理出错
            if !deviceListUpdateStatus.isUpdatingList {
                DeviceListManager.shared.updateGroupAndDeviceList()
            }
            shouldToggleGroupModeAfterGetList = true
            ToastView.showLoadingToast(cirleWithMessage: nil)
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.activeMode
        let newMode = group.activeMode == .goOut ? TPSSDeviceGroupMode.atHome : .goOut
        group.activeMode = newMode
        ToastView.showLoadingToast(cirleWithMessage: nil)
        DeviceListManager.shared.changeActiveMode(with: deviceGroups[currentGroupIndex]).then { () in
            self.currentList.reload()
            self.currentList.showToastForActiveMode(newMode)
        }.catch { (_) in
            group.activeMode = originalMode
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func toggleDisplayMode() {
        dismissPresentedViews()

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.displayMode
        let newMode = originalMode == .bigCard ? DeviceUIDisplayType.smallCard : .bigCard

        DeviceListManager.shared.changeDisplayMode(for: group.groupID, with: newMode)

        for section in 0..<currentList.collectionView.numberOfSections {
            for item in 0..<currentList.collectionView.numberOfItems(inSection: section) {
                if newMode == .smallCard {
                    currentList.fold(at: IndexPath(row: item, section: section))
                } else {
                    currentList.unfold(at: IndexPath(row: item, section: section))
                }
            }
        }

        currentList.reload()
    }

    private func navigateToSearch() {
        dismissPresentedViews()
        let allDevices = DeviceListManager.shared.allDetailDevices
        let allGroups = DeviceListManager.shared.groupList
        let vc = RemoteDeviceListSearchViewController(devices: allDevices, groups: allGroups)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }
}

extension OnlineDeviceListMasterViewController {
    // MARK: Popover
    private func showPopoverGuideIfNeeded() {
        // add device popover
        if UserDefaults.standard.object(forKey: deviceListLaunchKey) == nil {
            showAddDevicePopover()
            UserDefaults.standard.set(true, forKey: deviceListLaunchKey)
        }
    }

    private func showAddDevicePopover() {
        if !isShowing() {
            /* 如果界面切换了不要加载 */
            return
        }
        if let source = (navigationItem.rightBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            navigationController?.navigationBar.layoutIfNeeded()
            dismissPresentedViews()
            addDeviceGuideView = presentGuideWith(viewToPresent: TutorialGuideView.addDevice, size: TutorialGuideView.addDevice.frame.size, source: source, clickThrough: true)
            addDeviceGuideView?.delegate = self
        }
    }
}

extension OnlineDeviceListMasterViewController: GuidePresentationViewDelegate {
    func guidePresentationViewDidDismiss(_ view: GuidePresentationView) {
        if view == moreToolsPopoverView {
            navigationItem.leftBarButtonItem?.tintColor = UIColor(white: 0, alpha: 0.8)
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        }
    }
}

// MARK: - util
extension OnlineDeviceListMasterViewController {
    private func storeGroupParameter() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        DeviceListManager.shared.updateLastSelectGroupID(deviceGroups[currentGroupIndex].groupID)
    }
}

extension OnlineDeviceListMasterViewController {

    private func presentUpgradeInfo(appVersionInfo: AppUpgradeModuleBaseUpgradeInfo) {
        let alertViewController = DeviceListUpgradeAlertController(versionInfo: appVersionInfo)
        present(alertViewController, animated: true, completion: nil)
    }

    private func checkUpdateIfNeeded() {
        let requiredService = DeviceListModule.shared.requiredService
        guard requiredService?.shouldShowNewAppVersion() ?? false else {
            return
        }

        // 仅跳转至需要更新的包中（若对应版本的升级包needNotify为false，而另外版本的needNotify为true，会跳转至另一版本）
        if TPAppUtils.isTestFlightBeta() {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, appVersionInfo.needNotify, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        } else {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo, appVersionInfo.needNotify {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        }

    }
}

extension OnlineDeviceListMasterViewController: DeviceListSearchViewControllerDelegate {
    func navigateToGroup(group: TPSSDeviceGroup) {
        navigationController?.popViewController(animated: true)
        DispatchQueue.main.async {
            self.loadGroup(with: group.groupID)
        }
    }

    func navigateToSyncPreviewViewController(device: DeviceDetail) {
        goToSyncPreview(ipc: device, listType: device.listType)
    }

    func navigateToPreviewViewController(device: DeviceDetail, channel: TPSSChannelInfo?) {
        if device.deviceType == .smartLock {
            DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
            return
        }
        goToPreview(device: device, channel: channel)
    }

    func navigateToBatteryDoorbellViewController(device: DeviceDetail, fromNVR nvr: (deviceID: TPSSDeviceIdentifier, channel: UInt)?) {
        DeviceListModule.shared.requiredService?.navigateToBatteryDoorbellViewController(for: device.identifier, group: DeviceListManager.shared.defaultGroupID, listType: device.listType, navigator: navigationController, from: nvr?.deviceID, channelInNVR: nvr?.channel.intValue)
    }

    func navigateToNVRViewController(nvr: DeviceDetail) {
        var groupId = DeviceListManager.shared.defaultGroup.groupID
        if currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex {
            groupId  = deviceGroups[currentGroupIndex].groupID
        }
        goToNVR(nvr: nvr, groupID: groupId)
    }

    func navigateToSolarControllerManagerViewController(device: DeviceDetail) {
        goToSolarController(solarController: device)
    }

    func navigateToRouterManagerViewController(device: DeviceDetail) {
        goToRouter(device: device)
    }

    func navigateToSmartLockViewController(device: DeviceDetail) {
        DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
    }
}

// MARK: Navigation
extension OnlineDeviceListMasterViewController: PreviewControllerEntrance {
    func goToPreview(device: DeviceDetail, channel: TPSSChannelInfo?) {
        goToPreview(deviceID: device.identifier, channelID: channel?.channelId.intValue ?? -1, listType: device.listType)
    }

    func goToNVR(nvr: DeviceDetail, groupID: String? = nil) {
        let vc = NVRTabViewController()
        vc.cloudIdentifier = nvr.cloudDeviceID
        vc.deviceIdentifier = nvr.identifier
        vc.listType = nvr.listType
        vc.groupId = groupID
        navigationController?.pushViewController(vc, animated: true)
    }

    func goToSolarController(solarController: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToSolarControllerManagerViewController(deviceID: solarController.identifier, listType: solarController.listType, navigator: navigationController)
    }

    func goToRouter(device: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToRouterDefault(mac: device.mac, listType: device.listType, isOnline: device.online, navigator: navigationController)
    }
}

// MARK: Actions
extension OnlineDeviceListMasterViewController {
    private func dismissPresentedViews() {
        addDeviceGuideView?.dismiss()
        moreToolsPopoverView?.dismiss()

        presentedGroupList?.dismiss(animated: true, completion: nil)

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }

    @IBAction private func addDeviceButtonClicked(_ sender: Any) {
        guard isCloudLogin else {
            showAlertWith(title: LocalizedString(key: deviceListNotLogin), defaultButtonTitle: LocalizedString(key: deviceListLogin), defaultButtonHandler: { (_) in
                DeviceListModule.shared.requiredService?.navigateToLoginViewController(navigator: self.navigationController)
            })
            return
        }
        dismissPresentedViews()

        DeviceListModule.shared.requiredService?.presentDeviceAddViewController(viewController: self, listType: listType)
    }

    @IBAction private func moreToolsButtonClicked(_ sender: Any) {
        guard isCloudLogin else { return }

        if moreToolsPopoverView != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let size = CGSize(width: 212, height: 16 + DeviceGroupMenuView.Item.allCases.count * 44)
        let menuView = DeviceGroupMenuView(frame: CGRect(origin: .zero, size: size))
        menuView.action = handleDeviceGroupMenu

        dismissPresentedViews()

        updateMenu()

        if let source = (navigationItem.leftBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
            menuView.configurePopoverShadow(cornerRadius: 8)
            moreToolsPopoverView = presentGuideWith(viewToPresent: menuView, size: size, backgroundColor: .clear, source: source, offset: CGPoint(x: -12, y: 4))
            moreToolsPopoverView?.delegate = self
        }
        navigationItem.leftBarButtonItem?.tintColor = .theme1
    }

    @IBAction private func groupMenuToggled(_ sender: UIButton) {
        guard isCloudLogin else { return }

        if presentedViewController != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_up_small_normal"), for: .normal)

        let groups = DeviceListManager.shared.groupList
        guard let vc = GroupListViewController.create() else {
            return
        }
        let height = CGFloat(groups.count) * 52 + 72
        vc.preferredContentSize = CGSize(width: UIScreen.main.bounds.width, height: height)
        vc.modalPresentationStyle = .custom
        vc.transitioningDelegate = groupPresenter
        vc.groups = groups
        vc.currentGroupID = deviceGroups[currentGroupIndex].groupID
        vc.delegate = self
        present(vc, animated: true, completion: nil)
    }

    @IBAction private func recentPreviewClicked(_ sender: Any) {
        // 不会用到此按钮，但暂时保留
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDataSource {
    private func groupInformation(at index: Int) -> (String, Bool) {
        if deviceGroups.isEmpty { return (LocalizedString(key: deviceListMyDevice), true) }
        return (deviceGroups[index].groupName, index == currentGroupIndex)
    }

    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }

    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return max(1, deviceGroups.count)
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        return collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)
    }
}

extension OnlineDeviceListMasterViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        updateGroupShadow()
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDelegate {
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        if deviceGroups.isEmpty { return }
        dismissPresentedViews()
        loadGroup(with: deviceGroups[indexPath.item].groupID)
    }
}

extension OnlineDeviceListMasterViewController: DeviceGroupNameLayoutDelegate {
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, groupForItemAt indexPath: IndexPath) -> (name: String, selected: Bool) {
        return groupInformation(at: indexPath.item)
    }
}

// MARK: Page Management
extension OnlineDeviceListMasterViewController: UIPageViewControllerDataSource {
    func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex > 0 && currentGroupIndex < deviceGroups.count else { return nil }
        return createPage(for: currentGroupIndex - 1)
    }

    func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex >= 0 && currentGroupIndex < deviceGroups.count - 1 else { return nil }
        return createPage(for: currentGroupIndex + 1)
    }
}

extension OnlineDeviceListMasterViewController: UIPageViewControllerDelegate {
    func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
        if completed {
            if let viewControllers = pageViewController.viewControllers, let firtViewController = viewControllers.first {
                if let currentGroupIndex = objc_getAssociatedObject(firtViewController, &pageIndexAssociatedObjectHandle) as? Int {
                    self.currentGroupIndex = currentGroupIndex
                    commonLoad(animated: true, recreate: false)
                }
            }
        }
    }
}

// MARK: Group Management
extension OnlineDeviceListMasterViewController: GroupListViewControllerDelegate {
    func groupListViewController(_ groupListViewController: GroupListViewController, canMoveGroupTo destinationIndex: Int) -> Bool {
        guard deviceGroups.count > destinationIndex else {
            return false
        }
        let group = deviceGroups[destinationIndex]
        return !group.isDefaultGroup
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didMoveGroupAt sourceIndex: Int, to destinationIndex: Int) {
        // check if current group index has changed
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let originalGroup = deviceGroups[currentGroupIndex]
        deviceGroups.swapAt(sourceIndex, destinationIndex)
        if let newIndex = deviceGroups.firstIndex(of: originalGroup), currentGroupIndex != newIndex {
            currentGroupIndex = newIndex
        }
        // always invalidate page controller cache
        pageController.setViewControllers([currentList], direction: .forward, animated: false, completion: nil)
        groupCollectionView.moveItem(at: IndexPath(item: sourceIndex, section: 0), to: IndexPath(item: destinationIndex, section: 0))
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didSelectGroupAt index: Int) {
        dismissPresentedViews()
        loadGroup(with: deviceGroups[index].groupID)
    }

    func groupListViewControllerDidSelectCreatingNewGroup(_ groupListViewController: GroupListViewController) {
        dismissPresentedViews()
        guard let vc = CommonNameInputViewController.create() else {
            return
        }
        vc.navigationTitle = LocalizedString(key: deviceListSetGroupNameTitle)
        vc.doneButtonTitle = LocalizedString(key: commonNextStep)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didRequestEditingGroupAt index: Int) {
        dismissPresentedViews()
        guard let vc = GroupSettingViewController.create() else {
            return
        }
        vc.group = deviceGroups[index]
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewControllerDidDismiss(_ groupListViewController: GroupListViewController) {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
        _ = DeviceListManager.shared.updateGroupOrder(newGroup: deviceGroups)
    }
}

extension OnlineDeviceListMasterViewController: CommonNameInputViewControllerDelegate {
    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didCancelWith text: String) {
        navigationController?.popViewController(animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didFinishWith text: String) {
        guard deviceGroups.count > 0 else {
            navigationController?.popToViewController(self, animated: true)
            return
        }
        newCreateGroupName = text
        let vc = DeviceSelectionViewController(entry: .groupAddIndependent, group: DeviceListManager.shared.defaultGroupID, canProceedWithNoSelection: true)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, errorMessageFor text: String) -> (allowed: Bool, message: String?) {
        let error = TPSSDeviceListValidate.validateDeviceGroupName(text)
        if error != nil {
            return (true, error?.message)
        }

        if DeviceListManager.shared.groupList.contains(where: { $0.groupName == text }) {
            return (true, LocalizedString(key: deviceListNameExists))
        }
        return (true, nil)
    }

    func placeholderForNameInputViewController(_ nameInputViewController: CommonNameInputViewController) -> String? {
        return SharedResource.sharedString(key: shareStringLengthConstraint)
    }
}

extension OnlineDeviceListMasterViewController {
    @objc func handleShowCameraDisplayNoActiveChannelAlertNotification(_ noti: NSNotification) {
        if let (device, listType) = noti.object as? (DeviceDetail, TPSSDeviceListType), listType == .remote {
            shouldShowCameraDisplayNoActiveChannelAlert = true
            addChannelCameraDisplay = DeviceListManager.shared.device(with: device.identifier)
        }
    }

    @objc func handleShowStorageDetectAlertNotification(_ noti: NSNotification) {
        diskStatusShowed = .none
        sdCardStatusShowed = .none
    }

    private func showCameraDisplayNoActiveChannelAlert() {
        showAlertWith(title: LocalizedString(key: deviceAddCameraDisplayNoActiveChannelsTitle), defaultButtonTitle: LocalizedString(key: deviceAddAddNext), cancelButtonTitle: LocalizedString(key: commonNotNow), cancelButtonHandler: nil) { (_) in
            if let cameraDisplay = self.addChannelCameraDisplay {
                DeviceListModule.shared.requiredService?.navigateToCameraDisplayDiscoverViewController(deviceID: cameraDisplay.identifier, discoverType: .cameraDisplay, listType: self.listType, navigator: self.navigationController)
                // 需要在中间插一个ViewController
                let vc = NVRTabViewController()
                vc.cloudIdentifier = cameraDisplay.cloudDeviceId
                vc.deviceIdentifier = cameraDisplay.identifier
                vc.listType = .remote
                vc.hidesBottomBarWhenPushed = true
                if var tmpViewControllers = self.tpNavigationController?.viewControllers {
                    tmpViewControllers.insert(vc, at: tmpViewControllers.count - 1)
                    self.tpNavigationController?.setViewControllers(tmpViewControllers, animated: true)
                }
            }
        }
    }
}

extension OnlineDeviceListMasterViewController: DeviceSDCardStatusChecker {
    var listType: TPSSDeviceListType { return .remote }

    func formatProcessDidFinish() {
        currentList.reload()
    }
}

extension OnlineDeviceListMasterViewController: DeviceSelectionViewControllerDelegate {
    func deviceSelectionViewController(_ deviceSelectionViewController: DeviceSelectionViewController, didPressRightBarButtonItemWithDeviceChannels selectedDeviceChannels: [DeviceDetail: [ChannelId]]) {
        switch deviceSelectionViewController.entryType {
        case .groupAddIndependent:
            ToastView.showLoadingToast(cirleWithMessage: nil)

            let targetDeviceChannels = DeviceSelectionViewController.covertDeviceChannel(selectedDeviceChannels)
            DeviceListManager.shared.createGroup(name: newCreateGroupName, deviceChannelMap: targetDeviceChannels).always {
                ToastView.dismissLoadingToast()
            }.then { (groupID) in
                self.navigationController?.popToViewController(self, animated: true)
                self.reload(with: groupID)
            }.catch { (error) in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }
        default:
            break
        }
    }
}

// MARK: - notification
extension OnlineDeviceListMasterViewController {
    @objc private func handleDeviceListInvalidated() {
        shouldRecreate = true
        deviceListVCCacheDictionary.removeAll()
    }

    @objc private func handleDeviceListUpdated() {
        showUpdateAlertIfAny()
    }

    @objc private func handleReorderBegined(_ notification: Notification) {
        enterReorderMode()
    }

    @objc private func handleReorderEnded(_ notification: Notification) {
        exitReorderMode()
    }

    @objc private func handleUpdateGroupAndDeviceList(_ notification: Notification) {
        if isCloudLogin {
            handleGroupModeToggleAfterGetList(notification)
        } else if isShowing {
            // 处理非登录场景

            // 仅页面正在显示才处理数据获取结果更新页面状态，否则等viewWillAppear再处理。避免正在获取列表
            // 时切换到其它页面，列表获取有结果后触发本逻辑使得子VC触发viewWillAppear，后续真正展示页面时
            // 就不再触发viewWillAppear导致数据异常
            showEmpty()
        }
    }

    @objc private func handleLocalDeviceRefreshed(_ notification: Notification) {
        if !isCloudLogin && isShowing {
            // 非登录且页面正在显示时才需要处理因网络状态变化重新发现完的通知，因为此时可能需要在有/无设备的页面之间切换。
            // 如果页面没有在显示则不需要处理，因为viewWillAppear会触发该逻辑
            showEmpty()
        }
    }

    @objc private func handleUpdateGroupList(_ notification: Notification) {
        if let dic = notification.object as? [String: Any],
           let error = dic[DeviceListManager.notificationKeyError] as? Error {
            ToastView.showWarningToast(title: error.localizedDescription, existTime: nil, centerY: .lowest)
            return
        }
        // 失败也更新，此时显示默认分组
        refreshAfterGroupUpdated()
    }

    private func handleGroupModeToggleAfterGetList(_ notification: Notification) {
        let finishHandler: (() -> Void) = {
            if self.shouldToggleGroupModeAfterGetList {
                ToastView.dismissLoadingToast()
                self.shouldToggleGroupModeAfterGetList = false
                self.toggleGroupMode()
            }
        }

        guard let dic = notification.object as? [String: Any],
              let status = dic[DeviceListManager.notificationKeyListUpdateStatus] as? DeviceListUpdateStatus else {
            finishHandler()
            return
        }

        if status.cloudUpdateNecessaryInfoFinished {
            finishHandler()
        }
    }
}

extension OnlineDeviceListMasterViewController: Storyboarded {
    static var storyboardName: String { return "DeviceList" }
    static var storyboardBundle: Bundle? { return Bundle.deviceListModuelBundle }
}

extension Notification.Name {
    static var DeviceListUpdated: Notification.Name { return Notification.Name("DeviceListUpdated") }
}

// MARK: - setup
extension OnlineDeviceListMasterViewController {
    private func setupView() {
        setupBarButtonItems()
        setupButtons()
    }

    private func setupBarButtonItems() {
        navigationItem.leftBarButtonItem = moreToolBarButtonItem
        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
    }

    private func setupButtons() {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }
}

// MARK: - reorder
extension OnlineDeviceListMasterViewController {
    // 本vc不会主动进入排序模式，而是依赖于OnlineDeviceListViewController的通知
    private func enterReorderMode() {
        isReordering = true
        tabBarController?.tabBar.isUserInteractionEnabled = false
        groupToolbarContainer.isUserInteractionEnabled = false

        pageController.scrollEnable = false

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
    }

    private func showUpdateAlertIfAny() {
        if DeviceListManager.shared.allDetailDevices.contains(where: {(DeviceListModule.shared.requiredService?.onboardingTypeFromQRCode(qrCode: $0.qrCode) ?? 0) == TPSS_EC_GENERAL} ) || DeviceListManager.shared.hasUnsupportedDevice {
            // 二维码获取不支持的设备或者读取设备列表中有不支持的设备时，弹出升级提示
            let lastVersion: (isShow: Bool, versionCode: Int) = DeviceListModule.shared.requiredService?.checkShowUpdateAlert() ?? (false, 0)
            if lastVersion.isShow {
                showAlertWith(title: LocalizedString(key: commonNoticeUpdateAPP), message: nil, messageTextAlignment: nil,
                              defaultButtonTitle: LocalizedString(key: commonUpdateNow), defaultButtonColor: .theme1,
                              cancelButtonTitle: LocalizedString(key: commonIgnoreNotice), cancelButtonColor: .black.withAlphaComponent(0.8),
                              cancelButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.updateUserNoMoreNotify(version: lastVersion.versionCode)
                    self.showDiskAlertIfAny()
                }, defaultButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.jumpAndCheckAppVersion()
                    self.showDiskAlertIfAny()
                })
            } else {
                showDiskAlertIfAny()
            }
        } else {
            showDiskAlertIfAny()
        }
    }

    private func exitReorderMode() {
        tabBarController?.tabBar.isUserInteractionEnabled = true
        groupToolbarContainer.isUserInteractionEnabled = true

        pageController.scrollEnable = true

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }

        isReordering = false
    }
}
//
//  SweeperMainViewController.swift
//  Pods
//
//  Created by 爱迪生 on 2021/8/2.
//

import UIKit
import SurveillanceHomeBase
import Promises
import SwiftyJSON
import SharedResource
import TPFoundation
import SimplePlayer
import DeviceDetailModule
import SnapKit
import NetService
import ThemeTool

enum CaptureImageLoadingStatus: Equatable {
    case loadSuccess
    case failure
    case loading
    case loadNoImage
    case model(SweeperBarrierType)
}

enum MainMapLoadingState {
    case loading
    case failure
    case noMap
    case hasMap
}

class SweeperMainViewController: SweeperGlobalConfigurationViewController {
    var needShowFastMapGuide: Bool = false
    // MARK: subviews
    private var previewButton: SweeperButton?
    weak var inputPasswordVC: UIViewController?
    var inputPassword: String?
    private var editButton: SweeperButton?
    private var baseStationButton: SweeperButton?
    private var moreButton: SweeperButton?
    private var parameterButton = SweeperButton()
    private var navigationTitleView = SweeperTitleBatteryView()
    private var chargeButton = SweeperButton()
    private var createMapContainer: SweeperCreateMapView?
    private var sweepAreaPopView: SweeperClearAreaPopView?
    private var sweeperAlarmViewController: (UIViewController & SweeperAlarmWindowSuitable)?
    private var startCleanAnimationView: SweeperStartCleanAnimationView?
    private var mapView = SweeperHomeMapView(frame: .zero, mapSize: .init(width: 1200, height: 1200))
    private var loadingView = SweeperMainMapLoadingView(frame: .zero)
    private var buttonContainerStackView = UIStackView()
    private var environmentView = UIView(frame: .zero)
    private var temperatureView = UILabel(frame: .zero)
    private var humidityView = UILabel(frame: .zero)
    private var equipmentOfflineView: SweeperRobotOfflineView?

    private var sweepControlView = SweeperControlView()
    private var sweepCaptureView = SweeperCaptureBubbleView()
    private var sweeperBaseUpgradingView = SweeperBaseStationUpgradingView()
    private var sweeperMechanicalOffView = SweeperMechanicalOffView()

    private var sweepControlViewHeightConstraint: NSLayoutConstraint?
    private var heightForControlView: CGFloat {
        switch status {
        case .stop:
            return 88 + bottomSafeAreaInset
        case .fastMap, .fastMapPause:
            return 69 + bottomSafeAreaInset
        case .sweepingPause, .sweeping:
            return 143 + bottomSafeAreaInset
        }
    }

    enum AlarmButtonClickMode {
        case exit
        case more
        case none
    }
    private var alarmButtonClickMode: AlarmButtonClickMode = .exit

    // 快速建图引导view
    private var fastMapImageView: UIImageView?
    private var fastMapGuideView: GuidePresentationView?


    // 地图已自动保存通知
    private var savedMapNoticeView: UIImageView?
    private var saveMapGuideView: GuidePresentationView?
    // 存储设备详细信息
    private var deviceDetail: DeviceDetail?
    private var isSharedDevice: Bool {
        return deviceDetail?.isSharedDevice ?? false
    }

    private var robotOffline = false
    private var hadStartWaveAnimation = false

    /// 首次载入
    /// 第一帧地图帧/路径帧到来时刷新所有界面
    private var needRefreshMapViewInMediaPlayer = true
    private var needEntrySaveMapLogic = true
    private var needShowCleaningLog = true

    /// 该属性用于，当前保存地图弹窗弹出时，扫地机正在清扫。保存该弹出状态，在清扫结束后再进入一遍保存地图逻辑。
    private var needEntrySaveMapLogicAfterBasicStateChanged = false


    /// 在地图变化时，将下列是否需要展示“地图保存”弹窗标识为true
    /// 在dataloading成功时，进行展示
    private var needShowSaveMapMultiFloor = false
    private var needShowSaveMapSingleFloor = false
    private var needShowMapHasSavedTip = false

    /// 基站升级与关机页面展示
    private var isShowingUpgradingView: Bool {
        get {
            return !sweeperBaseUpgradingView.isHidden
        }
        set {
            sweeperBaseUpgradingView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var isShowingMechanicalView: Bool {
        get {
            return !sweeperMechanicalOffView.isHidden
        }
        set {
            sweeperMechanicalOffView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var shouldShowChargeButton: Bool {
        get {
            guard let state = state else {
                return false
            }
            // 清扫完成并且不在基站上
            return state.cleanFinished && !state.onboard
        }
    }

    private var firstTimeUpdateNavigationTitle: Bool = true

    private var cleaningMode: SweeperCleaningMode {
        get {
            return sweeperControl?.cleaningMode ?? SweeperCleaningMode.init(type: .autoClean)
        }
        set {
            sweeperControl?.cleaningMode = newValue
            updateCleaningModeUI()
        }
    }

    private var cleaningModeType: CleaningModeType {
        get {
            return cleaningMode.type
        }
        set {
            cleaningMode.type = newValue
        }
    }

    override var sweeperCustomOrAutoMode: SweeperCustomOrAutoMode {
        get {
            return (sweeperControl?.customCleanEnabled ?? false) ? .custom : .auto
        }
        set { }
    }

    private var map: SweeperMap? {
        get {
            return sweeperControl?.map
        }
        set {
            let preMap = map
            sweeperControl?.map = newValue
            currentMapDidChanged(preMap: preMap)
        }
    }

    private var status: SweeperProcedure = .stop

    private var state: SweeperState? {
        get {
            return sweeperControl?.basicState
        }

        set {
            sweeperControl?.basicState = newValue
            basicStateChangeAction(showToast: true)
        }
    }

    private var temperatureText: String {
        get {
            var text = "环境温度："
            if let temperature = state?.temperature {
                let temperatureValue = Int(temperature)
                if temperatureValue == 127 || temperatureValue < -40 {
                    text += "--"
                } else {
                    text += "(Int(temperature))℃"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var humidityText: String {
        get {
            var text = "环境湿度："
            if let humidity = state?.humidity {
                let humidityValue = Int(humidity)
                if humidityValue < 0 || humidityValue > 100 {
                    text += "--"
                } else {
                    text += "(Int(humidity))%"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var cleaningState: SweeperCleaningState? {
        get {
            return sweeperControl?.cleaningState
        }

        set {
            sweeperControl?.cleaningState = newValue
            updateCleaningStateUI()
        }
    }

    private var isRecharging: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .recharge
    }

    private var forbiddenRechargeAndClean: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .assignLocation || state.mainState == .remoteControl
    }

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = SharedResource.sharedImage(named: "shared_setting_icon_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(settingBarButtonItemDidClick))
    }()

    // selected layerID backup
    private var selectedLayerID = [Int]()

    // 当前展示的障碍物ID
    private var obstacleID: Int?

    override var navigationBarTraits: [NavigationBarTrait] {
        return [.hidden(on: false), .style(style: .default), .translucent(on: false), .barTint(color: .init(hexString: lightGray10Color)), .separatorStyle(color: .clear, height: 0.0), .backgroundImage(image: UIImage())]
    }

    // MARK: - Constants
    private let chargeButtonPadding = 8.0
    private let defaultButtonPadding = 12.0
    private let defaultButtonInterval = 59.0
    private let battreyThreshold = 20
    private let bottomSafeAreaInset = TPUIUtils.safeAreaInsets().bottom

    override init(deviceID: TPSSDeviceIdentifier, listType: TPSSDeviceListType) {
        super.init(deviceID: deviceID, listType: listType)

        SweeperModule.shared.registerControlListener(listener: self, deviceID: deviceID, listType: listType)
        SweeperModule.shared.registerMapListener(mapListener: self)
        NotificationCenter.default.addObserver(self, selector: #selector(willEnterForeground), name: UIApplication.willEnterForegroundNotification, object: nil)
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        view.backgroundColor = .init(hexString: lightGray10Color)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        setupNavigation()
        setupControlView()
        setupMapView()
        setupSweeperAlarmView()
        setupButtons()
        setupOfflineView()
        setupEnvironmentView()
        setupLoadingView()
        setupUpgradingView()
        setupMechanicalOffView()
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true

        // 离开当前页面时，会使动画失效，若正在展示动画，再重新进入时，需要重新开始动画
        if hadStartWaveAnimation {
            startWaveAnimation()
        }

        if let loadingState = sweeperControl?.dataLoadingState {
            dataLoadingStateChangeAction(loadingState: loadingState)
        } else {
            updateViewShowState(state: .failed)
        }
        captureBubbleViewDismiss()
        // 横幅始终展示在最前方
        if let alarmView = sweeperAlarmViewController?.view {
            view.bringSubviewToFront(alarmView)
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        if needShowFastMapGuide {
            showFastMapGuideView()
            needShowFastMapGuide = false
        }
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        savedMapNoticeView?.removeFromSuperview()
    }

    deinit {
        SweeperModule.shared.removeControlListener(listener: self)
        SweeperModule.shared.removeMapListener(mapListener: self)
        NotificationCenter.default.removeObserver(self)
    }

    // 将从后台切换到前台，看作视图willAppear，方法作相同处理
    @objc func willEnterForeground() {
        cleanAllFlag()

        // 若当前的载入状态为loading时，对UI进行loading状态的刷新。
        // 否则等待dataLoadingStateDidChanged方法回调(从 loading -> 其他状态)。
        // 注：dataLoadingStateDidChanged方法在 loading -> loading 时不会被调用。
        if sweeperControl?.dataLoadingState == .loading {
            dataLoadingStateChanged(loadingState: .loading)
        }
    }

    /// 根据载入状态更新主页面View的展示情况
    /// -主页面加载状态 -
    /// 需要管理的控件：创建地图按钮、主页面地图、载入（载入失败）页面、编辑地图按钮、边扫边拖（定制清扫）悬浮按钮
    private func updateViewShowState(state: SweeperDataLoadingState) {
        switch state {
            case .loading:
                loadingView.isHidden = false
                loadingView.isLoadingFailure = false
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
            case .failed:
                loadingView.isLoadingFailure = true
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
                // 若扫地机离线，则展示离线页面，否则展示加载失败页面
                loadingView.isHidden = robotOffline
                equipmentOfflineView?.isHidden = !robotOffline
            case .noMap:
                createMapContainer?.isHidden = false
                loadingView.isHidden = true
                mapView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                parameterButton.isHidden = false
                moreButton?.isHidden = false
                editButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
            case .success:
                loadingView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                mapView.isHidden = false
                createMapContainer?.isHidden = true
                parameterButton.isHidden = false
                editButton?.isHidden = false
                moreButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
        }
    }

    override func willUpdateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode, showAlert: Bool) -> Bool {
        /// 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            if showAlert {
                showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap)
            }
            return false
        }
        return super.willUpdateSweeperCustomOrAutoMode(newMode: newMode, showAlert: showAlert)
    }

    override func updateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode) {
        /// 1. 若切换时当前清扫模式与newMode相同，则无需进入后续逻辑
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap,
              let sweeperControl = sweeperControl,
              let mapID = sweeperControl.map?.currentMapID,
              newMode != sweeperCustomOrAutoMode else {
            return
        }

        /// 2. 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap) { [weak self] (_) in
                self?.configurationView?.selectSegment(type: .auto)
            }
            return
        }

        /// 3. 切换为定制清扫时，无设置清扫顺序与清扫偏好，则不向设备发送请求（并在退出弹窗时（configurationFinished）切换回变扫边拖）
        if newMode == .custom && !isSetPreference() && !isSetSweepSeq() {
            return
        }

        /// 4. 发送切换清扫模式的接口，并修改主页面UI
        let customCleanEnabled = newMode == .custom
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestSetCleaningParam(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: mapID, customEnabled: customCleanEnabled).always {
            ToastView.dismissLoadingToast()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }

    override func configurationFinished() {
        /// 若configurationView当前处于定制清扫页面（“1”状态），则判断是否已设置定制清扫，若否切回边扫边拖。
        if !isSetPreference() && !isSetSweepSeq() && !settingButtonDidClickFlag && configurationView?.segmentedControl.selectedSegmentIndex == 1 {
            ToastView.showWarningToast(title: "未设置定制清扫，只能使用普通清扫", existTime: nil, centerY: .low)
            // 0 - means auto cleaning
            configurationView?.selectSegment(type: .auto)
        }
    }

    override func preferenceButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.preferenceButtonClickOperation()
    }

    override func sweepOrderButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.sweepOrderButtonClickOperation()
    }

    private func refreshMediaPlayerAndSweeperControl() {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.refreshSweeperControl()
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
    }

    private func updateConfigurationView() {
        configurationView?.selectSegment(type: sweeperCustomOrAutoMode)
        if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
            cleanMethodMode = mode
        }
    }

    private func updateClearingAreaButton() {
        var text = "全屋"
        var imagePath = "sweep_home"
        var title = text
        switch cleaningModeType {
        case .pointClean:
            text = "选框"
            title = text
            imagePath = "sweep_frame"
        case .areaClean:
            text = "区域"
            title = text
            imagePath = "sweep_region"
        case .autoClean:
            text = "全屋"
            title = text
            imagePath = "sweep_home"
        case .partClean:
            // 仅在sweepControlView的RangeTitle中修改
            updateData(with: .autoClean)
            title = "局部"
        case .fastMap:
            // DO NOTHING
            return
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
        sweepControlView.clearAreaButton?.titleLabel.text = text
        sweepControlView.clearAreaButton?.titleImageView.image = UIImage.image(named: imagePath)
        sweepControlView.rangeTitleLabel.text = title
        sweepControlView.clearAreaButton?.selectedAreaNumber = cleaningModeType == .areaClean ? selectedLayerID.count : 0
    }

    private func updateSweeperHomeMapViewCleanMode() {
        switch cleaningModeType {
        case .pointClean:
            mapView.cleaningModeType = .pointClean
        case .areaClean:
            mapView.cleaningModeType = .areaClean
        case .autoClean:
            mapView.cleaningModeType = .autoClean
        case .partClean:
            mapView.cleaningModeType = .partClean
        case .fastMap:
            mapView.cleaningModeType = .fastMap
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
    }

    private func updateSelectedLayerID() {
        if let seq = sweeperControl?.cleaningMode.areaIDs {
            selectedLayerID = seq
        }
    }

    private func updateParamUI() {
        var text = ""
        var imagePath = ""
        switch sweeperCustomOrAutoMode {
        case .auto:
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                switch mode {
                case .sweep:
                    text = LocalizedString(key: sweeperCleanOnlySweep)
                    imagePath = "mode_sweep"
                case .mop:
                    text = LocalizedString(key: sweeperCleanOnlyMop)
                    imagePath = "mode_mop"
                case .both:
                    text = LocalizedString(key: sweeperCleanSweepAndMop)
                    imagePath = "mode_sweep_mop"
                }
            }
        case .custom:
            text = LocalizedString(key: sweeperCustomClean)
            imagePath = "mode_diy"
        }
        let image = UIImage.image(named: imagePath)
        // 控制栏的参数按钮
        sweepControlView.parameterButton?.titleLabel.text = text
        sweepControlView.parameterButton?.titleImageView.image = image

        // 悬浮的参数按钮
        parameterButton.titleLabel.text = text
        parameterButton.titleImageView.image = image
    }

    private func updateSweeperHomeMapViewCustomOrAutoMode() {
        switch sweeperCustomOrAutoMode {
        case .auto:
            mapView.sweeperCustomOrAutoMode = .auto
        case .custom:
            mapView.sweeperCustomOrAutoMode = .custom
        }
    }

    private func dataLoadingStateChangeAction(loadingState: SweeperDataLoadingState) {
        // 1. 判断设备是否离线（deviceDetail.online）
        if loadingState == .failed {
            robotOffline = !(deviceDetail?.online ?? false)
        }

        // 2. 判断基站是否升级，若是，则不展示所有UI（除了导航栏）
        if state?.chargeBaseUpgrading == true {
            isShowingUpgradingView = true
            updateNavigation()
            return
        }

        if let switchOn = state?.mechanicalSwitchOn {
            showMechanicalOffView(switchOn: switchOn)
        }

        // 3. 刷新UI状态(是否hidden)
        updateViewShowState(state: loadingState)

        // 4. 载入成功（success or nomap）按照其他状态展示UI
        if loadingState == .success {
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            mapView.updateCleanningModeAndSweepingState()
            mapView.updateCustomOrAutoMode()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            sweeperAlarmViewController?.showAlarm()
            sweeperAlarmViewController?.showNotify()
            if needShowCleaningLog {
                sweeperAlarmViewController?.showCleaningLog()
                needShowCleaningLog = false
            }
            if needEntrySaveMapLogic {
                currentMapDidChanged(preMap: nil)
                needEntrySaveMapLogic = false
            }
            saveMapLogic()
        } else if loadingState == .noMap {
            // 尽管当前map id 为-2，但当设备发送地图帧过来时，仍然需要展示地图，故仍然需要刷新mapView
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            sweeperAlarmViewController?.showCleaningLog()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            // 用户未进入引导页，且当前不在清扫、建图中，需要进入快速建图引导页
            if UserDefaults.standard.shouldShowGuideForFastMap(for: deviceID) && (state?.cleanFinished ?? true) {
                let vc = SweeperFastMapGuideViewController(deviceID: deviceID, listType: listType)
                navigationController?.pushViewController(vc, animated: true)
            }
        }
    }

    private func saveMapLogic() {
        // 若需要展示弹窗，但当前在清扫中，则将弹窗状态保存起来，待扫地机状态变化时重新进入。
        if state?.cleanFinished == false && (needShowSaveMapSingleFloor || needShowSaveMapMultiFloor) {
            needEntrySaveMapLogicAfterBasicStateChanged = true
            return
        }
        if needShowMapHasSavedTip {
            showMapHasSavedTip()
            needShowMapHasSavedTip = false
        }
        if needShowSaveMapSingleFloor {
            saveMapSingleFloor()
            needShowSaveMapSingleFloor = false
        }
        if needShowSaveMapMultiFloor {
            saveMapMultiFloor()
            needShowSaveMapMultiFloor = false
        }
    }

    private func basicStateChangeAction(showToast: Bool) {
        // 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 展示波纹动画: 1. 当前地图ID为-2；
        //             2. 当前在清扫中；
        //             3. 未展示过动画
        //             4. 无地图帧
        if map?.currentMapID == noMapID
            && state?.cleanFinished == false && !hadStartWaveAnimation && sweeperControl?.hadFrame == false {
            startWaveAnimation()
        }
        if (state?.cleanFinished == true) {
            stopWaveAnimation()
        }
        // 特殊情况处理，当扫地机进入清扫状态时
        // 且当前处于无地图时，需要显示地图（而非等到map更改的信令进行变化）
        // 再次变为非清扫状态，且无地图时，需要展示无地图Image
        if map?.currentMapID == noMapID && state?.cleanFinished == false {
            updateViewShowState(state: .success)
        } else if map?.currentMapID == noMapID && state?.cleanFinished == true {
            updateViewShowState(state: .noMap)
        }

        // 扫地机关机状态更新
        showMechanicalOffView(switchOn: state?.mechanicalSwitchOn ?? false)

        if showToast {
            updateBasicStateToastView()
        }
        // 更新扫地机当前的清扫状态（将扫地机状态分为清扫中、暂停中、未清扫，后续根据该status更新清扫UI）
        updateSweepProduce()

        updateUI()
    }

    /// 使用Clean Finished，fast Map  字段与 basic state字段联合判断当前清扫是否结束
    private func updateSweepProduce() {
        guard let state = state else {
            status = .stop
            return
        }
        if state.cleanFinished && state.mainState != .paused && state.mainState != .cleaning {
            // 若设备清扫完成且设备主状态不在清扫、暂停时
            status = .stop
        } else {
            if state.fastMap {
                // 若为快速建图
                if state.mainState == .cleaning {
                    status = .fastMap
                } else {
                    status = .fastMapPause
                }
            } else {
                // 若不为快速建图，则展示正常清扫UI
                if state.mainState == .cleaning {
                   status = .sweeping
                } else {
                   status = .sweepingPause
                }
            }
        }
    }

    // 根据信令展示ToastView
    private func updateBasicStateToastView() {
        guard let state = state else {
            return
        }
        // 主状态为回充，遥控，清扫时候，主页均需展示loading
        if ((state.mainState == .cleaning || state.mainState == .recharge || state.mainState == .remoteControl) && state.subState == .relocate) {
            ToastView.showLoadingToast(cirleWithMessage: "定位中...", existTime: 60, existMessage: nil)
        } else {
            ToastView.dismissLoadingToast()
        }
    }

    /// 根据status更新：清扫面板、清扫参数、导航栏里扫地机的状态、回充按钮、提示栏的位置；
    /// status:     sweeping：当cleanFinished为false，且mainState为Cleaning，subState为Sweeping；
    ///        pause：当cleanFinished为false，
    private func updateUI() {
        // 只当地图数据载入完成之后，更新信令收到后的UI
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 每次收到信令后，获取设备状态，更新设备状态同时更新界面UI

        // 控制面板
        sweepControlView.status = status
        sweepControlViewHeightConstraint?.constant = heightForControlView
        if status == .stop {
            // 清扫参数按钮
            parameterButton.isHidden = true
            // 地图控件
            mapView.isSweeping = false
        } else if status == .fastMap || status == .fastMapPause {
            mapView.isSweeping = true
            parameterButton.isHidden = true
        } else {
            parameterButton.isHidden = false
            mapView.isSweeping = true
        }
        // 导航栏的状态和电量
        updateNavigation()
        // 温度湿度更新
        updateEnvironmentView()
        // 充电按钮
        updateChargeButton()
        refreshBubbleView()
    }

    private func updateCleaningStateUI() {
        guard let state = cleaningState else {
            return
        }
        sweepControlView.areaTitleLabel.text = "(state.cleaningArea)㎡"
        sweepControlView.timeTitleLabel.text = "(state.cleaningTime)min"
    }

    private func updateCleaningModeUI() {
        /// 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        /// 修改设置清扫模式（cleaningMode）按钮的样式
        updateClearingAreaButton()
        /// 修改地图的清扫模式
        updateSweeperHomeMapViewCleanMode()
        /// 根据获取到的cleaningMode中区域清扫的ID，更新地图区域的清扫顺序数组
        updateSelectedLayerID()
        /// 修改定制清扫/边扫边拖属性 - 通过回调去更新该属性更新后主页后续的UI。回调中调用的方法 - updateSweeperCustomOrAutoMode()
        updateConfigurationView()
        /// 修改定制清扫/边扫边拖按钮的样式
        updateParamUI()
        /// 修改定制清扫/边扫边拖地图的样式
        updateSweeperHomeMapViewCustomOrAutoMode()
    }

    private func showAlertWithWholeHouseClean() {
        showAlertWith(title: "进行一次全屋清扫", message: "清扫完成后，将建立家居地图。", messageTextAlignment: .center, defaultButtonTitle: "进行全屋清扫", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonHandler: nil) { [weak self] (_) in
            self?.showSweepTipsAlert()
        }
    }

    private func startFastMap() {
        if sweeperControl?.basicState?.mainState == .remoteControl {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFastMapDuringRemoteControl))
            return
        }
        if sweeperControl?.basicState?.mainState == .assignLocation {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFAstMapDuringAssignLocation))
            return
        }
        // 强制扫地机进入新建快速地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .fastMap)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: self.deviceID, channel: self.channel, listType: self.listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func startFastMapAlert() {
        let alert = SweeperTipsAlert(type: .fastMap) { [weak self] () in
            guard let self = self else { return }
            self.startFastMap()
        }
        alert.show()
    }

    private func showAlertWithFastMapEnd() {
        showAlertWith(title: "尚未得到完整地图，确定要结束吗？", message: nil, messageTextAlignment: .center, defaultButtonTitle: "结束建图", defaultButtonColor: .theme1, cancelButtonTitle: "继续", cancelButtonHandler: nil) { [weak self] (_) in
            self?.setCleaningMode(type: .stop)
        }
    }

    private func showSweepTipsAlert() {
        let alert = SweeperTipsAlert(type: .clean) { [weak self] () in
            self?.setCleaningMode(type: .sweeping)
        }
        alert.show()
    }

    private func setCleaningMode(type: SweeperProcedure) {
        switch type {
        case .sweeping:
            if sweeperControl?.basicState?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringRemoteControl))
                return
            }
            if sweeperControl?.basicState?.mainState == .assignLocation {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringAssignLocation))
                return
            }
            // 若扫地机当前无地图，则所有“清扫”操作为全屋清扫。
            if map?.currentMapID == noMapID {
                self.cleaningMode = SweeperCleaningMode.init(type: .autoClean)
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: SweeperCleaningMode.init(type: .autoClean)).catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
                return
            }

            if cleaningModeType == .areaClean {
                if selectedLayerID.count == 0 {
                    ToastView.showWarningToast(title: "请选择需要清扫的区域", existTime: nil, centerY: .low)
                    return
                }
                sweeperControl?.cleaningMode.areaIDs = selectedLayerID
            } else if cleaningModeType == .pointClean,
                      let partArea = mapView.getSelectionRect() {
                // 若能够从SelectionRect获取到数据，则修改cleaningMode的PointRect
                sweeperControl?.cleaningMode.leftTopPoint = partArea.leftTopPoint
                sweeperControl?.cleaningMode.rightBottomPoint = partArea.rightBottomPoint
            } else {
                sweeperControl?.cleaningMode = .init(type: .autoClean)
            }

            ToastView.showLoadingToast(cirleWithMessage: nil)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: sweeperControl?.cleaningMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .sweepingPause, .fastMapPause:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .pause)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .stop:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .stop)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .fastMap:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .fastMap)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func saveMapSingleFloor() {
        let deleteMapID = map?.allMapNames.keys.first(where: { (mapID) -> Bool in
                  return mapID != temporaryMapID
              })
        guard let sweeperControl = sweeperControl,
              let deleteMapID = deleteMapID,
              let deleteMapName = map?.allMapNames[deleteMapID] else {
            return
        }
        showAlert(title: "是否保存新地图?", buttons: [
            .init(style: .default, text: "更新“(deleteMapName)”", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                ToastView.showLoadingToast(cirleWithMessage: "正在更新")
                SweeperService.deleteMap(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: deleteMapID).then { (_) in
                    ToastView.showWarningToast(title: "更新成功", existTime: nil, centerY: .low)
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
            }),
            .init(style: .default, text: "另存为新地图", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let alert = SweeperSelectionAlert(title: "相同环境请勿保存多张地图，有可能影响机器人的定位。", message: "我家为多楼层户型") {
                    guard self?.isCurrentMapSaved() == true else {
                        ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                        return
                    }
                    ToastView.showLoadingToast(cirleWithMessage: "正在保存")
                    SweeperService.setMultiFloorEnabled(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, enabled: true, mapID: nil).always {
                        ToastView.dismissLoadingToast()
                    }.then { _ in
                        ToastView.showWarningToast(title: "保存成功", existTime: nil, centerY: .low)
                    }.catch { (error) in
                        ToastView.showWarningToast(warningMessage: error.localizedDescription)
                    }
                } cancelHandler: { [weak self] () in
                    self?.saveMapSingleFloor()
                }
                alert.show()
            }, isPreferred: true),
            .init(style: .default, text: LocalizedString(key: notSaveMap))
        ])
    }

    private func saveMapMultiFloor() {
        showAlert(title: "地图数量已达上限，是否保存新地图？", message: "如点击“保存”，请选择新地图要覆盖哪张旧地图。", messageTextAlignment: .center, buttons: [
            .init(style: .default, text: LocalizedString(key: notSaveMap), color: .theme1),
            .init(style: .default, text: "保存", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let vc = SweeperCoverOldMapController()
                vc.sweeperControl = self?.sweeperControl
                self?.navigationController?.pushViewController(vc, animated: true)
            }, isPreferred: true)
        ])
    }

    private func isCurrentMapSaved() -> Bool {
        return map?.currentMapID == temporaryMapID
    }

    /// preMapID 为 nil，表示为第一次赋值
    private func currentMapDidChanged(preMap: SweeperMap?) {
        guard let map = map else {
            return
        }
        // 展示波纹动画条件： 1. 当前地图id为-2
        //                 2. 当前主状态为清扫中
        //                 3. 第一次进入主页面
        //                 4. 当前无地图I帧
        let needShowRobotWave = map.currentMapID == noMapID && sweeperControl?.basicState?.mainState == .cleaning && (preMap == nil || !hadStartWaveAnimation) && sweeperControl?.hadFrame == false
        if needShowRobotWave {
            startWaveAnimation()
        }
        /// preMapID 从 nil -> 0，未处理后退出主页重新进入
        /// 或 从 “-1” -> 0  表示成功创建，但还未自动保存新地图
        let preMapID = preMap?.currentMapID
        if (preMapID == nil || preMapID == isCreatingMapID) && map.currentMapID == temporaryMapID {
            ///  生成临时地图： 需要判断是多楼层还是单楼层来决定保存方式；
            guard let multiFloorEnabled = sweeperControl?.multiFloorEnabled, let maxMapNumber = sweeperControl?.capability?.maxMapNumber else {
                return
            }
            if multiFloorEnabled {
                if map.mapNumber > maxMapNumber && maxMapNumber > 0 && map.currentMapID == temporaryMapID {
                    // 地图已达上限且能力集中多楼层地图上限不为0，且当前地图是临时地图时，展示多楼层地图上限弹窗
                    needShowSaveMapMultiFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            } else {
                if map.mapNumber > 1 && map.currentMapID == temporaryMapID {
                    // 已经有一张地图且当前地图时临时地图时，展示单楼层地图上限弹窗。
                    needShowSaveMapSingleFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            }
            return
        }

        /// 成功创建，mapID 从 “-1” -> 大于0
        if preMapID == isCreatingMapID && map.currentMapID != noMapID && map.currentMapID != temporaryMapID && map.allMapNames.count == (preMap?.allMapNames.count ?? 0) + 1 {
            ///  生成完整地图：直接进入“已自动保存逻辑”
            needShowMapHasSavedTip = true
        }
    }

    private func showMapNotCompletedAlert(alertMessage: String, cancelHandler: ((UIAlertAction) -> Void)? = nil, defaultHandler: (() -> Void)? = nil) {
        showAlertWith(title: alertMessage, message: nil, messageTextAlignment: nil, defaultButtonTitle: "查看帮助", defaultButtonColor: .theme1, cancelButtonTitle: "关闭", cancelButtonColor: .theme1, cancelButtonHandler: cancelHandler, defaultButtonHandler: { [weak self] (_) in
            let vc = SweeperMapHelpViewController(type: .incomplete)
            self?.navigationController?.pushViewController(vc, animated: true)
            defaultHandler?()
        })
    }

    private func showCanNotCustomCleanAlert(isCreatingMap: Bool, defaultButtonhandler: ((UIAlertAction) -> Void)? = nil) {
        if isCreatingMap {
            showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持定制清扫", defaultHandler: { [weak self] () in
                self?.configurationView?.dismiss()
            })
        } else {
            showAlertWith(title: "请创建地图后再设置定制清扫", defaultButtonTitle: SharedResource.sharedFormatString(key: commonSure), defaultButtonColor: UIColor.black, cancelButtonTitle: nil, defaultButtonHandler: defaultButtonhandler)
        }
    }

    func showFastMapGuideView() {
        if fastMapImageView == nil {
            fastMapImageView = UIImageView()
            fastMapImageView?.image = UIImage.image(named: "quick_build_map")
            fastMapImageView?.sizeToFit()
        }
        guard let imageView = fastMapImageView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            fastMapGuideView?.dismiss()
            var offset: CGFloat = defaultButtonInterval
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            fastMapGuideView = presentGuideWith(viewToPresent: imageView, size: imageView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    func showMapHasSavedTip() {
        if savedMapNoticeView == nil {
            savedMapNoticeView = UIImageView()
            savedMapNoticeView?.image = UIImage.image(named: "edit_map")
            savedMapNoticeView?.sizeToFit()
        }
        guard let noticeView = savedMapNoticeView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            saveMapGuideView?.dismiss()
            var offset: CGFloat = 0
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            saveMapGuideView = presentGuideWith(viewToPresent: noticeView, size: noticeView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    override func collectionViewCell(_ cell: SweeperGlobalCleaningConfigurationCollectionViewCell, didSelectItemAt indexPath: IndexPath) {
        super.collectionViewCell(cell, didSelectItemAt: indexPath)

        let itemIndex = indexPath.section
        let row = indexPath.row
        let parameter = settingItems[itemIndex].paramters[row].type
        if parameter == .suctionForce(.none) {
            showAlertWith(title: "静音模式下吸尘能力将暂时降低，仅本次清扫任务生效。", message: nil, messageTextAlignment: nil, defaultButtonTitle: "确定", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonColor: .black, cancelButtonHandler: nil) { [weak self] (_) in
                self?.setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
            }
        } else {
            setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
        }
    }

    func setGlobalConfig(parameter: SweeperGlobalConfigurationType, itemIndex: Int) {
        var pendingConfig = sweeperControl?.globalCleaningConfig

        switch parameter {
        case .suctionForce(_):
            pendingConfig?.suction = parameter
        case .waterYield(_):
            pendingConfig?.waterYield = parameter
        case .sweepTimes(_):
            pendingConfig?.cleanTimes = parameter
        case .cleanMethod(_):
            pendingConfig?.cleanMethod = parameter
        case .mopMode(_):
            pendingConfig?.mopMode = parameter
        }


        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setGlobalCleaningConfig(device: deviceID, channel: channel, listType: listType, config: pendingConfig).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.then { [weak self] (_) in
            self?.sweeperControl?.globalCleaningConfig = pendingConfig
            self?.configurationView?.collectionView.reloadData()
            self?.updateParamUI()
        }
    }

    func startWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        let animationView = SweeperStartCleanAnimationView(frame: .zero)
        view.addSubview(animationView)

        animationView.snp.makeConstraints { make in
            make.centerX.equalToSuperview().offset(28)
            make.centerY.equalToSuperview().multipliedBy(0.764).offset(28)
            make.width.height.equalTo(56)
        }
        self.startCleanAnimationView = animationView
        animationView.startAnimation()
        hadStartWaveAnimation = true
    }

    func stopWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        startCleanAnimationView = nil
        hadStartWaveAnimation = false
    }

    private func cleanAllFlag() {
        needEntrySaveMapLogic = true
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true
        needShowMapHasSavedTip = false
        needShowSaveMapMultiFloor = false
        needShowSaveMapSingleFloor = false
        needEntrySaveMapLogicAfterBasicStateChanged = false
    }
}

// MARK: Button Action
private extension SweeperMainViewController {
    @objc func paramterButtonDidClick() {
        configurationView?.isSetSeq = isSetSweepSeq()
        configurationView?.isSetPreference = isSetPreference()
        configurationView?.show(view: self.navigationController?.view)
    }

    @objc func clearAreaButtonDidClick() {
        sweepAreaPopView = SweeperClearAreaPopView(type: cleaningModeType)
        sweepAreaPopView?.delegate = self
        sweepAreaPopView?.show()
    }

    @objc func startButtonDidClick() {
        guard (map?.currentMapID) != nil  else {
            return
        }
        if sweeperControl?.dataLoadingState == .success {
            setCleaningMode(type: .sweeping)
        } else {
            showAlertWithWholeHouseClean()
        }
    }

    @objc func stopButtonDidClick() {
        if status == .fastMapPause || status == .fastMap {
            showAlertWithFastMapEnd()
        } else {
            setCleaningMode(type: .stop)
        }
    }

    @objc func pasueButtonDidClick() {
        if status == .sweepingPause {
            setCleaningMode(type: .sweeping)
        } else if status == .fastMapPause {
            setCleaningMode(type: .fastMap)
        } else {
            setCleaningMode(type: .sweepingPause)
        }
    }

    @objc func previewButtonDidClick() {
        guard let mediaState = sweeperControl?.mediaState, checkEntryCondition() else {
            return
        }
        checkMediaStateAndJump(state: mediaState)
    }

    func checkMediaStateAndJump(state: SweeperMediaState) {
        // 若为被分享端，则不判断，直接进入人工驾驶页面
        if isSharedDevice {
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            vc.needShowSettingButton = false
            navigationController?.pushViewController(vc, animated: true)
            return
        }

        switch state {
        case .closed, .open:
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        case .openWithPermission:
            if sweeperControl?.mediaEncryptEnabled == true {
                // 视频加密开启，直接验证密码
                checkUnAuthenticated()
                return
            }
            // 视频加密关闭，需要检测设备空密码
            ToastView.showLoadingToast(cirleWithMessage: nil)
            requestCheckEmptyPassword {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func checkEntryCondition() -> Bool {
        if state?.collectDust == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterCollectionDust))
            return false
        }
        if state?.mopWashState == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterWashingMop))
            return false
        }
        return true
    }

    @objc func baseStationButtonDidClick() {
        if sweeperControl?.basicState?.cleanSinkState != .stop {
            let vc = SweeperBaseStationCleanSinkViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        } else {
            let vc = SweeperBaseStationMainViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func moreButtonDidClick() {
        let vc = SweeperMoreActionViewController(deviceID: deviceID, listType: listType)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    @objc func editButtonDidClick() {
        // 大于0的地图数量为0时(无已保存地图)并且没有地图，不允许进入，若mapID为“-1”允许进入
        if sweeperControl?.mapWithoutZero?.count == 0 && sweeperControl?.map?.currentMapID == noMapID {
            // 若扫地机在清扫、建图时，展示暂无地图
            if (state?.cleanFinished ?? true) {
                let fastMapGuideSheet = SweeperFastMapSheet()
                fastMapGuideSheet.delegate = self
                fastMapGuideSheet.show()
            } else {
                ToastView.showWarningToast(title: "暂无地图", existTime: nil, centerY: .low)
            }
            return
        }

        let alertActionSheet = TPActionSheet.init(title: nil)
        let setRigionAction = TPActionSheetAction.init(title: "设置禁区/虚拟墙", detail: "设置不允许扫地机器人进入的区域", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }

            // 清扫过程中进入编辑禁区页面需要暂停扫地机
            if self.status == .sweeping || self.status == .fastMap {
                self.setCleaningMode(type: .sweepingPause)
            }
            // 回充过程中进入编辑进去页面需要设置为待机
            if self.state?.mainState == .recharge {
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setStandBy(deviceID: self.deviceID, listType: self.listType).always {
                    ToastView.dismissLoadingToast()
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }
            }
            // 指哪到哪和遥控时不允许进入禁区页面
            if self.state?.mainState == .assignLocation || self.state?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterMission))
                return
            }
            let vc = SweeperForbiddenAreaVirtualWallViewController(sweeperControl: self.sweeperControl)
            self.navigationController?.pushViewController(vc, animated: true)
        }

        let editMapAreaAction = TPActionSheetAction.init(title: "编辑地图区域", detail: "划分地图区域并进行标记", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }
            /// 清扫、快速建图中不允许进入编辑区域页面
            if self.status != .stop {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterCleaning))
                return
            }
            /// 正在创建地图中不允许进入编辑区域页面
            guard self.map?.currentMapID != isCreatingMapID else {
                self.showMapNotCompletedAlert(alertMessage: LocalizedString(key: sweeperMapIsNotCompleteForEditingArea))
                return
            }
            let vc = SweeperEditMapAreaViewController(sweeperControl: self.sweeperControl)
            vc.isSetPreferenceOrOrder = self.isSetPreference() || self.isSetSweepSeq()
            self.navigationController?.pushViewController(vc, animated: true)
        }


        let manageMapAction = TPActionSheetAction.init(title: "管理地图", style: .leftTitle) { [weak self] (_) in
            guard let self = self else {
                return
            }
            let vc = SweeperMapManagerViewController()
            vc.delegate = self
            vc.deviceID = self.deviceID
            vc.listType = self.listType
            self.navigationController?.pushViewController(vc, animated: true)
        }

        var editActionArray: [TPActionSheetAction] = []
        editActionArray = map?.currentMapID == noMapID ? [manageMapAction] : [setRigionAction, editMapAreaAction, manageMapAction]

        editActionArray.forEach { (action) in
            action.font = .projectFont(ofSize: 16)
            action.detailFont = .projectFont(ofSize: 12)
            alertActionSheet.addAction(action)
        }
        alertActionSheet.separatorColor = .cellSeparatorGray

        alertActionSheet.show()
    }

    @objc func settingBarButtonItemDidClick() {
        if let vc = SweeperSettingViewController.create() {
            vc.deviceID = deviceID
            vc.listType = listType
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func rechargeButtonDidClick() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setRechargeState(device: deviceID, channel: channel, listType: listType, enabled: !isRecharging).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperRobotOfflineViewDelegate {
    func offlineHelpButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.requiredService?.goToOfflineHelp(deviceID: sweeperControl.deviceID, cloudID: sweeperControl.cloudID, listType: sweeperControl.listType, navigator: self.navigationController)
    }

    func offlineRefreshButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
        SweeperModule.shared.refreshSweeperControl()
    }
}

extension SweeperMainViewController: SweeperClearAreaPopViewDelegate {
    func updateData(with type: CleaningModeType) {
        if map?.currentMapID == isCreatingMapID {
            switch type {
            case .areaClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持区域清扫")
            case .pointClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持选框清扫")
            case .autoClean:
                // DO NOTHING
                break
            case .partClean:
                // DO NOTHING
                break
            case .pause:
                // DO NOTHING
                break
            case .stop:
                // DO NOTHING
                break
            case .fastMap:
                // DO NOTHING
                break
            }
            sweepAreaPopView?.dismiss()
            return
        } else {
            if type == .areaClean {
                if map?.currentMapID != noMapID {
                    ToastView.showWarningToast(title: "请选择区域", existTime: nil, centerY: .low)
                }
            }
        }
        self.cleaningModeType = type
        sweepAreaPopView?.dismiss()
    }
}

// MARK: setup UI
private extension SweeperMainViewController {
    func setupNavigation() {

        navigationItem.title = deviceDetail?.alias ?? "扫地机器人"

        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
        addCustomNavigationLeftBarButtonItem(title: nil, image: SharedResource.sharedImage(named: "common_light_back_nor"))
    }

    func setupButtons() {
        var title: String
        var imageName: String
        if isSharedDevice {
            title = "遥控"
            imageName = "ptz"
        } else {
            title = "视频遥控"
            imageName = "preview_light_nor"
        }
        previewButton = SweeperButton(title: title, fontSize: 9, image: UIImage.image(named: imageName))
        let previewTap = UITapGestureRecognizer.init(target: self, action: #selector(previewButtonDidClick))
        previewButton?.addGestureRecognizer(previewTap)
        if let button = previewButton {
            self.view.bringSubviewToFront(button)
        }
        if let previewButton = previewButton {
            buttonContainerStackView.addArrangedSubview(previewButton)
        }

        editButton = SweeperButton(title: "编辑地图", fontSize: 9, image: UIImage.image(named: "map_black_nor"))

        let editTap = UITapGestureRecognizer.init(target: self, action: #selector(editButtonDidClick))
        editButton?.addGestureRecognizer(editTap)
        if let editButton = editButton {
            buttonContainerStackView.addArrangedSubview(editButton)
        }

        baseStationButton = SweeperButton(title: "基站", fontSize: 9, image: UIImage.image(named: "sweeper_home"))

        let stationTap = UITapGestureRecognizer.init(target: self, action: #selector(baseStationButtonDidClick))
        baseStationButton?.addGestureRecognizer(stationTap)
        if let baseStationButton = baseStationButton {
            buttonContainerStackView.addArrangedSubview(baseStationButton)
        }

        moreButton = SweeperButton(title: "更多", fontSize: 9, image: UIImage.image(named: "star"))

        let moreButtonTap = UITapGestureRecognizer.init(target: self, action: #selector(moreButtonDidClick))
        moreButton?.addGestureRecognizer(moreButtonTap)
        if let moreButton = moreButton {
            buttonContainerStackView.addArrangedSubview(moreButton)
        }

        [previewButton, editButton, baseStationButton, moreButton].forEach { button in
            button?.snp.makeConstraints { make in
                make.width.equalTo(44)
                make.height.equalTo(47)
            }
        }

        /* buttonContainerStackView */
        view.addSubview(buttonContainerStackView)
        buttonContainerStackView.axis = .vertical
        buttonContainerStackView.alignment = .center
        buttonContainerStackView.spacing = 12
        buttonContainerStackView.snp.makeConstraints { make in
            make.width.equalTo(44)
            make.top.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }

        /* createMapButton */
        createMapContainer = SweeperCreateMapView()
        if let createMapContainer = createMapContainer {
            view.addSubview(createMapContainer)

            let goldenRatio: CGFloat = 0.382
            createMapContainer.snp.makeConstraints { make in
                make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2).offset(-(88 * goldenRatio))
                make.centerX.equalToSuperview()
                make.width.equalTo(230)
            }
        }
        createMapContainer?.isHidden = true

        /* chargeButton */
        chargeButton = SweeperButton(title: "返回基站", fontSize: 9, image: UIImage.image(named: "robot_charger"), offsetToTop: 5)
        addContraint(for: chargeButton, trailingToSuperView: -defaultButtonPadding)
        chargeButton.isHidden = true
        chargeButton.snp.makeConstraints { make in
            if let sweeperAlarmView = sweeperAlarmViewController {
                make.bottom.equalTo(sweeperAlarmView.view.snp.top).offset(-defaultButtonPadding / 2)
            } else {
                make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding)
            }
        }
        let chargeTap = UITapGestureRecognizer.init(target: self, action: #selector(rechargeButtonDidClick))
        chargeButton.addGestureRecognizer(chargeTap)

        parameterButton = SweeperButton(title: LocalizedString(key: sweeperCleanSweepAndMop), fontSize: 9, image: UIImage.image(named: "mode_general"), offsetToTop: 5)
        addContraint(for: parameterButton, trailingToSuperView: -defaultButtonPadding, bottomToSuperView: nil)
        parameterButton.snp.makeConstraints { (make) in
            make.bottom.equalTo(chargeButton.snp.bottom)
        }

        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        parameterButton.addGestureRecognizer(paramTap)

    }

    func setupOfflineView() {
        let offlineView = SweeperRobotOfflineView(frame: .zero)
        offlineView.delegate = self
        self.view.addSubview(offlineView)

        let goldenRatio: CGFloat = 0.382
        offlineView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2)
        }
        equipmentOfflineView = offlineView
        equipmentOfflineView?.isHidden = true
    }

    func updateNavigation() {
        if firstTimeUpdateNavigationTitle {
            navigationTitleView = SweeperTitleBatteryView(title: deviceDetail?.alias ?? "扫地机器人", stateText: "", power: 0, charge: false)
            navigationTitleView.snp.remakeConstraints { make in
                make.height.equalTo(44)
                make.width.equalTo(screenWidth - 150)
            }
            navigationItem.titleView = navigationTitleView
            firstTimeUpdateNavigationTitle = false
        }

        let stateText = state?.stateDescription ?? "故障中"
        let battery = state?.battery ?? 0
        let isCharging = state?.mainState == .charging
        navigationTitleView.setState(stateText: stateText, power: battery, charge: isCharging)
    }

    func updateEnvironmentView() {
        temperatureView.text = temperatureText
        humidityView.text = humidityText
    }

    func updateChargeButton() {
        chargeButton.isHidden = !shouldShowChargeButton
        if isRecharging {
            chargeButton.setTitle(title: "停止回充", buttonImage: UIImage.image(named: "robot_charge_stop"))
        } else {
            chargeButton.setTitle(title: "返回基站", buttonImage: UIImage.image(named: "robot_charger"))
        }
        if forbiddenRechargeAndClean {
            chargeButton.titleLabel.textColor = .lightGray3Color.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = false
        } else {
            chargeButton.titleLabel.textColor = .black.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = true
        }
    }

    func setupLoadingView() {
        view.addSubview(loadingView)
        loadingView.delegate = self
        loadingView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(0.764)
        }
    }

    func setupMapView() {
        let mapSize = sweeperControl?.mapSize ?? CGSize(width: defaultMapWidth, height: defaultMapHeight)
        mapView = SweeperHomeMapView(frame: .zero, mapSize: mapSize)
        mapView.backgroundColor = UIColor.clear
        view.addSubview(mapView)
        mapView.delegate = self
        mapView.sweeperIconMapView.delegate = self
        mapView.datasource = self
        mapView.isHidden = true

        mapView.snp.makeConstraints { make in
            make.top.trailing.leading.equalToSuperview()
            make.bottom.equalTo(sweepControlView.snp.top)
        }
        setupTapGesture()
    }

    func setupTapGesture() {
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(didTaped(recognizer:)))
        self.mapView.addGestureRecognizer(tapGesture)
    }

    func setupSweeperAlarmView() {
        let sweeperAlarmViewController = SweeperAlarmBannerViewController()
        sweeperAlarmViewController.window(from: .mainPage)
        sweeperAlarmViewController.sweeperControl = self.sweeperControl

        self.addChild(sweeperAlarmViewController)
        view.addSubview(sweeperAlarmViewController.view)
        sweeperAlarmViewController.view.snp.makeConstraints { make in
            make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding / 2)
            make.leading.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }
        self.sweeperAlarmViewController = sweeperAlarmViewController
    }

    @objc func didTaped(recognizer: UITapGestureRecognizer) {
        captureBubbleViewDismiss()
    }

    func setupEnvironmentView() {
        view.addSubview(environmentView)

        environmentView.snp.makeConstraints { make in
            make.height.equalTo(36)
            make.leading.top.equalToSuperview().offset(12)
        }
        environmentView.backgroundColor = .lightGray3Color.withAlphaComponent(0.1964)
        environmentView.layer.cornerRadius = 5

        [temperatureView, humidityView].forEach { label in
            environmentView.addSubview(label)

            label.backgroundColor = .clear
            label.textColor = .black.withAlphaComponent(0.6)
            label.textAlignment = .left
            label.font = .projectFont(ofSize: 10)
            label.snp.makeConstraints { make in
                make.height.equalTo(14)
                make.trailing.equalToSuperview().offset(-8)
                make.leading.equalToSuperview().offset(8)
            }
        }

        temperatureView.snp.makeConstraints { make in
            make.top.equalToSuperview().offset(4)
        }
        temperatureView.text = temperatureText

        humidityView.snp.makeConstraints { make in
            make.top.equalTo(temperatureView.snp.bottom)
        }
        humidityView.text = humidityText
    }

    func setupControlView() {
        addConstraint(forBottomView: sweepControlView, height: nil)
        sweepControlView.isHidden = true
        sweepControlViewHeightConstraint = NSLayoutConstraint(item: sweepControlView,
                                                             attribute: .height,
                                                             relatedBy: .equal,
                                                             toItem: nil,
                                                             attribute: .notAnAttribute,
                                                             multiplier: 1.0,
                                                             constant: 0)
        sweepControlViewHeightConstraint?.isActive = true

        // button clicked
        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        sweepControlView.parameterButton?.addGestureRecognizer(paramTap)

        let clearTap = UITapGestureRecognizer.init(target: self, action: #selector(clearAreaButtonDidClick))
        sweepControlView.clearAreaButton?.addGestureRecognizer(clearTap)

        let startTap = UITapGestureRecognizer.init(target: self, action: #selector(startButtonDidClick))
        sweepControlView.startButton.addGestureRecognizer(startTap)

        let stopTap = UITapGestureRecognizer.init(target: self, action: #selector(stopButtonDidClick))
        sweepControlView.stopButton.addGestureRecognizer(stopTap)

        let pauseTap = UITapGestureRecognizer.init(target: self, action: #selector(pasueButtonDidClick))
        sweepControlView.pauseButton.addGestureRecognizer(pauseTap)

    }

    func setupUpgradingView() {
        view.addSubview(sweeperBaseUpgradingView)
        sweeperBaseUpgradingView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingUpgradingView = false
    }

    func setupMechanicalOffView() {
        view.addSubview(sweeperMechanicalOffView)
        sweeperMechanicalOffView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingMechanicalView = false
        sweeperMechanicalOffView.delegate = self
    }

    func addConstraint(forBottomView bottomView: UIView?, height: CGFloat?) {
        guard let bottomView = bottomView else {
            return
        }
        bottomView.translatesAutoresizingMaskIntoConstraints = false

        view.addSubview(bottomView)

        // UI中设置的阴影radius为12，此处设置为8，才能与UI的效果一致。
        let shadowRadius: CGFloat = 8
        bottomView.layer.shadowOffset = .init(width: 0, height: 2)
        bottomView.layer.shadowRadius = shadowRadius
        bottomView.layer.shadowColor = UIColor.black.cgColor
        bottomView.layer.shadowOpacity = 0.16

        NSLayoutConstraint(item: bottomView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .width,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        if let height = height {
            NSLayoutConstraint(item: bottomView,
                               attribute: .height,
                               relatedBy: .equal,
                               toItem: nil,
                               attribute: .notAnAttribute,
                               multiplier: 1.0,
                               constant: height).isActive = true
        }

        NSLayoutConstraint(item: bottomView,
                           attribute: .bottom,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .bottom,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        NSLayoutConstraint(item: bottomView,
                           attribute: .centerX,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .centerX,
                           multiplier: 1.0,
                           constant: 0).isActive = true
    }

    func addContraint(for subView: UIView?, trailingToSuperView: CGFloat, topToSuperView: CGFloat? = nil, bottomToSuperView: CGFloat? = nil) {
        guard let subView = subView else {
            return
        }

        view.addSubview(subView)
        subView.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint(item: subView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 44).isActive = true
        NSLayoutConstraint(item: subView,
                           attribute: .height,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 47).isActive = true
        if let topToSuperView = topToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .top,
                               relatedBy: .equal,
                               toItem: view,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: topToSuperView).isActive = true
        }

        if let bottomToSuperView = bottomToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .bottom,
                               relatedBy: .equal,
                               toItem: bottomLayoutGuide,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: bottomToSuperView).isActive = true
        }

        NSLayoutConstraint(item: subView,
                           attribute: .trailing,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .trailing,
                           multiplier: 1.0,
                           constant: trailingToSuperView).isActive = true
    }
}

/// receive bitmap data
extension SweeperMainViewController: SweeperMapMediaPlayerListener {
    func mediaPlayerConnected(connectedSuccess: Bool) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if !connectedSuccess {
            dataLoadingStateChangeAction(loadingState: .failed)
        }
    }

    func dataLoadingStateChanged(loadingState: SweeperDataLoadingState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        dataLoadingStateChangeAction(loadingState: loadingState)
    }

    func mediaPlayerBitmapDataUpdate(dataType: MapMediaPlayerFrameFormat) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        /// 对扫地机地图正处于拖动或缩放时地图的刷新进行限制，避免卡顿的情况。
        guard !mapView.isOperation else {
            return
        }
        if dataType == .map {
            // 第一次收到I帧
            if sweeperControl?.hadFrame == true {
                stopWaveAnimation()
            }
            mapView.sweeperBitmapView.refreshBitmapImage()
            mapView.sweeperAreaView.refreshAreaView()
            if needRefreshMapViewInMediaPlayer {
                needRefreshMapViewInMediaPlayer = false
                mapView.refreshView()
            }
        }

        if sweeperControl?.hadFrame == true && dataType == .path {
            mapView.sweeperRouteView.refreshRouteView()
            // refresh equipment icon and charger pile location.
            mapView.sweeperIconMapView.refreshIconView()
        }
    }

    func mediaPlayerSignalling(mapID: String, type: SweeperConfigUpdateType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if type == .cleaningState {
            updateCleaningStateUI()
        } else if type == .cleaningMode || type == .cleanParam {
            updateCleaningModeUI()
        } else if type == .areaCleaning {
            mapView.updateCustomOrAutoMode()
            mapView.refreshAreaAndLabelView()
        } else if type == .globalCleaningConfig {
            // 修改全局清扫配置
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                cleanMethodMode = mode
                configurationView?.collectionView.reloadData()
            }
        } else {
            mapView.refreshView()
            mapView.refreshAreaAndLabelView()
        }
    }

    func mediaPlayerBasicStateDidChanged(preState: SweeperState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        basicStateChangeAction(showToast: true)
        sweeperAlarmViewController?.showAlarm()
        sweeperAlarmViewController?.showNotify()

        // 当前扫地机清扫结束时，若需要进入地图保存逻辑，则重新进入
        if !preState.cleanFinished && state?.cleanFinished == true && needEntrySaveMapLogicAfterBasicStateChanged {
            currentMapDidChanged(preMap: nil)
            saveMapLogic()
            needEntrySaveMapLogicAfterBasicStateChanged = false
        }
    }

    func mediaPlayerMapIDDidChanged(preMap: SweeperMap) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        currentMapDidChanged(preMap: preMap)

        /// 每次修改current map id 后， 地图的大小都会发生变化，故需要刷新初始地图的大小以适应屏幕
        mapView.restoreInitalMapView()
        mapView.shouldRefreshSize = true
        mapView.refreshView()
        mapView.updateCleanningModeAndSweepingState()
        mapView.updateCustomOrAutoMode()
        mapView.refreshAreaAndLabelView()
    }

    func mediaPlayerAlarm(type: SweeperAlarmType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        let alarm = SweeperAlarm(type: type)

        // 当前alarm需要在主页面显示、当基站升级、开关断开时不展示
        guard alarm.window.contains(.mainPage) && sweeperMechanicalOffView.isHidden && sweeperBaseUpgradingView.isHidden else {
            return
        }

        // 展示Toast
        if alarm.rank.contains(.toast),
           let message = alarm.toastTitle {
            ToastView.showWarningToast(title: message, existTime: nil, centerY: .low)
            return
        }

        // 展示Dialog，不展示只在基站展示的dialog
        if alarm.rank.contains(.dialog),
           !SweeperAlarm.baseDialogTypes.contains(type),
           let title = alarm.toastTitle {
            showAlertWith(title: title, message: alarm.toastContent, messageTextAlignment: .center, defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil, cancelButtonHandler: nil, defaultButtonHandler: nil)
            return
        }
    }
}

extension SweeperMainViewController: SweeperMapViewDataSource {
    func area(_ view: UIView, customCleanConfigurationIn areaID: Int) -> SweeperGlobalCleaningConfiguration? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaCleaningConfiguration
    }

    func area(_ view: UIView, infomationLayerMarkIn areaID: Int) -> String? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaLabel
    }

    func areaIDSet(_ in: UIView) -> [Int]? {
        return sweeperControl?.mapModel?.areaModel.areaIDs
    }

    func areaLabelLocation(_ view: UIView, areaID: Int) -> CGPoint? {
        return sweeperControl?.mapModel?.areaModel.areaLabelLocation[areaID]
    }

    func bitmapImage(_ view: UIView) -> CGImage? {
        return sweeperControl?.mapModel?.bitmapImage()
    }

    func bitmapOffset(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.offset
    }

    func bitmapSize(_ view: UIView) -> CGSize? {
        return sweeperControl?.mapModel?.bitmapSize
    }

    func areaData(_ view: UIView) -> [UInt8]? {
        return sweeperControl?.mapModel?.areaModel.areaData
    }

    func routeAllPointArray(_ view: UIView) -> [RoutePoint]? {
        return sweeperControl?.routeModel?.routePoints
    }

    func virtualWallIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.virtualWallModel?.wallIDs
    }

    func virutalWall(_ view: UIView, wallID: Int, isInEditMap: Bool) -> (CGPoint, CGPoint)? {
        return sweeperControl?.virtualWallModel?.couplePiontDictionary[wallID]
    }

    func forbiddenAreaIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.forbiddenAreaModel?.areaIDs
    }

    func forbiddenArea(_ view: UIView, areaID: Int, isInEditMap: Bool) -> RectangleArea? {
        return sweeperControl?.forbiddenAreaModel?.couplePiontDictionary[areaID]
    }

    func equipmentLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.routeModel?.equipmenLocation
    }

    func equipmentAngle(_ view: UIView) -> CGFloat? {
        return sweeperControl?.routeModel?.equipmenOritention
    }

    func chargePileLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.chargePileLocation
    }

    func barrierIDSet(_ view: UIView) -> [Int]? {
        if let keys = sweeperControl?.barriersModel?.barrierDictionary.keys {
            return Array(keys)
        } else {
            return nil
        }
    }

    func barrier(_ view: UIView, barrierModelIn barrierID: Int) -> SweeperBarrier? {
        return sweeperControl?.barriersModel?.barrierDictionary[barrierID]
    }

    func rectClean(_ view: UIView) -> (leftTopPoint: CGPoint, rightBottomPoint: CGPoint)? {
        if cleaningMode.leftTopPoint != .zero && cleaningMode.rightBottomPoint != .zero {
            return (cleaningMode.leftTopPoint, cleaningMode.rightBottomPoint)
        } else {
            return nil
        }
    }

    func mapScale(_ view: UIView) -> CGFloat? {
        return sweeperControl?.capability?.mapScale
    }
}

extension SweeperMainViewController: SweeperHomeMapViewDelegate {
    func hadMapFrame(_ view: SweeperHomeMapView) -> Bool? {
        return sweeperControl?.hadFrame
    }

    func areaSelected(_ view: SweeperHomeMapView) -> [Int]? {
        if cleaningModeType == .areaClean {
            return selectedLayerID
        } else {
            return nil
        }
    }

    func homeMapViewIsSetPreference(_ view: SweeperHomeMapView) -> Bool {
        return isSetPreference()
    }

    func homeMapViewIsSetSeq(_ view: SweeperHomeMapView) -> Bool {
        return isSetSweepSeq()
    }

    func layer(_ view: SweeperHomeMapView, layerSelectedSequence layerID: Int) -> Int? {
        if cleaningModeType == .areaClean, let orderID = selectedLayerID.firstIndex(of: layerID) {
            return orderID
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, layerCleaningOrder layerID: Int) -> Int? {
        if let order = sweeperControl?.mapModel?.areaModel.areaCleaningOrder,
           let orderID = order.firstIndex(of: layerID) {
            return orderID + 1
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, selectedLayer layerID: Int) {
        if let index = selectedLayerID.firstIndex(of: layerID) {
            selectedLayerID.remove(at: index)
        } else {
            selectedLayerID.append(layerID)
        }
        if cleaningModeType == .areaClean && !selectedLayerID.isEmpty {
            ToastView.showWarningToast(title: "已选择(selectedLayerID.count)个区域", existTime: nil, centerY: .low)
        }
        updateClearingAreaButton()
        mapView.refreshAreaAndLabelView()
    }
}

extension SweeperMainViewController {

    // 物体抓拍气泡展示
    private func captureBubbleViewShow(captureView: UIImageView, titleText: String, iconImage: UIImage, status: CaptureImageLoadingStatus, obstacleID: Int, thumbnail: UIImage? = nil) {
        sweepCaptureView.removeFromSuperview()
        captureBubbleViewLayout(captureView: captureView)
        sweepCaptureView.delegate = self

        // 更新障碍物抓拍气泡的展示
        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: thumbnail, obstacleID: obstacleID)

        // 更新障碍物抓拍是否有缩略图以及缩略图状态
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl?.barrierRecognitionEnabled ?? false, captureImageStatus: status)

        self.view.layoutIfNeeded()
        self.autoSuitPosition()
    }

    private func captureBubbleViewLayout(captureView: UIImageView) {
        self.mapView.addSubview(sweepCaptureView)
        sweepCaptureView.snp.remakeConstraints { make in
            make.centerX.equalTo(captureView.snp.centerX)
            make.bottom.equalTo(captureView.snp.top).offset(-12)
            make.width.equalTo(159)
            if sweeperControl?.barrierRecognitionEnabled ?? false {
                make.height.equalTo(128)
            } else {
                make.height.equalTo(40)
            }
        }
    }

    // 物体抓拍气泡隐藏
    private func captureBubbleViewDismiss() {
        sweepCaptureView.dismiss()
    }

    private func autoSuitPosition() {
        var offsetX: CGFloat = 0
        var offsetY: CGFloat = 0
        let maxXCoordinate = mapView.frame.width - sweepCaptureView.frame.width - 16
        if sweepCaptureView.frame.origin.x < 16 {
            offsetX = 16 - sweepCaptureView.frame.origin.x
        } else if sweepCaptureView.frame.origin.x > maxXCoordinate {
            offsetX = maxXCoordinate - sweepCaptureView.frame.origin.x
        }

        if sweepCaptureView.frame.origin.y < 16 {
            offsetY = 16 - sweepCaptureView.frame.origin.y
        }
        // 不用考虑底部超出边界，因为弹窗从顶部出现

        mapView.moveBy(x: offsetX, y: offsetY)
    }

    /// 刷新当前正在展示的气泡及其内容
    private func refreshBubbleView() {
        guard let sweeperControl = sweeperControl,
              let obstacleID = obstacleID,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              let iconImage = barrier.type.bigImage,
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            captureBubbleViewDismiss()
            return
        }
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
            return
        }

        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: .loading)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { [weak self] (status, image) in
            self?.sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: image, obstacleID: obstacleID)
            self?.sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: status)
        }
    }

}

extension SweeperMainViewController: SweeperMapManagerViewControllerDelegate {
    func mapManagerBeginSweep(_ controller: SweeperMapManagerViewController) {
        // 强制扫地机进入新建地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .autoClean)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    func mapManagerFastMap(_ controller: SweeperMapManagerViewController) {
        // 开始快速建图
        startFastMapAlert()
    }
}

extension SweeperMainViewController: SweeperCaptureBubbleViewDelegate {
    func captureNextButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.titleLabel.textColor = UIColor.black.withAlphaComponent(0.5)
        // 获取全部障碍物的详情页
        let sweepCaptureNextPageViewController = SweeperCaptureNextPageViewController(deviceID: deviceID, listType: listType)
        sweepCaptureNextPageViewController.delegate = self

        // 更新详情页跳转到具体哪个页面
        sweepCaptureNextPageViewController.obstacleID = captureView.obstacleID
        self.navigationController?.pushViewController(sweepCaptureNextPageViewController, animated: true)
    }

    func reloadButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.imageStatus = .loading
        let barrierID = captureView.obstacleID
        guard let fileID = sweeperControl?.barriersModel?.barrierDictionary[barrierID]?.fileID else {
            return captureView.imageStatus = .loadNoImage
        }

        SweeperDownloader.downloadObstacleImage(forDevice: deviceID, listType: listType, fileID: fileID) { status, image in
            captureView.imageStatus = status
            captureView.titleImageView.image = image
        }
    }

    func handleGestures(enable: Bool) {
        mapView.isGestureEnable = enable
    }
}

extension SweeperMainViewController: SweeperMainMapLoadingViewDelegate {
    func reloadButtonDidClick(_ UIView: SweeperMainMapLoadingView) {
        refreshMediaPlayerAndSweeperControl()
    }
}

extension SweeperMainViewController: SweeperIconMapViewDelegate {
    func didTapBaseStation(in view: SweeperIconMapView) {
        baseStationButtonDidClick()
    }

    func iconMap(_ view: SweeperIconMapView, transforToScreenPointFrom realPoint: CGPoint) -> CGPoint? {
        // 之前未调用
        return nil
    }

    func didTapObstacle(in view: UIImageView, obstacleID: Int) {

        guard let sweeperControl = sweeperControl,
              let iconImage = sweeperControl.barriersModel?.barrierDictionary[obstacleID]?.type.bigImage,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            return
        }
        self.obstacleID = obstacleID
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loadNoImage, obstacleID: obstacleID)
            return
        }

        self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loading, obstacleID: obstacleID)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { status, image in
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: status, obstacleID: obstacleID, thumbnail: image)
        }
    }
}

extension SweeperMainViewController: SweeperNewPasswordProtocol {
    func checkUnAuthenticated() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperModule.shared.requiredService?.checkUserInfo(deviceID: deviceID, listType: listType, completion: { [weak self] (success, errorCode) in
            ToastView.dismissLoadingToast()
            guard let self = self else {
                return
            }
            if success {
                self.goToPreview()
                return
            }

            if errorCode == TPSS_ASYNC_EC_TIMEOUT || errorCode == TPSS_COMM_EC_SYSTEM {
                /* 请求超时 */
                ToastView.showWarningToast(warningMessage: "网络错误")
                return
            }

            /* 设备锁定 */
            if errorCode == TPSS_COMM_EC_PREVIEW_LOCKED {
                self.showAlertWith(title: SharedResource.sharedString(key: sweeperPreviewLockedAlertTitle), defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil)
                return
            }

            /* 鉴权失败,弹出密码输入框 */
            self.presentInputPasswordVC(deviceID: self.deviceID, listType: self.listType)

        })
    }
}

extension SweeperMainViewController: SweeperVerifyPasswordProtocol {
    func verifySuccessHandler() {
        goToPreview()
    }
}

extension SweeperMainViewController: SweeperCaptureNextPageViewControllerDelegate {
    func ignoreButtonDidClick(sweeperCaptureNextPageViewController: SweeperCaptureNextPageViewController, barrierID: Int) {
        // 点击障碍物抓拍详情页的“忽略”所对应的障碍物Id
        guard let mapID = map?.currentMapID else {
             return
        }
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestIgnoreBarrier(device: deviceID, channel: channel, listType: listType, barrierID: "(barrierID)", mapID: mapID).always {
            ToastView.dismissLoadingToast()
        }.then { [weak self] (_) in
            ToastView.showWarningToast(warningMessage: "已忽略该物体")
            self?.sweepCaptureView.dismiss()
            self?.goBackToSweeperMainViewController()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperMechanicalOffViewDelegate {
    func refreshButtonDidClick(in: SweeperMechanicalOffView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        sweeperMechanicalOffView.refreshLoadingUI(connectedState: .loading)
        view.bringSubviewToFront(sweeperMechanicalOffView)
        SweeperService.getSweeperState(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType).then { [weak self] (state) in
            guard let state = state else {
                return
            }
            self?.showMechanicalOffView(switchOn: state.mechanicalSwitchOn)
        }
    }

    func showMechanicalOffView(switchOn: Bool) {
        // 若开关关闭
        if !switchOn {
            isShowingMechanicalView = true
            sweeperMechanicalOffView.refreshLoadingUI(connectedState: .off)
        } else {
            isShowingMechanicalView = false
        }
    }
}

extension SweeperMainViewController: SweeperMoreActionViewControllerDelegate {
    func cleanWholeHouse(in vc: SweeperMoreActionViewController) {
        showSweepTipsAlert()
    }
}

extension SweeperMainViewController: SweeperFastMapSheetDelegate {
    func startFastMap(view: SweeperFastMapSheet) {
        startFastMapAlert()
    }
}

extension String {
    func separatedBySemiColon(isAutoFill: Bool = true) -> (String, String?) {
        let seperator = self.contains(":") ? ":" : "："
        let separatedTexts: [String] = self.components(separatedBy: seperator)
        if !isAutoFill && separatedTexts.count == 1 {
            return (separatedTexts[0], nil)
        } else {
            return (separatedTexts.count >= 1 ? separatedTexts[0] : "", separatedTexts.count >= 2 ? separatedTexts[1] : "")
        }
    }
}
//
//  OnlineDeviceListMasterViewController.swift
//  SurveillanceHome
//
//  Created by Li Linfeng on 2019/12/9.
//  Copyright © 2019 tplink. All rights reserved.
//

import UIKit
import SurveillanceHomeBase
import SharedResource
import TPFoundation
import DeviceDetailModule
import NetService

private var pageIndexAssociatedObjectHandle: UInt8 = 0

final class OnlineDeviceListMasterViewController: BaseViewController {
    @IBOutlet private weak var groupCollectionView: UICollectionView!
    @IBOutlet private weak var groupToolbarShadowView: UIView!
    @IBOutlet private weak var groupToolbarContainer: UIView!
    @IBOutlet private weak var groupToolbarDropMenuButton: UIButton!
    @IBOutlet private weak var recentPreviewView: RecentPreviewView!
    @IBOutlet private weak var containerViewBottom2SuperViewBottomConstraint: NSLayoutConstraint!
    @IBOutlet private weak var containerViewTop2TopLayoutGuideBottomConstraint: NSLayoutConstraint!

    override var navigationBarTraits: [NavigationBarTrait] {
        return NavigationBarTrait.noSeparator
    }

    private var deviceGroups: [TPSSDeviceGroup] = []
    private var currentGroupIndex: Int = 0

    private var newCreateGroupName = ""

    private var pageController: UIPageViewController!
    private var deviceListVCCacheDictionary = [TPSSDeviceGroupID: OnlineDeviceListViewController]()
    private var transitionVCForPageController = UIViewController()
    lazy private var loginCacheVC = DeviceListLoginViewController.create()

    private var firstAppear = true
    private var shouldRecreate: Bool = false

    /// for routers' entry
    private var isLoginBefore = false

    var sdCardStatusShowed: SDCardStatusShowed = .none
    var diskStatusShowed: SDCardStatusShowed = .none

    // camera display
    private var shouldShowCameraDisplayNoActiveChannelAlert = false
    private var addChannelCameraDisplay: TPSSDeviceForDeviceList?

    // navigation
    private lazy var moreToolBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(moreToolsButtonClicked(_:)))
    }()

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_add_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(addDeviceButtonClicked(_:)))
    }()

    // MARK: guides and overlays
    private weak var addDeviceGuideView: GuidePresentationView?
    private weak var moreToolsPopoverView: GuidePresentationView?

    private lazy var groupPresenter = GroupListPresentationManager()
    private var presentedGroupList: GroupListViewController? {
        return presentedViewController as? GroupListViewController
    }

    private var currentList: OnlineDeviceListViewController {
        if let viewControllers = pageController.viewControllers, let firstViewController = viewControllers.first as? OnlineDeviceListViewController {
            return firstViewController
        }
        return OnlineDeviceListViewController()
    }

    private var isCloudLogin: Bool {
        return DeviceListModule.shared.requiredService?.isCloudLogin ?? false
    }

    private var isReordering = false                // 是否正在处于排序模式
    private var shouldToggleGroupModeAfterGetList = false   // 是否需要在获取列表结束后切换防护模式，仅在列表还未获取完时触发防护模式切换使用

    private var isShowing: Bool {
        return isShowing(ignorePresentedClasses: [UIAlertController.classForCoder()])
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        setupView()

        NotificationCenter.default.addObserver(self, selector: #selector(handleShowCameraDisplayNoActiveChannelAlertNotification(_:)), name: .ShowCameraDisplayNoActiveChannelAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleShowStorageDetectAlertNotification(_:)), name: .ShowStorageDetectAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListInvalidated), name: .DeviceListInvalidated, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListUpdated), name: .DeviceListUpdated, object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderBegined(_:)),
                                               name: .DeviceListReorderBegined,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderEnded(_:)),
                                               name: .DeviceListReorderEnded,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupAndDeviceList(_:)),
                                               name: .UpdateGroupAndDeviceListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: DeviceListNetworkObserver.localDeviceRefreshed,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupList(_:)),
                                               name: .UpdateGroupListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: .unbindDiscoveryFinished,
                                               object: nil)

        _ = DeviceListModule.shared.requiredService?.addEntrustObserver(observeTypes: [.entrustmentStop, .entrustmentExitByTrustee], { (_, _) in
            DeviceListManager.shared.updateDeviceList(of: DeviceListManager.shared.defaultGroupID).always {
                self.currentList.reload()
            }
        })
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        showGroupAndNavigationButton(true)
        if !isCloudLogin {
            showEmpty()
        } else if firstAppear {
            firstAppear = false
            restore()
        } else if shouldRecreate {
            shouldRecreate = false
            reload()
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        checkUpdateIfNeeded()

        if isCloudLogin {
            showPopoverGuideIfNeeded()
        }

        if shouldShowCameraDisplayNoActiveChannelAlert {
            shouldShowCameraDisplayNoActiveChannelAlert = false
            showCameraDisplayNoActiveChannelAlert()
        }
        updateGroupShadow()
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)

        dismissPresentedViews()
    }

    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let vc = segue.destination as? UIPageViewController {
            pageController = vc
            pageController.dataSource = self
            pageController.delegate = self
        }
    }

    private func refreshAfterGroupUpdated() {
        guard !isReordering else {
            return
        }

        guard isShowing else {
            // 如果分组刷新完，此时页面不是正在显示，则不进行页面刷新，仅记录状态，等回到本页面才统一进行刷新。
            // 需要注意通过记录状态后续回到页面才处理的逻辑，要与本方法后续处理逻辑要保持一致
            shouldRecreate = true
            return
        }

        reload()
    }

    private func showEmpty() {
        deviceGroups = []
        currentGroupIndex = -1

        showGroupAndNavigationButton(false)

        let emptyVC: UIViewController?
        // 有发现出来的/已绑定到局域网的设备时显示带登陆按钮的设备列表；没有则显示普通的登陆提示页
        if DeviceListManager.shared.unbindDetailDeviceList().count > 0 {
            emptyVC = createUnloginPage()
        } else {
            emptyVC = loginCacheVC
        }
        if let emptyVC = emptyVC {
            pageController.setViewControllers([emptyVC], direction: .forward, animated: false, completion: nil)
        }
        groupCollectionView.reloadData()
    }

    private func showGroupAndNavigationButton(_ shouldShow: Bool) {
        if shouldShow {
            navigationItem.leftBarButtonItem = moreToolBarButtonItem
            groupToolbarDropMenuButton.isHidden = false
        } else {
            navigationItem.leftBarButtonItem = nil
            groupToolbarDropMenuButton.isHidden = true
        }
    }

    private func restore() {
        deviceGroups = DeviceListManager.shared.groupList

        loadGroup(with: DeviceListManager.shared.lastSelectedGroupID)
    }

    private func reload(with preferredGroupID: String? = nil) {
        let oldGroupID = preferredGroupID ?? DeviceListManager.shared.lastSelectedGroupID
        deviceGroups = DeviceListManager.shared.groupList
        presentedGroupList?.groups = deviceGroups

        loadGroup(with: oldGroupID)
    }

    private func loadGroup(with groupID: String) {
        let currentGroup = DeviceListManager.shared.group(of: groupID) ?? DeviceListManager.shared.defaultGroup

        guard let groupIndex = deviceGroups.firstIndex(where: { $0.groupID == currentGroup.groupID }) else {
            return
        }

        currentGroupIndex = groupIndex

        presentedGroupList?.currentGroupID = currentGroup.groupID
        presentedGroupList?.reload()

        commonLoad()
    }

    private func commonLoad(animated: Bool = false, recreate: Bool = true) {
        groupCollectionView.reloadData()

        guard currentGroupIndex >= 0 else {
            return
        }

        groupCollectionView.scrollToItem(at: IndexPath(item: currentGroupIndex, section: 0), at: .right, animated: false)
        updateGroupShadow()

        if recreate, let vc = createPage(for: currentGroupIndex) {
            pageController.setViewControllers([vc], direction: .forward, animated: false, completion: nil)
        }

        storeGroupParameter()
    }

    private func updateGroupShadow() {
        groupToolbarShadowView.isHidden = groupCollectionView.bounds.maxX >= (groupCollectionView.contentSize.width - 1)
    }

    private func refreshAllDeviceLists() {
        if let viewController = pageController.viewControllers {
            viewController.forEach {
                if let vc = $0 as? OnlineDeviceListViewController {
                    vc.reload()
                }
            }
        }
    }

    private func createPage(for index: Int) -> OnlineDeviceListViewController? {
        let group = deviceGroups[index]
        guard let vc = createPage(for: group.groupID as TPSSDeviceGroupID) else {
            return nil
        }
        objc_setAssociatedObject(vc, &pageIndexAssociatedObjectHandle, index, .OBJC_ASSOCIATION_COPY_NONATOMIC)
        vc.realGroup = deviceGroups[index]
        return vc
    }

    private func createUnloginPage() -> OnlineDeviceListViewController? {
        return createPage(for: "unlogin page")
    }

    private func createPage(for key: TPSSDeviceGroupID) -> OnlineDeviceListViewController? {
        let vc: OnlineDeviceListViewController?
        if let item = deviceListVCCacheDictionary[key] {
            vc = item
        } else {
            vc = OnlineDeviceListViewController.create()
            deviceListVCCacheDictionary[key] = vc
        }
        return vc
    }
}

extension OnlineDeviceListMasterViewController: DeviceListUnwindDestination {}

// MARK: Popover handler
extension OnlineDeviceListMasterViewController {
    private func updateMenu() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let networkAvailable = NetworkManager.shared.isConnected
        let isInHomeMode = deviceGroups[currentGroupIndex].activeMode != .goOut
        let isBigCardMode = deviceGroups[currentGroupIndex].displayMode != .smallCard
        let homeModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_home_active") : DeviceListModule.image(named: "devicelist_home_disabled")
        let outModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_out_active") : DeviceListModule.image(named: "devicelist_out_disabled")
        DeviceGroupMenuItem.alarmMode.image = (isInHomeMode ? homeModeImage : outModeImage)?.withRenderingMode(.alwaysOriginal)
        DeviceGroupMenuItem.alarmMode.enabled = networkAvailable
        DeviceGroupMenuItem.alarmMode.title = isInHomeMode ? LocalizedString(key: deviceListModeHome) : LocalizedString(key: deviceListModeOut)
        DeviceGroupMenuItem.alarmMode.subtitle = isInHomeMode ? LocalizedString(key: deviceListSwitchModeToOut) : LocalizedString(key: deviceListSwitchModeToHome)
        DeviceGroupMenuItem.viewMode.title = isBigCardMode ? LocalizedString(key: deviceListViewGrid) : LocalizedString(key: deviceListViewList)
        DeviceGroupMenuItem.viewMode.subtitle = isBigCardMode ? LocalizedString(key: deviceListSwitchViewToList) : LocalizedString(key: deviceListSwitchViewToGrid)
        DeviceGroupMenuItem.viewMode.image = isBigCardMode ?  DeviceListModule.image(named: "devicelist_grid")?.withRenderingMode(.alwaysOriginal) : DeviceListModule.image(named: "devicelist_list")?.withRenderingMode(.alwaysOriginal)
    }

    private func handleDeviceGroupMenu(item: DeviceGroupMenuView.Item) {
        switch item {
        case .alarmMode:
            toggleGroupMode()
        case .search:
            navigateToSearch()
        case .viewMode:
            toggleDisplayMode()
        }
    }

    private func toggleGroupMode() {
        dismissPresentedViews()

        let deviceListUpdateStatus = DeviceListManager.shared.deviceListUpdateStatus
        if !deviceListUpdateStatus.cloudUpdateNecessaryInfoFinished {
            // 列表必要信息没获取到，此时若需要改变防护模式，就先请求获取数据并且loading，等所有信息获取完处理，避免数据不完整导致处理出错
            if !deviceListUpdateStatus.isUpdatingList {
                DeviceListManager.shared.updateGroupAndDeviceList()
            }
            shouldToggleGroupModeAfterGetList = true
            ToastView.showLoadingToast(cirleWithMessage: nil)
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.activeMode
        let newMode = group.activeMode == .goOut ? TPSSDeviceGroupMode.atHome : .goOut
        group.activeMode = newMode
        ToastView.showLoadingToast(cirleWithMessage: nil)
        DeviceListManager.shared.changeActiveMode(with: deviceGroups[currentGroupIndex]).then { () in
            self.currentList.reload()
            self.currentList.showToastForActiveMode(newMode)
        }.catch { (_) in
            group.activeMode = originalMode
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func toggleDisplayMode() {
        dismissPresentedViews()

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.displayMode
        let newMode = originalMode == .bigCard ? DeviceUIDisplayType.smallCard : .bigCard

        DeviceListManager.shared.changeDisplayMode(for: group.groupID, with: newMode)

        for section in 0..<currentList.collectionView.numberOfSections {
            for item in 0..<currentList.collectionView.numberOfItems(inSection: section) {
                if newMode == .smallCard {
                    currentList.fold(at: IndexPath(row: item, section: section))
                } else {
                    currentList.unfold(at: IndexPath(row: item, section: section))
                }
            }
        }

        currentList.reload()
    }

    private func navigateToSearch() {
        dismissPresentedViews()
        let allDevices = DeviceListManager.shared.allDetailDevices
        let allGroups = DeviceListManager.shared.groupList
        let vc = RemoteDeviceListSearchViewController(devices: allDevices, groups: allGroups)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }
}

extension OnlineDeviceListMasterViewController {
    // MARK: Popover
    private func showPopoverGuideIfNeeded() {
        // add device popover
        if UserDefaults.standard.object(forKey: deviceListLaunchKey) == nil {
            showAddDevicePopover()
            UserDefaults.standard.set(true, forKey: deviceListLaunchKey)
        }
    }

    private func showAddDevicePopover() {
        if !isShowing() {
            /* 如果界面切换了不要加载 */
            return
        }
        if let source = (navigationItem.rightBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            navigationController?.navigationBar.layoutIfNeeded()
            dismissPresentedViews()
            addDeviceGuideView = presentGuideWith(viewToPresent: TutorialGuideView.addDevice, size: TutorialGuideView.addDevice.frame.size, source: source, clickThrough: true)
            addDeviceGuideView?.delegate = self
        }
    }
}

extension OnlineDeviceListMasterViewController: GuidePresentationViewDelegate {
    func guidePresentationViewDidDismiss(_ view: GuidePresentationView) {
        if view == moreToolsPopoverView {
            navigationItem.leftBarButtonItem?.tintColor = UIColor(white: 0, alpha: 0.8)
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        }
    }
}

// MARK: - util
extension OnlineDeviceListMasterViewController {
    private func storeGroupParameter() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        DeviceListManager.shared.updateLastSelectGroupID(deviceGroups[currentGroupIndex].groupID)
    }
}

extension OnlineDeviceListMasterViewController {

    private func presentUpgradeInfo(appVersionInfo: AppUpgradeModuleBaseUpgradeInfo) {
        let alertViewController = DeviceListUpgradeAlertController(versionInfo: appVersionInfo)
        present(alertViewController, animated: true, completion: nil)
    }

    private func checkUpdateIfNeeded() {
        let requiredService = DeviceListModule.shared.requiredService
        guard requiredService?.shouldShowNewAppVersion() ?? false else {
            return
        }

        // 仅跳转至需要更新的包中（若对应版本的升级包needNotify为false，而另外版本的needNotify为true，会跳转至另一版本）
        if TPAppUtils.isTestFlightBeta() {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, appVersionInfo.needNotify, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        } else {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo, appVersionInfo.needNotify {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        }

    }
}

extension OnlineDeviceListMasterViewController: DeviceListSearchViewControllerDelegate {
    func navigateToGroup(group: TPSSDeviceGroup) {
        navigationController?.popViewController(animated: true)
        DispatchQueue.main.async {
            self.loadGroup(with: group.groupID)
        }
    }

    func navigateToSyncPreviewViewController(device: DeviceDetail) {
        goToSyncPreview(ipc: device, listType: device.listType)
    }

    func navigateToPreviewViewController(device: DeviceDetail, channel: TPSSChannelInfo?) {
        if device.deviceType == .smartLock {
            DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
            return
        }
        goToPreview(device: device, channel: channel)
    }

    func navigateToBatteryDoorbellViewController(device: DeviceDetail, fromNVR nvr: (deviceID: TPSSDeviceIdentifier, channel: UInt)?) {
        DeviceListModule.shared.requiredService?.navigateToBatteryDoorbellViewController(for: device.identifier, group: DeviceListManager.shared.defaultGroupID, listType: device.listType, navigator: navigationController, from: nvr?.deviceID, channelInNVR: nvr?.channel.intValue)
    }

    func navigateToNVRViewController(nvr: DeviceDetail) {
        var groupId = DeviceListManager.shared.defaultGroup.groupID
        if currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex {
            groupId  = deviceGroups[currentGroupIndex].groupID
        }
        goToNVR(nvr: nvr, groupID: groupId)
    }

    func navigateToSolarControllerManagerViewController(device: DeviceDetail) {
        goToSolarController(solarController: device)
    }

    func navigateToRouterManagerViewController(device: DeviceDetail) {
        goToRouter(device: device)
    }

    func navigateToSmartLockViewController(device: DeviceDetail) {
        DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
    }
}

// MARK: Navigation
extension OnlineDeviceListMasterViewController: PreviewControllerEntrance {
    func goToPreview(device: DeviceDetail, channel: TPSSChannelInfo?) {
        goToPreview(deviceID: device.identifier, channelID: channel?.channelId.intValue ?? -1, listType: device.listType)
    }

    func goToNVR(nvr: DeviceDetail, groupID: String? = nil) {
        let vc = NVRTabViewController()
        vc.cloudIdentifier = nvr.cloudDeviceID
        vc.deviceIdentifier = nvr.identifier
        vc.listType = nvr.listType
        vc.groupId = groupID
        navigationController?.pushViewController(vc, animated: true)
    }

    func goToSolarController(solarController: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToSolarControllerManagerViewController(deviceID: solarController.identifier, listType: solarController.listType, navigator: navigationController)
    }

    func goToRouter(device: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToRouterDefault(mac: device.mac, listType: device.listType, isOnline: device.online, navigator: navigationController)
    }
}

// MARK: Actions
extension OnlineDeviceListMasterViewController {
    private func dismissPresentedViews() {
        addDeviceGuideView?.dismiss()
        moreToolsPopoverView?.dismiss()

        presentedGroupList?.dismiss(animated: true, completion: nil)

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }

    @IBAction private func addDeviceButtonClicked(_ sender: Any) {
        guard isCloudLogin else {
            showAlertWith(title: LocalizedString(key: deviceListNotLogin), defaultButtonTitle: LocalizedString(key: deviceListLogin), defaultButtonHandler: { (_) in
                DeviceListModule.shared.requiredService?.navigateToLoginViewController(navigator: self.navigationController)
            })
            return
        }
        dismissPresentedViews()

        DeviceListModule.shared.requiredService?.presentDeviceAddViewController(viewController: self, listType: listType)
    }

    @IBAction private func moreToolsButtonClicked(_ sender: Any) {
        guard isCloudLogin else { return }

        if moreToolsPopoverView != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let size = CGSize(width: 212, height: 16 + DeviceGroupMenuView.Item.allCases.count * 44)
        let menuView = DeviceGroupMenuView(frame: CGRect(origin: .zero, size: size))
        menuView.action = handleDeviceGroupMenu

        dismissPresentedViews()

        updateMenu()

        if let source = (navigationItem.leftBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
            menuView.configurePopoverShadow(cornerRadius: 8)
            moreToolsPopoverView = presentGuideWith(viewToPresent: menuView, size: size, backgroundColor: .clear, source: source, offset: CGPoint(x: -12, y: 4))
            moreToolsPopoverView?.delegate = self
        }
        navigationItem.leftBarButtonItem?.tintColor = .theme1
    }

    @IBAction private func groupMenuToggled(_ sender: UIButton) {
        guard isCloudLogin else { return }

        if presentedViewController != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_up_small_normal"), for: .normal)

        let groups = DeviceListManager.shared.groupList
        guard let vc = GroupListViewController.create() else {
            return
        }
        let height = CGFloat(groups.count) * 52 + 72
        vc.preferredContentSize = CGSize(width: UIScreen.main.bounds.width, height: height)
        vc.modalPresentationStyle = .custom
        vc.transitioningDelegate = groupPresenter
        vc.groups = groups
        vc.currentGroupID = deviceGroups[currentGroupIndex].groupID
        vc.delegate = self
        present(vc, animated: true, completion: nil)
    }

    @IBAction private func recentPreviewClicked(_ sender: Any) {
        // 不会用到此按钮，但暂时保留
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDataSource {
    private func groupInformation(at index: Int) -> (String, Bool) {
        if deviceGroups.isEmpty { return (LocalizedString(key: deviceListMyDevice), true) }
        return (deviceGroups[index].groupName, index == currentGroupIndex)
    }

    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }

    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return max(1, deviceGroups.count)
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        return collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)
    }
}

extension OnlineDeviceListMasterViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        updateGroupShadow()
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDelegate {
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        if deviceGroups.isEmpty { return }
        dismissPresentedViews()
        loadGroup(with: deviceGroups[indexPath.item].groupID)
    }
}

extension OnlineDeviceListMasterViewController: DeviceGroupNameLayoutDelegate {
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, groupForItemAt indexPath: IndexPath) -> (name: String, selected: Bool) {
        return groupInformation(at: indexPath.item)
    }
}

// MARK: Page Management
extension OnlineDeviceListMasterViewController: UIPageViewControllerDataSource {
    func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex > 0 && currentGroupIndex < deviceGroups.count else { return nil }
        return createPage(for: currentGroupIndex - 1)
    }

    func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex >= 0 && currentGroupIndex < deviceGroups.count - 1 else { return nil }
        return createPage(for: currentGroupIndex + 1)
    }
}

extension OnlineDeviceListMasterViewController: UIPageViewControllerDelegate {
    func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
        if completed {
            if let viewControllers = pageViewController.viewControllers, let firtViewController = viewControllers.first {
                if let currentGroupIndex = objc_getAssociatedObject(firtViewController, &pageIndexAssociatedObjectHandle) as? Int {
                    self.currentGroupIndex = currentGroupIndex
                    commonLoad(animated: true, recreate: false)
                }
            }
        }
    }
}

// MARK: Group Management
extension OnlineDeviceListMasterViewController: GroupListViewControllerDelegate {
    func groupListViewController(_ groupListViewController: GroupListViewController, canMoveGroupTo destinationIndex: Int) -> Bool {
        guard deviceGroups.count > destinationIndex else {
            return false
        }
        let group = deviceGroups[destinationIndex]
        return !group.isDefaultGroup
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didMoveGroupAt sourceIndex: Int, to destinationIndex: Int) {
        // check if current group index has changed
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let originalGroup = deviceGroups[currentGroupIndex]
        deviceGroups.swapAt(sourceIndex, destinationIndex)
        if let newIndex = deviceGroups.firstIndex(of: originalGroup), currentGroupIndex != newIndex {
            currentGroupIndex = newIndex
        }
        // always invalidate page controller cache
        pageController.setViewControllers([currentList], direction: .forward, animated: false, completion: nil)
        groupCollectionView.moveItem(at: IndexPath(item: sourceIndex, section: 0), to: IndexPath(item: destinationIndex, section: 0))
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didSelectGroupAt index: Int) {
        dismissPresentedViews()
        loadGroup(with: deviceGroups[index].groupID)
    }

    func groupListViewControllerDidSelectCreatingNewGroup(_ groupListViewController: GroupListViewController) {
        dismissPresentedViews()
        guard let vc = CommonNameInputViewController.create() else {
            return
        }
        vc.navigationTitle = LocalizedString(key: deviceListSetGroupNameTitle)
        vc.doneButtonTitle = LocalizedString(key: commonNextStep)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didRequestEditingGroupAt index: Int) {
        dismissPresentedViews()
        guard let vc = GroupSettingViewController.create() else {
            return
        }
        vc.group = deviceGroups[index]
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewControllerDidDismiss(_ groupListViewController: GroupListViewController) {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
        _ = DeviceListManager.shared.updateGroupOrder(newGroup: deviceGroups)
    }
}

extension OnlineDeviceListMasterViewController: CommonNameInputViewControllerDelegate {
    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didCancelWith text: String) {
        navigationController?.popViewController(animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didFinishWith text: String) {
        guard deviceGroups.count > 0 else {
            navigationController?.popToViewController(self, animated: true)
            return
        }
        newCreateGroupName = text
        let vc = DeviceSelectionViewController(entry: .groupAddIndependent, group: DeviceListManager.shared.defaultGroupID, canProceedWithNoSelection: true)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, errorMessageFor text: String) -> (allowed: Bool, message: String?) {
        let error = TPSSDeviceListValidate.validateDeviceGroupName(text)
        if error != nil {
            return (true, error?.message)
        }

        if DeviceListManager.shared.groupList.contains(where: { $0.groupName == text }) {
            return (true, LocalizedString(key: deviceListNameExists))
        }
        return (true, nil)
    }

    func placeholderForNameInputViewController(_ nameInputViewController: CommonNameInputViewController) -> String? {
        return SharedResource.sharedString(key: shareStringLengthConstraint)
    }
}

extension OnlineDeviceListMasterViewController {
    @objc func handleShowCameraDisplayNoActiveChannelAlertNotification(_ noti: NSNotification) {
        if let (device, listType) = noti.object as? (DeviceDetail, TPSSDeviceListType), listType == .remote {
            shouldShowCameraDisplayNoActiveChannelAlert = true
            addChannelCameraDisplay = DeviceListManager.shared.device(with: device.identifier)
        }
    }

    @objc func handleShowStorageDetectAlertNotification(_ noti: NSNotification) {
        diskStatusShowed = .none
        sdCardStatusShowed = .none
    }

    private func showCameraDisplayNoActiveChannelAlert() {
        showAlertWith(title: LocalizedString(key: deviceAddCameraDisplayNoActiveChannelsTitle), defaultButtonTitle: LocalizedString(key: deviceAddAddNext), cancelButtonTitle: LocalizedString(key: commonNotNow), cancelButtonHandler: nil) { (_) in
            if let cameraDisplay = self.addChannelCameraDisplay {
                DeviceListModule.shared.requiredService?.navigateToCameraDisplayDiscoverViewController(deviceID: cameraDisplay.identifier, discoverType: .cameraDisplay, listType: self.listType, navigator: self.navigationController)
                // 需要在中间插一个ViewController
                let vc = NVRTabViewController()
                vc.cloudIdentifier = cameraDisplay.cloudDeviceId
                vc.deviceIdentifier = cameraDisplay.identifier
                vc.listType = .remote
                vc.hidesBottomBarWhenPushed = true
                if var tmpViewControllers = self.tpNavigationController?.viewControllers {
                    tmpViewControllers.insert(vc, at: tmpViewControllers.count - 1)
                    self.tpNavigationController?.setViewControllers(tmpViewControllers, animated: true)
                }
            }
        }
    }
}

extension OnlineDeviceListMasterViewController: DeviceSDCardStatusChecker {
    var listType: TPSSDeviceListType { return .remote }

    func formatProcessDidFinish() {
        currentList.reload()
    }
}

extension OnlineDeviceListMasterViewController: DeviceSelectionViewControllerDelegate {
    func deviceSelectionViewController(_ deviceSelectionViewController: DeviceSelectionViewController, didPressRightBarButtonItemWithDeviceChannels selectedDeviceChannels: [DeviceDetail: [ChannelId]]) {
        switch deviceSelectionViewController.entryType {
        case .groupAddIndependent:
            ToastView.showLoadingToast(cirleWithMessage: nil)

            let targetDeviceChannels = DeviceSelectionViewController.covertDeviceChannel(selectedDeviceChannels)
            DeviceListManager.shared.createGroup(name: newCreateGroupName, deviceChannelMap: targetDeviceChannels).always {
                ToastView.dismissLoadingToast()
            }.then { (groupID) in
                self.navigationController?.popToViewController(self, animated: true)
                self.reload(with: groupID)
            }.catch { (error) in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }
        default:
            break
        }
    }
}

// MARK: - notification
extension OnlineDeviceListMasterViewController {
    @objc private func handleDeviceListInvalidated() {
        shouldRecreate = true
        deviceListVCCacheDictionary.removeAll()
    }

    @objc private func handleDeviceListUpdated() {
        showUpdateAlertIfAny()
    }

    @objc private func handleReorderBegined(_ notification: Notification) {
        enterReorderMode()
    }

    @objc private func handleReorderEnded(_ notification: Notification) {
        exitReorderMode()
    }

    @objc private func handleUpdateGroupAndDeviceList(_ notification: Notification) {
        if isCloudLogin {
            handleGroupModeToggleAfterGetList(notification)
        } else if isShowing {
            // 处理非登录场景

            // 仅页面正在显示才处理数据获取结果更新页面状态，否则等viewWillAppear再处理。避免正在获取列表
            // 时切换到其它页面，列表获取有结果后触发本逻辑使得子VC触发viewWillAppear，后续真正展示页面时
            // 就不再触发viewWillAppear导致数据异常
            showEmpty()
        }
    }

    @objc private func handleLocalDeviceRefreshed(_ notification: Notification) {
        if !isCloudLogin && isShowing {
            // 非登录且页面正在显示时才需要处理因网络状态变化重新发现完的通知，因为此时可能需要在有/无设备的页面之间切换。
            // 如果页面没有在显示则不需要处理，因为viewWillAppear会触发该逻辑
            showEmpty()
        }
    }

    @objc private func handleUpdateGroupList(_ notification: Notification) {
        if let dic = notification.object as? [String: Any],
           let error = dic[DeviceListManager.notificationKeyError] as? Error {
            ToastView.showWarningToast(title: error.localizedDescription, existTime: nil, centerY: .lowest)
            return
        }
        // 失败也更新，此时显示默认分组
        refreshAfterGroupUpdated()
    }

    private func handleGroupModeToggleAfterGetList(_ notification: Notification) {
        let finishHandler: (() -> Void) = {
            if self.shouldToggleGroupModeAfterGetList {
                ToastView.dismissLoadingToast()
                self.shouldToggleGroupModeAfterGetList = false
                self.toggleGroupMode()
            }
        }

        guard let dic = notification.object as? [String: Any],
              let status = dic[DeviceListManager.notificationKeyListUpdateStatus] as? DeviceListUpdateStatus else {
            finishHandler()
            return
        }

        if status.cloudUpdateNecessaryInfoFinished {
            finishHandler()
        }
    }
}

extension OnlineDeviceListMasterViewController: Storyboarded {
    static var storyboardName: String { return "DeviceList" }
    static var storyboardBundle: Bundle? { return Bundle.deviceListModuelBundle }
}

extension Notification.Name {
    static var DeviceListUpdated: Notification.Name { return Notification.Name("DeviceListUpdated") }
}

// MARK: - setup
extension OnlineDeviceListMasterViewController {
    private func setupView() {
        setupBarButtonItems()
        setupButtons()
    }

    private func setupBarButtonItems() {
        navigationItem.leftBarButtonItem = moreToolBarButtonItem
        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
    }

    private func setupButtons() {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }
}

// MARK: - reorder
extension OnlineDeviceListMasterViewController {
    // 本vc不会主动进入排序模式，而是依赖于OnlineDeviceListViewController的通知
    private func enterReorderMode() {
        isReordering = true
        tabBarController?.tabBar.isUserInteractionEnabled = false
        groupToolbarContainer.isUserInteractionEnabled = false

        pageController.scrollEnable = false

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
    }

    private func showUpdateAlertIfAny() {
        if DeviceListManager.shared.allDetailDevices.contains(where: {(DeviceListModule.shared.requiredService?.onboardingTypeFromQRCode(qrCode: $0.qrCode) ?? 0) == TPSS_EC_GENERAL} ) || DeviceListManager.shared.hasUnsupportedDevice {
            // 二维码获取不支持的设备或者读取设备列表中有不支持的设备时，弹出升级提示
            let lastVersion: (isShow: Bool, versionCode: Int) = DeviceListModule.shared.requiredService?.checkShowUpdateAlert() ?? (false, 0)
            if lastVersion.isShow {
                showAlertWith(title: LocalizedString(key: commonNoticeUpdateAPP), message: nil, messageTextAlignment: nil,
                              defaultButtonTitle: LocalizedString(key: commonUpdateNow), defaultButtonColor: .theme1,
                              cancelButtonTitle: LocalizedString(key: commonIgnoreNotice), cancelButtonColor: .black.withAlphaComponent(0.8),
                              cancelButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.updateUserNoMoreNotify(version: lastVersion.versionCode)
                    self.showDiskAlertIfAny()
                }, defaultButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.jumpAndCheckAppVersion()
                    self.showDiskAlertIfAny()
                })
            } else {
                showDiskAlertIfAny()
            }
        } else {
            showDiskAlertIfAny()
        }
    }

    private func exitReorderMode() {
        tabBarController?.tabBar.isUserInteractionEnabled = true
        groupToolbarContainer.isUserInteractionEnabled = true

        pageController.scrollEnable = true

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }

        isReordering = false
    }
}
//
//  SweeperMainViewController.swift
//  Pods
//
//  Created by 爱迪生 on 2021/8/2.
//

import UIKit
import SurveillanceHomeBase
import Promises
import SwiftyJSON
import SharedResource
import TPFoundation
import SimplePlayer
import DeviceDetailModule
import SnapKit
import NetService
import ThemeTool

enum CaptureImageLoadingStatus: Equatable {
    case loadSuccess
    case failure
    case loading
    case loadNoImage
    case model(SweeperBarrierType)
}

enum MainMapLoadingState {
    case loading
    case failure
    case noMap
    case hasMap
}

class SweeperMainViewController: SweeperGlobalConfigurationViewController {
    var needShowFastMapGuide: Bool = false
    // MARK: subviews
    private var previewButton: SweeperButton?
    weak var inputPasswordVC: UIViewController?
    var inputPassword: String?
    private var editButton: SweeperButton?
    private var baseStationButton: SweeperButton?
    private var moreButton: SweeperButton?
    private var parameterButton = SweeperButton()
    private var navigationTitleView = SweeperTitleBatteryView()
    private var chargeButton = SweeperButton()
    private var createMapContainer: SweeperCreateMapView?
    private var sweepAreaPopView: SweeperClearAreaPopView?
    private var sweeperAlarmViewController: (UIViewController & SweeperAlarmWindowSuitable)?
    private var startCleanAnimationView: SweeperStartCleanAnimationView?
    private var mapView = SweeperHomeMapView(frame: .zero, mapSize: .init(width: 1200, height: 1200))
    private var loadingView = SweeperMainMapLoadingView(frame: .zero)
    private var buttonContainerStackView = UIStackView()
    private var environmentView = UIView(frame: .zero)
    private var temperatureView = UILabel(frame: .zero)
    private var humidityView = UILabel(frame: .zero)
    private var equipmentOfflineView: SweeperRobotOfflineView?

    private var sweepControlView = SweeperControlView()
    private var sweepCaptureView = SweeperCaptureBubbleView()
    private var sweeperBaseUpgradingView = SweeperBaseStationUpgradingView()
    private var sweeperMechanicalOffView = SweeperMechanicalOffView()

    private var sweepControlViewHeightConstraint: NSLayoutConstraint?
    private var heightForControlView: CGFloat {
        switch status {
        case .stop:
            return 88 + bottomSafeAreaInset
        case .fastMap, .fastMapPause:
            return 69 + bottomSafeAreaInset
        case .sweepingPause, .sweeping:
            return 143 + bottomSafeAreaInset
        }
    }

    enum AlarmButtonClickMode {
        case exit
        case more
        case none
    }
    private var alarmButtonClickMode: AlarmButtonClickMode = .exit

    // 快速建图引导view
    private var fastMapImageView: UIImageView?
    private var fastMapGuideView: GuidePresentationView?


    // 地图已自动保存通知
    private var savedMapNoticeView: UIImageView?
    private var saveMapGuideView: GuidePresentationView?
    // 存储设备详细信息
    private var deviceDetail: DeviceDetail?
    private var isSharedDevice: Bool {
        return deviceDetail?.isSharedDevice ?? false
    }

    private var robotOffline = false
    private var hadStartWaveAnimation = false

    /// 首次载入
    /// 第一帧地图帧/路径帧到来时刷新所有界面
    private var needRefreshMapViewInMediaPlayer = true
    private var needEntrySaveMapLogic = true
    private var needShowCleaningLog = true

    /// 该属性用于，当前保存地图弹窗弹出时，扫地机正在清扫。保存该弹出状态，在清扫结束后再进入一遍保存地图逻辑。
    private var needEntrySaveMapLogicAfterBasicStateChanged = false


    /// 在地图变化时，将下列是否需要展示“地图保存”弹窗标识为true
    /// 在dataloading成功时，进行展示
    private var needShowSaveMapMultiFloor = false
    private var needShowSaveMapSingleFloor = false
    private var needShowMapHasSavedTip = false

    /// 基站升级与关机页面展示
    private var isShowingUpgradingView: Bool {
        get {
            return !sweeperBaseUpgradingView.isHidden
        }
        set {
            sweeperBaseUpgradingView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var isShowingMechanicalView: Bool {
        get {
            return !sweeperMechanicalOffView.isHidden
        }
        set {
            sweeperMechanicalOffView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var shouldShowChargeButton: Bool {
        get {
            guard let state = state else {
                return false
            }
            // 清扫完成并且不在基站上
            return state.cleanFinished && !state.onboard
        }
    }

    private var firstTimeUpdateNavigationTitle: Bool = true

    private var cleaningMode: SweeperCleaningMode {
        get {
            return sweeperControl?.cleaningMode ?? SweeperCleaningMode.init(type: .autoClean)
        }
        set {
            sweeperControl?.cleaningMode = newValue
            updateCleaningModeUI()
        }
    }

    private var cleaningModeType: CleaningModeType {
        get {
            return cleaningMode.type
        }
        set {
            cleaningMode.type = newValue
        }
    }

    override var sweeperCustomOrAutoMode: SweeperCustomOrAutoMode {
        get {
            return (sweeperControl?.customCleanEnabled ?? false) ? .custom : .auto
        }
        set { }
    }

    private var map: SweeperMap? {
        get {
            return sweeperControl?.map
        }
        set {
            let preMap = map
            sweeperControl?.map = newValue
            currentMapDidChanged(preMap: preMap)
        }
    }

    private var status: SweeperProcedure = .stop

    private var state: SweeperState? {
        get {
            return sweeperControl?.basicState
        }

        set {
            sweeperControl?.basicState = newValue
            basicStateChangeAction(showToast: true)
        }
    }

    private var temperatureText: String {
        get {
            var text = "环境温度："
            if let temperature = state?.temperature {
                let temperatureValue = Int(temperature)
                if temperatureValue == 127 || temperatureValue < -40 {
                    text += "--"
                } else {
                    text += "(Int(temperature))℃"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var humidityText: String {
        get {
            var text = "环境湿度："
            if let humidity = state?.humidity {
                let humidityValue = Int(humidity)
                if humidityValue < 0 || humidityValue > 100 {
                    text += "--"
                } else {
                    text += "(Int(humidity))%"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var cleaningState: SweeperCleaningState? {
        get {
            return sweeperControl?.cleaningState
        }

        set {
            sweeperControl?.cleaningState = newValue
            updateCleaningStateUI()
        }
    }

    private var isRecharging: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .recharge
    }

    private var forbiddenRechargeAndClean: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .assignLocation || state.mainState == .remoteControl
    }

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = SharedResource.sharedImage(named: "shared_setting_icon_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(settingBarButtonItemDidClick))
    }()

    // selected layerID backup
    private var selectedLayerID = [Int]()

    // 当前展示的障碍物ID
    private var obstacleID: Int?

    override var navigationBarTraits: [NavigationBarTrait] {
        return [.hidden(on: false), .style(style: .default), .translucent(on: false), .barTint(color: .init(hexString: lightGray10Color)), .separatorStyle(color: .clear, height: 0.0), .backgroundImage(image: UIImage())]
    }

    // MARK: - Constants
    private let chargeButtonPadding = 8.0
    private let defaultButtonPadding = 12.0
    private let defaultButtonInterval = 59.0
    private let battreyThreshold = 20
    private let bottomSafeAreaInset = TPUIUtils.safeAreaInsets().bottom

    override init(deviceID: TPSSDeviceIdentifier, listType: TPSSDeviceListType) {
        super.init(deviceID: deviceID, listType: listType)

        SweeperModule.shared.registerControlListener(listener: self, deviceID: deviceID, listType: listType)
        SweeperModule.shared.registerMapListener(mapListener: self)
        NotificationCenter.default.addObserver(self, selector: #selector(willEnterForeground), name: UIApplication.willEnterForegroundNotification, object: nil)
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        view.backgroundColor = .init(hexString: lightGray10Color)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        setupNavigation()
        setupControlView()
        setupMapView()
        setupSweeperAlarmView()
        setupButtons()
        setupOfflineView()
        setupEnvironmentView()
        setupLoadingView()
        setupUpgradingView()
        setupMechanicalOffView()
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true

        // 离开当前页面时，会使动画失效，若正在展示动画，再重新进入时，需要重新开始动画
        if hadStartWaveAnimation {
            startWaveAnimation()
        }

        if let loadingState = sweeperControl?.dataLoadingState {
            dataLoadingStateChangeAction(loadingState: loadingState)
        } else {
            updateViewShowState(state: .failed)
        }
        captureBubbleViewDismiss()
        // 横幅始终展示在最前方
        if let alarmView = sweeperAlarmViewController?.view {
            view.bringSubviewToFront(alarmView)
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        if needShowFastMapGuide {
            showFastMapGuideView()
            needShowFastMapGuide = false
        }
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        savedMapNoticeView?.removeFromSuperview()
    }

    deinit {
        SweeperModule.shared.removeControlListener(listener: self)
        SweeperModule.shared.removeMapListener(mapListener: self)
        NotificationCenter.default.removeObserver(self)
    }

    // 将从后台切换到前台，看作视图willAppear，方法作相同处理
    @objc func willEnterForeground() {
        cleanAllFlag()

        // 若当前的载入状态为loading时，对UI进行loading状态的刷新。
        // 否则等待dataLoadingStateDidChanged方法回调(从 loading -> 其他状态)。
        // 注：dataLoadingStateDidChanged方法在 loading -> loading 时不会被调用。
        if sweeperControl?.dataLoadingState == .loading {
            dataLoadingStateChanged(loadingState: .loading)
        }
    }

    /// 根据载入状态更新主页面View的展示情况
    /// -主页面加载状态 -
    /// 需要管理的控件：创建地图按钮、主页面地图、载入（载入失败）页面、编辑地图按钮、边扫边拖（定制清扫）悬浮按钮
    private func updateViewShowState(state: SweeperDataLoadingState) {
        switch state {
            case .loading:
                loadingView.isHidden = false
                loadingView.isLoadingFailure = false
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
            case .failed:
                loadingView.isLoadingFailure = true
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
                // 若扫地机离线，则展示离线页面，否则展示加载失败页面
                loadingView.isHidden = robotOffline
                equipmentOfflineView?.isHidden = !robotOffline
            case .noMap:
                createMapContainer?.isHidden = false
                loadingView.isHidden = true
                mapView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                parameterButton.isHidden = false
                moreButton?.isHidden = false
                editButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
            case .success:
                loadingView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                mapView.isHidden = false
                createMapContainer?.isHidden = true
                parameterButton.isHidden = false
                editButton?.isHidden = false
                moreButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
        }
    }

    override func willUpdateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode, showAlert: Bool) -> Bool {
        /// 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            if showAlert {
                showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap)
            }
            return false
        }
        return super.willUpdateSweeperCustomOrAutoMode(newMode: newMode, showAlert: showAlert)
    }

    override func updateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode) {
        /// 1. 若切换时当前清扫模式与newMode相同，则无需进入后续逻辑
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap,
              let sweeperControl = sweeperControl,
              let mapID = sweeperControl.map?.currentMapID,
              newMode != sweeperCustomOrAutoMode else {
            return
        }

        /// 2. 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap) { [weak self] (_) in
                self?.configurationView?.selectSegment(type: .auto)
            }
            return
        }

        /// 3. 切换为定制清扫时，无设置清扫顺序与清扫偏好，则不向设备发送请求（并在退出弹窗时（configurationFinished）切换回变扫边拖）
        if newMode == .custom && !isSetPreference() && !isSetSweepSeq() {
            return
        }

        /// 4. 发送切换清扫模式的接口，并修改主页面UI
        let customCleanEnabled = newMode == .custom
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestSetCleaningParam(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: mapID, customEnabled: customCleanEnabled).always {
            ToastView.dismissLoadingToast()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }

    override func configurationFinished() {
        /// 若configurationView当前处于定制清扫页面（“1”状态），则判断是否已设置定制清扫，若否切回边扫边拖。
        if !isSetPreference() && !isSetSweepSeq() && !settingButtonDidClickFlag && configurationView?.segmentedControl.selectedSegmentIndex == 1 {
            ToastView.showWarningToast(title: "未设置定制清扫，只能使用普通清扫", existTime: nil, centerY: .low)
            // 0 - means auto cleaning
            configurationView?.selectSegment(type: .auto)
        }
    }

    override func preferenceButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.preferenceButtonClickOperation()
    }

    override func sweepOrderButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.sweepOrderButtonClickOperation()
    }

    private func refreshMediaPlayerAndSweeperControl() {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.refreshSweeperControl()
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
    }

    private func updateConfigurationView() {
        configurationView?.selectSegment(type: sweeperCustomOrAutoMode)
        if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
            cleanMethodMode = mode
        }
    }

    private func updateClearingAreaButton() {
        var text = "全屋"
        var imagePath = "sweep_home"
        var title = text
        switch cleaningModeType {
        case .pointClean:
            text = "选框"
            title = text
            imagePath = "sweep_frame"
        case .areaClean:
            text = "区域"
            title = text
            imagePath = "sweep_region"
        case .autoClean:
            text = "全屋"
            title = text
            imagePath = "sweep_home"
        case .partClean:
            // 仅在sweepControlView的RangeTitle中修改
            updateData(with: .autoClean)
            title = "局部"
        case .fastMap:
            // DO NOTHING
            return
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
        sweepControlView.clearAreaButton?.titleLabel.text = text
        sweepControlView.clearAreaButton?.titleImageView.image = UIImage.image(named: imagePath)
        sweepControlView.rangeTitleLabel.text = title
        sweepControlView.clearAreaButton?.selectedAreaNumber = cleaningModeType == .areaClean ? selectedLayerID.count : 0
    }

    private func updateSweeperHomeMapViewCleanMode() {
        switch cleaningModeType {
        case .pointClean:
            mapView.cleaningModeType = .pointClean
        case .areaClean:
            mapView.cleaningModeType = .areaClean
        case .autoClean:
            mapView.cleaningModeType = .autoClean
        case .partClean:
            mapView.cleaningModeType = .partClean
        case .fastMap:
            mapView.cleaningModeType = .fastMap
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
    }

    private func updateSelectedLayerID() {
        if let seq = sweeperControl?.cleaningMode.areaIDs {
            selectedLayerID = seq
        }
    }

    private func updateParamUI() {
        var text = ""
        var imagePath = ""
        switch sweeperCustomOrAutoMode {
        case .auto:
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                switch mode {
                case .sweep:
                    text = LocalizedString(key: sweeperCleanOnlySweep)
                    imagePath = "mode_sweep"
                case .mop:
                    text = LocalizedString(key: sweeperCleanOnlyMop)
                    imagePath = "mode_mop"
                case .both:
                    text = LocalizedString(key: sweeperCleanSweepAndMop)
                    imagePath = "mode_sweep_mop"
                }
            }
        case .custom:
            text = LocalizedString(key: sweeperCustomClean)
            imagePath = "mode_diy"
        }
        let image = UIImage.image(named: imagePath)
        // 控制栏的参数按钮
        sweepControlView.parameterButton?.titleLabel.text = text
        sweepControlView.parameterButton?.titleImageView.image = image

        // 悬浮的参数按钮
        parameterButton.titleLabel.text = text
        parameterButton.titleImageView.image = image
    }

    private func updateSweeperHomeMapViewCustomOrAutoMode() {
        switch sweeperCustomOrAutoMode {
        case .auto:
            mapView.sweeperCustomOrAutoMode = .auto
        case .custom:
            mapView.sweeperCustomOrAutoMode = .custom
        }
    }

    private func dataLoadingStateChangeAction(loadingState: SweeperDataLoadingState) {
        // 1. 判断设备是否离线（deviceDetail.online）
        if loadingState == .failed {
            robotOffline = !(deviceDetail?.online ?? false)
        }

        // 2. 判断基站是否升级，若是，则不展示所有UI（除了导航栏）
        if state?.chargeBaseUpgrading == true {
            isShowingUpgradingView = true
            updateNavigation()
            return
        }

        if let switchOn = state?.mechanicalSwitchOn {
            showMechanicalOffView(switchOn: switchOn)
        }

        // 3. 刷新UI状态(是否hidden)
        updateViewShowState(state: loadingState)

        // 4. 载入成功（success or nomap）按照其他状态展示UI
        if loadingState == .success {
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            mapView.updateCleanningModeAndSweepingState()
            mapView.updateCustomOrAutoMode()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            sweeperAlarmViewController?.showAlarm()
            sweeperAlarmViewController?.showNotify()
            if needShowCleaningLog {
                sweeperAlarmViewController?.showCleaningLog()
                needShowCleaningLog = false
            }
            if needEntrySaveMapLogic {
                currentMapDidChanged(preMap: nil)
                needEntrySaveMapLogic = false
            }
            saveMapLogic()
        } else if loadingState == .noMap {
            // 尽管当前map id 为-2，但当设备发送地图帧过来时，仍然需要展示地图，故仍然需要刷新mapView
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            sweeperAlarmViewController?.showCleaningLog()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            // 用户未进入引导页，且当前不在清扫、建图中，需要进入快速建图引导页
            if UserDefaults.standard.shouldShowGuideForFastMap(for: deviceID) && (state?.cleanFinished ?? true) {
                let vc = SweeperFastMapGuideViewController(deviceID: deviceID, listType: listType)
                navigationController?.pushViewController(vc, animated: true)
            }
        }
    }

    private func saveMapLogic() {
        // 若需要展示弹窗，但当前在清扫中，则将弹窗状态保存起来，待扫地机状态变化时重新进入。
        if state?.cleanFinished == false && (needShowSaveMapSingleFloor || needShowSaveMapMultiFloor) {
            needEntrySaveMapLogicAfterBasicStateChanged = true
            return
        }
        if needShowMapHasSavedTip {
            showMapHasSavedTip()
            needShowMapHasSavedTip = false
        }
        if needShowSaveMapSingleFloor {
            saveMapSingleFloor()
            needShowSaveMapSingleFloor = false
        }
        if needShowSaveMapMultiFloor {
            saveMapMultiFloor()
            needShowSaveMapMultiFloor = false
        }
    }

    private func basicStateChangeAction(showToast: Bool) {
        // 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 展示波纹动画: 1. 当前地图ID为-2；
        //             2. 当前在清扫中；
        //             3. 未展示过动画
        //             4. 无地图帧
        if map?.currentMapID == noMapID
            && state?.cleanFinished == false && !hadStartWaveAnimation && sweeperControl?.hadFrame == false {
            startWaveAnimation()
        }
        if (state?.cleanFinished == true) {
            stopWaveAnimation()
        }
        // 特殊情况处理，当扫地机进入清扫状态时
        // 且当前处于无地图时，需要显示地图（而非等到map更改的信令进行变化）
        // 再次变为非清扫状态，且无地图时，需要展示无地图Image
        if map?.currentMapID == noMapID && state?.cleanFinished == false {
            updateViewShowState(state: .success)
        } else if map?.currentMapID == noMapID && state?.cleanFinished == true {
            updateViewShowState(state: .noMap)
        }

        // 扫地机关机状态更新
        showMechanicalOffView(switchOn: state?.mechanicalSwitchOn ?? false)

        if showToast {
            updateBasicStateToastView()
        }
        // 更新扫地机当前的清扫状态（将扫地机状态分为清扫中、暂停中、未清扫，后续根据该status更新清扫UI）
        updateSweepProduce()

        updateUI()
    }

    /// 使用Clean Finished，fast Map  字段与 basic state字段联合判断当前清扫是否结束
    private func updateSweepProduce() {
        guard let state = state else {
            status = .stop
            return
        }
        if state.cleanFinished && state.mainState != .paused && state.mainState != .cleaning {
            // 若设备清扫完成且设备主状态不在清扫、暂停时
            status = .stop
        } else {
            if state.fastMap {
                // 若为快速建图
                if state.mainState == .cleaning {
                    status = .fastMap
                } else {
                    status = .fastMapPause
                }
            } else {
                // 若不为快速建图，则展示正常清扫UI
                if state.mainState == .cleaning {
                   status = .sweeping
                } else {
                   status = .sweepingPause
                }
            }
        }
    }

    // 根据信令展示ToastView
    private func updateBasicStateToastView() {
        guard let state = state else {
            return
        }
        // 主状态为回充，遥控，清扫时候，主页均需展示loading
        if ((state.mainState == .cleaning || state.mainState == .recharge || state.mainState == .remoteControl) && state.subState == .relocate) {
            ToastView.showLoadingToast(cirleWithMessage: "定位中...", existTime: 60, existMessage: nil)
        } else {
            ToastView.dismissLoadingToast()
        }
    }

    /// 根据status更新：清扫面板、清扫参数、导航栏里扫地机的状态、回充按钮、提示栏的位置；
    /// status:     sweeping：当cleanFinished为false，且mainState为Cleaning，subState为Sweeping；
    ///        pause：当cleanFinished为false，
    private func updateUI() {
        // 只当地图数据载入完成之后，更新信令收到后的UI
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 每次收到信令后，获取设备状态，更新设备状态同时更新界面UI

        // 控制面板
        sweepControlView.status = status
        sweepControlViewHeightConstraint?.constant = heightForControlView
        if status == .stop {
            // 清扫参数按钮
            parameterButton.isHidden = true
            // 地图控件
            mapView.isSweeping = false
        } else if status == .fastMap || status == .fastMapPause {
            mapView.isSweeping = true
            parameterButton.isHidden = true
        } else {
            parameterButton.isHidden = false
            mapView.isSweeping = true
        }
        // 导航栏的状态和电量
        updateNavigation()
        // 温度湿度更新
        updateEnvironmentView()
        // 充电按钮
        updateChargeButton()
        refreshBubbleView()
    }

    private func updateCleaningStateUI() {
        guard let state = cleaningState else {
            return
        }
        sweepControlView.areaTitleLabel.text = "(state.cleaningArea)㎡"
        sweepControlView.timeTitleLabel.text = "(state.cleaningTime)min"
    }

    private func updateCleaningModeUI() {
        /// 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        /// 修改设置清扫模式（cleaningMode）按钮的样式
        updateClearingAreaButton()
        /// 修改地图的清扫模式
        updateSweeperHomeMapViewCleanMode()
        /// 根据获取到的cleaningMode中区域清扫的ID，更新地图区域的清扫顺序数组
        updateSelectedLayerID()
        /// 修改定制清扫/边扫边拖属性 - 通过回调去更新该属性更新后主页后续的UI。回调中调用的方法 - updateSweeperCustomOrAutoMode()
        updateConfigurationView()
        /// 修改定制清扫/边扫边拖按钮的样式
        updateParamUI()
        /// 修改定制清扫/边扫边拖地图的样式
        updateSweeperHomeMapViewCustomOrAutoMode()
    }

    private func showAlertWithWholeHouseClean() {
        showAlertWith(title: "进行一次全屋清扫", message: "清扫完成后，将建立家居地图。", messageTextAlignment: .center, defaultButtonTitle: "进行全屋清扫", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonHandler: nil) { [weak self] (_) in
            self?.showSweepTipsAlert()
        }
    }

    private func startFastMap() {
        if sweeperControl?.basicState?.mainState == .remoteControl {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFastMapDuringRemoteControl))
            return
        }
        if sweeperControl?.basicState?.mainState == .assignLocation {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFAstMapDuringAssignLocation))
            return
        }
        // 强制扫地机进入新建快速地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .fastMap)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: self.deviceID, channel: self.channel, listType: self.listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func startFastMapAlert() {
        let alert = SweeperTipsAlert(type: .fastMap) { [weak self] () in
            guard let self = self else { return }
            self.startFastMap()
        }
        alert.show()
    }

    private func showAlertWithFastMapEnd() {
        showAlertWith(title: "尚未得到完整地图，确定要结束吗？", message: nil, messageTextAlignment: .center, defaultButtonTitle: "结束建图", defaultButtonColor: .theme1, cancelButtonTitle: "继续", cancelButtonHandler: nil) { [weak self] (_) in
            self?.setCleaningMode(type: .stop)
        }
    }

    private func showSweepTipsAlert() {
        let alert = SweeperTipsAlert(type: .clean) { [weak self] () in
            self?.setCleaningMode(type: .sweeping)
        }
        alert.show()
    }

    private func setCleaningMode(type: SweeperProcedure) {
        switch type {
        case .sweeping:
            if sweeperControl?.basicState?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringRemoteControl))
                return
            }
            if sweeperControl?.basicState?.mainState == .assignLocation {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringAssignLocation))
                return
            }
            // 若扫地机当前无地图，则所有“清扫”操作为全屋清扫。
            if map?.currentMapID == noMapID {
                self.cleaningMode = SweeperCleaningMode.init(type: .autoClean)
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: SweeperCleaningMode.init(type: .autoClean)).catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
                return
            }

            if cleaningModeType == .areaClean {
                if selectedLayerID.count == 0 {
                    ToastView.showWarningToast(title: "请选择需要清扫的区域", existTime: nil, centerY: .low)
                    return
                }
                sweeperControl?.cleaningMode.areaIDs = selectedLayerID
            } else if cleaningModeType == .pointClean,
                      let partArea = mapView.getSelectionRect() {
                // 若能够从SelectionRect获取到数据，则修改cleaningMode的PointRect
                sweeperControl?.cleaningMode.leftTopPoint = partArea.leftTopPoint
                sweeperControl?.cleaningMode.rightBottomPoint = partArea.rightBottomPoint
            } else {
                sweeperControl?.cleaningMode = .init(type: .autoClean)
            }

            ToastView.showLoadingToast(cirleWithMessage: nil)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: sweeperControl?.cleaningMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .sweepingPause, .fastMapPause:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .pause)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .stop:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .stop)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .fastMap:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .fastMap)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func saveMapSingleFloor() {
        let deleteMapID = map?.allMapNames.keys.first(where: { (mapID) -> Bool in
                  return mapID != temporaryMapID
              })
        guard let sweeperControl = sweeperControl,
              let deleteMapID = deleteMapID,
              let deleteMapName = map?.allMapNames[deleteMapID] else {
            return
        }
        showAlert(title: "是否保存新地图?", buttons: [
            .init(style: .default, text: "更新“(deleteMapName)”", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                ToastView.showLoadingToast(cirleWithMessage: "正在更新")
                SweeperService.deleteMap(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: deleteMapID).then { (_) in
                    ToastView.showWarningToast(title: "更新成功", existTime: nil, centerY: .low)
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
            }),
            .init(style: .default, text: "另存为新地图", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let alert = SweeperSelectionAlert(title: "相同环境请勿保存多张地图，有可能影响机器人的定位。", message: "我家为多楼层户型") {
                    guard self?.isCurrentMapSaved() == true else {
                        ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                        return
                    }
                    ToastView.showLoadingToast(cirleWithMessage: "正在保存")
                    SweeperService.setMultiFloorEnabled(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, enabled: true, mapID: nil).always {
                        ToastView.dismissLoadingToast()
                    }.then { _ in
                        ToastView.showWarningToast(title: "保存成功", existTime: nil, centerY: .low)
                    }.catch { (error) in
                        ToastView.showWarningToast(warningMessage: error.localizedDescription)
                    }
                } cancelHandler: { [weak self] () in
                    self?.saveMapSingleFloor()
                }
                alert.show()
            }, isPreferred: true),
            .init(style: .default, text: LocalizedString(key: notSaveMap))
        ])
    }

    private func saveMapMultiFloor() {
        showAlert(title: "地图数量已达上限，是否保存新地图？", message: "如点击“保存”，请选择新地图要覆盖哪张旧地图。", messageTextAlignment: .center, buttons: [
            .init(style: .default, text: LocalizedString(key: notSaveMap), color: .theme1),
            .init(style: .default, text: "保存", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let vc = SweeperCoverOldMapController()
                vc.sweeperControl = self?.sweeperControl
                self?.navigationController?.pushViewController(vc, animated: true)
            }, isPreferred: true)
        ])
    }

    private func isCurrentMapSaved() -> Bool {
        return map?.currentMapID == temporaryMapID
    }

    /// preMapID 为 nil，表示为第一次赋值
    private func currentMapDidChanged(preMap: SweeperMap?) {
        guard let map = map else {
            return
        }
        // 展示波纹动画条件： 1. 当前地图id为-2
        //                 2. 当前主状态为清扫中
        //                 3. 第一次进入主页面
        //                 4. 当前无地图I帧
        let needShowRobotWave = map.currentMapID == noMapID && sweeperControl?.basicState?.mainState == .cleaning && (preMap == nil || !hadStartWaveAnimation) && sweeperControl?.hadFrame == false
        if needShowRobotWave {
            startWaveAnimation()
        }
        /// preMapID 从 nil -> 0，未处理后退出主页重新进入
        /// 或 从 “-1” -> 0  表示成功创建，但还未自动保存新地图
        let preMapID = preMap?.currentMapID
        if (preMapID == nil || preMapID == isCreatingMapID) && map.currentMapID == temporaryMapID {
            ///  生成临时地图： 需要判断是多楼层还是单楼层来决定保存方式；
            guard let multiFloorEnabled = sweeperControl?.multiFloorEnabled, let maxMapNumber = sweeperControl?.capability?.maxMapNumber else {
                return
            }
            if multiFloorEnabled {
                if map.mapNumber > maxMapNumber && maxMapNumber > 0 && map.currentMapID == temporaryMapID {
                    // 地图已达上限且能力集中多楼层地图上限不为0，且当前地图是临时地图时，展示多楼层地图上限弹窗
                    needShowSaveMapMultiFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            } else {
                if map.mapNumber > 1 && map.currentMapID == temporaryMapID {
                    // 已经有一张地图且当前地图时临时地图时，展示单楼层地图上限弹窗。
                    needShowSaveMapSingleFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            }
            return
        }

        /// 成功创建，mapID 从 “-1” -> 大于0
        if preMapID == isCreatingMapID && map.currentMapID != noMapID && map.currentMapID != temporaryMapID && map.allMapNames.count == (preMap?.allMapNames.count ?? 0) + 1 {
            ///  生成完整地图：直接进入“已自动保存逻辑”
            needShowMapHasSavedTip = true
        }
    }

    private func showMapNotCompletedAlert(alertMessage: String, cancelHandler: ((UIAlertAction) -> Void)? = nil, defaultHandler: (() -> Void)? = nil) {
        showAlertWith(title: alertMessage, message: nil, messageTextAlignment: nil, defaultButtonTitle: "查看帮助", defaultButtonColor: .theme1, cancelButtonTitle: "关闭", cancelButtonColor: .theme1, cancelButtonHandler: cancelHandler, defaultButtonHandler: { [weak self] (_) in
            let vc = SweeperMapHelpViewController(type: .incomplete)
            self?.navigationController?.pushViewController(vc, animated: true)
            defaultHandler?()
        })
    }

    private func showCanNotCustomCleanAlert(isCreatingMap: Bool, defaultButtonhandler: ((UIAlertAction) -> Void)? = nil) {
        if isCreatingMap {
            showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持定制清扫", defaultHandler: { [weak self] () in
                self?.configurationView?.dismiss()
            })
        } else {
            showAlertWith(title: "请创建地图后再设置定制清扫", defaultButtonTitle: SharedResource.sharedFormatString(key: commonSure), defaultButtonColor: UIColor.black, cancelButtonTitle: nil, defaultButtonHandler: defaultButtonhandler)
        }
    }

    func showFastMapGuideView() {
        if fastMapImageView == nil {
            fastMapImageView = UIImageView()
            fastMapImageView?.image = UIImage.image(named: "quick_build_map")
            fastMapImageView?.sizeToFit()
        }
        guard let imageView = fastMapImageView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            fastMapGuideView?.dismiss()
            var offset: CGFloat = defaultButtonInterval
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            fastMapGuideView = presentGuideWith(viewToPresent: imageView, size: imageView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    func showMapHasSavedTip() {
        if savedMapNoticeView == nil {
            savedMapNoticeView = UIImageView()
            savedMapNoticeView?.image = UIImage.image(named: "edit_map")
            savedMapNoticeView?.sizeToFit()
        }
        guard let noticeView = savedMapNoticeView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            saveMapGuideView?.dismiss()
            var offset: CGFloat = 0
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            saveMapGuideView = presentGuideWith(viewToPresent: noticeView, size: noticeView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    override func collectionViewCell(_ cell: SweeperGlobalCleaningConfigurationCollectionViewCell, didSelectItemAt indexPath: IndexPath) {
        super.collectionViewCell(cell, didSelectItemAt: indexPath)

        let itemIndex = indexPath.section
        let row = indexPath.row
        let parameter = settingItems[itemIndex].paramters[row].type
        if parameter == .suctionForce(.none) {
            showAlertWith(title: "静音模式下吸尘能力将暂时降低，仅本次清扫任务生效。", message: nil, messageTextAlignment: nil, defaultButtonTitle: "确定", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonColor: .black, cancelButtonHandler: nil) { [weak self] (_) in
                self?.setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
            }
        } else {
            setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
        }
    }

    func setGlobalConfig(parameter: SweeperGlobalConfigurationType, itemIndex: Int) {
        var pendingConfig = sweeperControl?.globalCleaningConfig

        switch parameter {
        case .suctionForce(_):
            pendingConfig?.suction = parameter
        case .waterYield(_):
            pendingConfig?.waterYield = parameter
        case .sweepTimes(_):
            pendingConfig?.cleanTimes = parameter
        case .cleanMethod(_):
            pendingConfig?.cleanMethod = parameter
        case .mopMode(_):
            pendingConfig?.mopMode = parameter
        }


        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setGlobalCleaningConfig(device: deviceID, channel: channel, listType: listType, config: pendingConfig).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.then { [weak self] (_) in
            self?.sweeperControl?.globalCleaningConfig = pendingConfig
            self?.configurationView?.collectionView.reloadData()
            self?.updateParamUI()
        }
    }

    func startWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        let animationView = SweeperStartCleanAnimationView(frame: .zero)
        view.addSubview(animationView)

        animationView.snp.makeConstraints { make in
            make.centerX.equalToSuperview().offset(28)
            make.centerY.equalToSuperview().multipliedBy(0.764).offset(28)
            make.width.height.equalTo(56)
        }
        self.startCleanAnimationView = animationView
        animationView.startAnimation()
        hadStartWaveAnimation = true
    }

    func stopWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        startCleanAnimationView = nil
        hadStartWaveAnimation = false
    }

    private func cleanAllFlag() {
        needEntrySaveMapLogic = true
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true
        needShowMapHasSavedTip = false
        needShowSaveMapMultiFloor = false
        needShowSaveMapSingleFloor = false
        needEntrySaveMapLogicAfterBasicStateChanged = false
    }
}

// MARK: Button Action
private extension SweeperMainViewController {
    @objc func paramterButtonDidClick() {
        configurationView?.isSetSeq = isSetSweepSeq()
        configurationView?.isSetPreference = isSetPreference()
        configurationView?.show(view: self.navigationController?.view)
    }

    @objc func clearAreaButtonDidClick() {
        sweepAreaPopView = SweeperClearAreaPopView(type: cleaningModeType)
        sweepAreaPopView?.delegate = self
        sweepAreaPopView?.show()
    }

    @objc func startButtonDidClick() {
        guard (map?.currentMapID) != nil  else {
            return
        }
        if sweeperControl?.dataLoadingState == .success {
            setCleaningMode(type: .sweeping)
        } else {
            showAlertWithWholeHouseClean()
        }
    }

    @objc func stopButtonDidClick() {
        if status == .fastMapPause || status == .fastMap {
            showAlertWithFastMapEnd()
        } else {
            setCleaningMode(type: .stop)
        }
    }

    @objc func pasueButtonDidClick() {
        if status == .sweepingPause {
            setCleaningMode(type: .sweeping)
        } else if status == .fastMapPause {
            setCleaningMode(type: .fastMap)
        } else {
            setCleaningMode(type: .sweepingPause)
        }
    }

    @objc func previewButtonDidClick() {
        guard let mediaState = sweeperControl?.mediaState, checkEntryCondition() else {
            return
        }
        checkMediaStateAndJump(state: mediaState)
    }

    func checkMediaStateAndJump(state: SweeperMediaState) {
        // 若为被分享端，则不判断，直接进入人工驾驶页面
        if isSharedDevice {
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            vc.needShowSettingButton = false
            navigationController?.pushViewController(vc, animated: true)
            return
        }

        switch state {
        case .closed, .open:
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        case .openWithPermission:
            if sweeperControl?.mediaEncryptEnabled == true {
                // 视频加密开启，直接验证密码
                checkUnAuthenticated()
                return
            }
            // 视频加密关闭，需要检测设备空密码
            ToastView.showLoadingToast(cirleWithMessage: nil)
            requestCheckEmptyPassword {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func checkEntryCondition() -> Bool {
        if state?.collectDust == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterCollectionDust))
            return false
        }
        if state?.mopWashState == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterWashingMop))
            return false
        }
        return true
    }

    @objc func baseStationButtonDidClick() {
        if sweeperControl?.basicState?.cleanSinkState != .stop {
            let vc = SweeperBaseStationCleanSinkViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        } else {
            let vc = SweeperBaseStationMainViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func moreButtonDidClick() {
        let vc = SweeperMoreActionViewController(deviceID: deviceID, listType: listType)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    @objc func editButtonDidClick() {
        // 大于0的地图数量为0时(无已保存地图)并且没有地图，不允许进入，若mapID为“-1”允许进入
        if sweeperControl?.mapWithoutZero?.count == 0 && sweeperControl?.map?.currentMapID == noMapID {
            // 若扫地机在清扫、建图时，展示暂无地图
            if (state?.cleanFinished ?? true) {
                let fastMapGuideSheet = SweeperFastMapSheet()
                fastMapGuideSheet.delegate = self
                fastMapGuideSheet.show()
            } else {
                ToastView.showWarningToast(title: "暂无地图", existTime: nil, centerY: .low)
            }
            return
        }

        let alertActionSheet = TPActionSheet.init(title: nil)
        let setRigionAction = TPActionSheetAction.init(title: "设置禁区/虚拟墙", detail: "设置不允许扫地机器人进入的区域", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }

            // 清扫过程中进入编辑禁区页面需要暂停扫地机
            if self.status == .sweeping || self.status == .fastMap {
                self.setCleaningMode(type: .sweepingPause)
            }
            // 回充过程中进入编辑进去页面需要设置为待机
            if self.state?.mainState == .recharge {
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setStandBy(deviceID: self.deviceID, listType: self.listType).always {
                    ToastView.dismissLoadingToast()
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }
            }
            // 指哪到哪和遥控时不允许进入禁区页面
            if self.state?.mainState == .assignLocation || self.state?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterMission))
                return
            }
            let vc = SweeperForbiddenAreaVirtualWallViewController(sweeperControl: self.sweeperControl)
            self.navigationController?.pushViewController(vc, animated: true)
        }

        let editMapAreaAction = TPActionSheetAction.init(title: "编辑地图区域", detail: "划分地图区域并进行标记", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }
            /// 清扫、快速建图中不允许进入编辑区域页面
            if self.status != .stop {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterCleaning))
                return
            }
            /// 正在创建地图中不允许进入编辑区域页面
            guard self.map?.currentMapID != isCreatingMapID else {
                self.showMapNotCompletedAlert(alertMessage: LocalizedString(key: sweeperMapIsNotCompleteForEditingArea))
                return
            }
            let vc = SweeperEditMapAreaViewController(sweeperControl: self.sweeperControl)
            vc.isSetPreferenceOrOrder = self.isSetPreference() || self.isSetSweepSeq()
            self.navigationController?.pushViewController(vc, animated: true)
        }


        let manageMapAction = TPActionSheetAction.init(title: "管理地图", style: .leftTitle) { [weak self] (_) in
            guard let self = self else {
                return
            }
            let vc = SweeperMapManagerViewController()
            vc.delegate = self
            vc.deviceID = self.deviceID
            vc.listType = self.listType
            self.navigationController?.pushViewController(vc, animated: true)
        }

        var editActionArray: [TPActionSheetAction] = []
        editActionArray = map?.currentMapID == noMapID ? [manageMapAction] : [setRigionAction, editMapAreaAction, manageMapAction]

        editActionArray.forEach { (action) in
            action.font = .projectFont(ofSize: 16)
            action.detailFont = .projectFont(ofSize: 12)
            alertActionSheet.addAction(action)
        }
        alertActionSheet.separatorColor = .cellSeparatorGray

        alertActionSheet.show()
    }

    @objc func settingBarButtonItemDidClick() {
        if let vc = SweeperSettingViewController.create() {
            vc.deviceID = deviceID
            vc.listType = listType
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func rechargeButtonDidClick() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setRechargeState(device: deviceID, channel: channel, listType: listType, enabled: !isRecharging).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperRobotOfflineViewDelegate {
    func offlineHelpButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.requiredService?.goToOfflineHelp(deviceID: sweeperControl.deviceID, cloudID: sweeperControl.cloudID, listType: sweeperControl.listType, navigator: self.navigationController)
    }

    func offlineRefreshButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
        SweeperModule.shared.refreshSweeperControl()
    }
}

extension SweeperMainViewController: SweeperClearAreaPopViewDelegate {
    func updateData(with type: CleaningModeType) {
        if map?.currentMapID == isCreatingMapID {
            switch type {
            case .areaClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持区域清扫")
            case .pointClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持选框清扫")
            case .autoClean:
                // DO NOTHING
                break
            case .partClean:
                // DO NOTHING
                break
            case .pause:
                // DO NOTHING
                break
            case .stop:
                // DO NOTHING
                break
            case .fastMap:
                // DO NOTHING
                break
            }
            sweepAreaPopView?.dismiss()
            return
        } else {
            if type == .areaClean {
                if map?.currentMapID != noMapID {
                    ToastView.showWarningToast(title: "请选择区域", existTime: nil, centerY: .low)
                }
            }
        }
        self.cleaningModeType = type
        sweepAreaPopView?.dismiss()
    }
}

// MARK: setup UI
private extension SweeperMainViewController {
    func setupNavigation() {

        navigationItem.title = deviceDetail?.alias ?? "扫地机器人"

        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
        addCustomNavigationLeftBarButtonItem(title: nil, image: SharedResource.sharedImage(named: "common_light_back_nor"))
    }

    func setupButtons() {
        var title: String
        var imageName: String
        if isSharedDevice {
            title = "遥控"
            imageName = "ptz"
        } else {
            title = "视频遥控"
            imageName = "preview_light_nor"
        }
        previewButton = SweeperButton(title: title, fontSize: 9, image: UIImage.image(named: imageName))
        let previewTap = UITapGestureRecognizer.init(target: self, action: #selector(previewButtonDidClick))
        previewButton?.addGestureRecognizer(previewTap)
        if let button = previewButton {
            self.view.bringSubviewToFront(button)
        }
        if let previewButton = previewButton {
            buttonContainerStackView.addArrangedSubview(previewButton)
        }

        editButton = SweeperButton(title: "编辑地图", fontSize: 9, image: UIImage.image(named: "map_black_nor"))

        let editTap = UITapGestureRecognizer.init(target: self, action: #selector(editButtonDidClick))
        editButton?.addGestureRecognizer(editTap)
        if let editButton = editButton {
            buttonContainerStackView.addArrangedSubview(editButton)
        }

        baseStationButton = SweeperButton(title: "基站", fontSize: 9, image: UIImage.image(named: "sweeper_home"))

        let stationTap = UITapGestureRecognizer.init(target: self, action: #selector(baseStationButtonDidClick))
        baseStationButton?.addGestureRecognizer(stationTap)
        if let baseStationButton = baseStationButton {
            buttonContainerStackView.addArrangedSubview(baseStationButton)
        }

        moreButton = SweeperButton(title: "更多", fontSize: 9, image: UIImage.image(named: "star"))

        let moreButtonTap = UITapGestureRecognizer.init(target: self, action: #selector(moreButtonDidClick))
        moreButton?.addGestureRecognizer(moreButtonTap)
        if let moreButton = moreButton {
            buttonContainerStackView.addArrangedSubview(moreButton)
        }

        [previewButton, editButton, baseStationButton, moreButton].forEach { button in
            button?.snp.makeConstraints { make in
                make.width.equalTo(44)
                make.height.equalTo(47)
            }
        }

        /* buttonContainerStackView */
        view.addSubview(buttonContainerStackView)
        buttonContainerStackView.axis = .vertical
        buttonContainerStackView.alignment = .center
        buttonContainerStackView.spacing = 12
        buttonContainerStackView.snp.makeConstraints { make in
            make.width.equalTo(44)
            make.top.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }

        /* createMapButton */
        createMapContainer = SweeperCreateMapView()
        if let createMapContainer = createMapContainer {
            view.addSubview(createMapContainer)

            let goldenRatio: CGFloat = 0.382
            createMapContainer.snp.makeConstraints { make in
                make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2).offset(-(88 * goldenRatio))
                make.centerX.equalToSuperview()
                make.width.equalTo(230)
            }
        }
        createMapContainer?.isHidden = true

        /* chargeButton */
        chargeButton = SweeperButton(title: "返回基站", fontSize: 9, image: UIImage.image(named: "robot_charger"), offsetToTop: 5)
        addContraint(for: chargeButton, trailingToSuperView: -defaultButtonPadding)
        chargeButton.isHidden = true
        chargeButton.snp.makeConstraints { make in
            if let sweeperAlarmView = sweeperAlarmViewController {
                make.bottom.equalTo(sweeperAlarmView.view.snp.top).offset(-defaultButtonPadding / 2)
            } else {
                make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding)
            }
        }
        let chargeTap = UITapGestureRecognizer.init(target: self, action: #selector(rechargeButtonDidClick))
        chargeButton.addGestureRecognizer(chargeTap)

        parameterButton = SweeperButton(title: LocalizedString(key: sweeperCleanSweepAndMop), fontSize: 9, image: UIImage.image(named: "mode_general"), offsetToTop: 5)
        addContraint(for: parameterButton, trailingToSuperView: -defaultButtonPadding, bottomToSuperView: nil)
        parameterButton.snp.makeConstraints { (make) in
            make.bottom.equalTo(chargeButton.snp.bottom)
        }

        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        parameterButton.addGestureRecognizer(paramTap)

    }

    func setupOfflineView() {
        let offlineView = SweeperRobotOfflineView(frame: .zero)
        offlineView.delegate = self
        self.view.addSubview(offlineView)

        let goldenRatio: CGFloat = 0.382
        offlineView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2)
        }
        equipmentOfflineView = offlineView
        equipmentOfflineView?.isHidden = true
    }

    func updateNavigation() {
        if firstTimeUpdateNavigationTitle {
            navigationTitleView = SweeperTitleBatteryView(title: deviceDetail?.alias ?? "扫地机器人", stateText: "", power: 0, charge: false)
            navigationTitleView.snp.remakeConstraints { make in
                make.height.equalTo(44)
                make.width.equalTo(screenWidth - 150)
            }
            navigationItem.titleView = navigationTitleView
            firstTimeUpdateNavigationTitle = false
        }

        let stateText = state?.stateDescription ?? "故障中"
        let battery = state?.battery ?? 0
        let isCharging = state?.mainState == .charging
        navigationTitleView.setState(stateText: stateText, power: battery, charge: isCharging)
    }

    func updateEnvironmentView() {
        temperatureView.text = temperatureText
        humidityView.text = humidityText
    }

    func updateChargeButton() {
        chargeButton.isHidden = !shouldShowChargeButton
        if isRecharging {
            chargeButton.setTitle(title: "停止回充", buttonImage: UIImage.image(named: "robot_charge_stop"))
        } else {
            chargeButton.setTitle(title: "返回基站", buttonImage: UIImage.image(named: "robot_charger"))
        }
        if forbiddenRechargeAndClean {
            chargeButton.titleLabel.textColor = .lightGray3Color.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = false
        } else {
            chargeButton.titleLabel.textColor = .black.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = true
        }
    }

    func setupLoadingView() {
        view.addSubview(loadingView)
        loadingView.delegate = self
        loadingView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(0.764)
        }
    }

    func setupMapView() {
        let mapSize = sweeperControl?.mapSize ?? CGSize(width: defaultMapWidth, height: defaultMapHeight)
        mapView = SweeperHomeMapView(frame: .zero, mapSize: mapSize)
        mapView.backgroundColor = UIColor.clear
        view.addSubview(mapView)
        mapView.delegate = self
        mapView.sweeperIconMapView.delegate = self
        mapView.datasource = self
        mapView.isHidden = true

        mapView.snp.makeConstraints { make in
            make.top.trailing.leading.equalToSuperview()
            make.bottom.equalTo(sweepControlView.snp.top)
        }
        setupTapGesture()
    }

    func setupTapGesture() {
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(didTaped(recognizer:)))
        self.mapView.addGestureRecognizer(tapGesture)
    }

    func setupSweeperAlarmView() {
        let sweeperAlarmViewController = SweeperAlarmBannerViewController()
        sweeperAlarmViewController.window(from: .mainPage)
        sweeperAlarmViewController.sweeperControl = self.sweeperControl

        self.addChild(sweeperAlarmViewController)
        view.addSubview(sweeperAlarmViewController.view)
        sweeperAlarmViewController.view.snp.makeConstraints { make in
            make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding / 2)
            make.leading.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }
        self.sweeperAlarmViewController = sweeperAlarmViewController
    }

    @objc func didTaped(recognizer: UITapGestureRecognizer) {
        captureBubbleViewDismiss()
    }

    func setupEnvironmentView() {
        view.addSubview(environmentView)

        environmentView.snp.makeConstraints { make in
            make.height.equalTo(36)
            make.leading.top.equalToSuperview().offset(12)
        }
        environmentView.backgroundColor = .lightGray3Color.withAlphaComponent(0.1964)
        environmentView.layer.cornerRadius = 5

        [temperatureView, humidityView].forEach { label in
            environmentView.addSubview(label)

            label.backgroundColor = .clear
            label.textColor = .black.withAlphaComponent(0.6)
            label.textAlignment = .left
            label.font = .projectFont(ofSize: 10)
            label.snp.makeConstraints { make in
                make.height.equalTo(14)
                make.trailing.equalToSuperview().offset(-8)
                make.leading.equalToSuperview().offset(8)
            }
        }

        temperatureView.snp.makeConstraints { make in
            make.top.equalToSuperview().offset(4)
        }
        temperatureView.text = temperatureText

        humidityView.snp.makeConstraints { make in
            make.top.equalTo(temperatureView.snp.bottom)
        }
        humidityView.text = humidityText
    }

    func setupControlView() {
        addConstraint(forBottomView: sweepControlView, height: nil)
        sweepControlView.isHidden = true
        sweepControlViewHeightConstraint = NSLayoutConstraint(item: sweepControlView,
                                                             attribute: .height,
                                                             relatedBy: .equal,
                                                             toItem: nil,
                                                             attribute: .notAnAttribute,
                                                             multiplier: 1.0,
                                                             constant: 0)
        sweepControlViewHeightConstraint?.isActive = true

        // button clicked
        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        sweepControlView.parameterButton?.addGestureRecognizer(paramTap)

        let clearTap = UITapGestureRecognizer.init(target: self, action: #selector(clearAreaButtonDidClick))
        sweepControlView.clearAreaButton?.addGestureRecognizer(clearTap)

        let startTap = UITapGestureRecognizer.init(target: self, action: #selector(startButtonDidClick))
        sweepControlView.startButton.addGestureRecognizer(startTap)

        let stopTap = UITapGestureRecognizer.init(target: self, action: #selector(stopButtonDidClick))
        sweepControlView.stopButton.addGestureRecognizer(stopTap)

        let pauseTap = UITapGestureRecognizer.init(target: self, action: #selector(pasueButtonDidClick))
        sweepControlView.pauseButton.addGestureRecognizer(pauseTap)

    }

    func setupUpgradingView() {
        view.addSubview(sweeperBaseUpgradingView)
        sweeperBaseUpgradingView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingUpgradingView = false
    }

    func setupMechanicalOffView() {
        view.addSubview(sweeperMechanicalOffView)
        sweeperMechanicalOffView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingMechanicalView = false
        sweeperMechanicalOffView.delegate = self
    }

    func addConstraint(forBottomView bottomView: UIView?, height: CGFloat?) {
        guard let bottomView = bottomView else {
            return
        }
        bottomView.translatesAutoresizingMaskIntoConstraints = false

        view.addSubview(bottomView)

        // UI中设置的阴影radius为12，此处设置为8，才能与UI的效果一致。
        let shadowRadius: CGFloat = 8
        bottomView.layer.shadowOffset = .init(width: 0, height: 2)
        bottomView.layer.shadowRadius = shadowRadius
        bottomView.layer.shadowColor = UIColor.black.cgColor
        bottomView.layer.shadowOpacity = 0.16

        NSLayoutConstraint(item: bottomView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .width,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        if let height = height {
            NSLayoutConstraint(item: bottomView,
                               attribute: .height,
                               relatedBy: .equal,
                               toItem: nil,
                               attribute: .notAnAttribute,
                               multiplier: 1.0,
                               constant: height).isActive = true
        }

        NSLayoutConstraint(item: bottomView,
                           attribute: .bottom,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .bottom,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        NSLayoutConstraint(item: bottomView,
                           attribute: .centerX,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .centerX,
                           multiplier: 1.0,
                           constant: 0).isActive = true
    }

    func addContraint(for subView: UIView?, trailingToSuperView: CGFloat, topToSuperView: CGFloat? = nil, bottomToSuperView: CGFloat? = nil) {
        guard let subView = subView else {
            return
        }

        view.addSubview(subView)
        subView.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint(item: subView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 44).isActive = true
        NSLayoutConstraint(item: subView,
                           attribute: .height,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 47).isActive = true
        if let topToSuperView = topToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .top,
                               relatedBy: .equal,
                               toItem: view,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: topToSuperView).isActive = true
        }

        if let bottomToSuperView = bottomToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .bottom,
                               relatedBy: .equal,
                               toItem: bottomLayoutGuide,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: bottomToSuperView).isActive = true
        }

        NSLayoutConstraint(item: subView,
                           attribute: .trailing,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .trailing,
                           multiplier: 1.0,
                           constant: trailingToSuperView).isActive = true
    }
}

/// receive bitmap data
extension SweeperMainViewController: SweeperMapMediaPlayerListener {
    func mediaPlayerConnected(connectedSuccess: Bool) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if !connectedSuccess {
            dataLoadingStateChangeAction(loadingState: .failed)
        }
    }

    func dataLoadingStateChanged(loadingState: SweeperDataLoadingState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        dataLoadingStateChangeAction(loadingState: loadingState)
    }

    func mediaPlayerBitmapDataUpdate(dataType: MapMediaPlayerFrameFormat) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        /// 对扫地机地图正处于拖动或缩放时地图的刷新进行限制，避免卡顿的情况。
        guard !mapView.isOperation else {
            return
        }
        if dataType == .map {
            // 第一次收到I帧
            if sweeperControl?.hadFrame == true {
                stopWaveAnimation()
            }
            mapView.sweeperBitmapView.refreshBitmapImage()
            mapView.sweeperAreaView.refreshAreaView()
            if needRefreshMapViewInMediaPlayer {
                needRefreshMapViewInMediaPlayer = false
                mapView.refreshView()
            }
        }

        if sweeperControl?.hadFrame == true && dataType == .path {
            mapView.sweeperRouteView.refreshRouteView()
            // refresh equipment icon and charger pile location.
            mapView.sweeperIconMapView.refreshIconView()
        }
    }

    func mediaPlayerSignalling(mapID: String, type: SweeperConfigUpdateType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if type == .cleaningState {
            updateCleaningStateUI()
        } else if type == .cleaningMode || type == .cleanParam {
            updateCleaningModeUI()
        } else if type == .areaCleaning {
            mapView.updateCustomOrAutoMode()
            mapView.refreshAreaAndLabelView()
        } else if type == .globalCleaningConfig {
            // 修改全局清扫配置
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                cleanMethodMode = mode
                configurationView?.collectionView.reloadData()
            }
        } else {
            mapView.refreshView()
            mapView.refreshAreaAndLabelView()
        }
    }

    func mediaPlayerBasicStateDidChanged(preState: SweeperState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        basicStateChangeAction(showToast: true)
        sweeperAlarmViewController?.showAlarm()
        sweeperAlarmViewController?.showNotify()

        // 当前扫地机清扫结束时，若需要进入地图保存逻辑，则重新进入
        if !preState.cleanFinished && state?.cleanFinished == true && needEntrySaveMapLogicAfterBasicStateChanged {
            currentMapDidChanged(preMap: nil)
            saveMapLogic()
            needEntrySaveMapLogicAfterBasicStateChanged = false
        }
    }

    func mediaPlayerMapIDDidChanged(preMap: SweeperMap) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        currentMapDidChanged(preMap: preMap)

        /// 每次修改current map id 后， 地图的大小都会发生变化，故需要刷新初始地图的大小以适应屏幕
        mapView.restoreInitalMapView()
        mapView.shouldRefreshSize = true
        mapView.refreshView()
        mapView.updateCleanningModeAndSweepingState()
        mapView.updateCustomOrAutoMode()
        mapView.refreshAreaAndLabelView()
    }

    func mediaPlayerAlarm(type: SweeperAlarmType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        let alarm = SweeperAlarm(type: type)

        // 当前alarm需要在主页面显示、当基站升级、开关断开时不展示
        guard alarm.window.contains(.mainPage) && sweeperMechanicalOffView.isHidden && sweeperBaseUpgradingView.isHidden else {
            return
        }

        // 展示Toast
        if alarm.rank.contains(.toast),
           let message = alarm.toastTitle {
            ToastView.showWarningToast(title: message, existTime: nil, centerY: .low)
            return
        }

        // 展示Dialog，不展示只在基站展示的dialog
        if alarm.rank.contains(.dialog),
           !SweeperAlarm.baseDialogTypes.contains(type),
           let title = alarm.toastTitle {
            showAlertWith(title: title, message: alarm.toastContent, messageTextAlignment: .center, defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil, cancelButtonHandler: nil, defaultButtonHandler: nil)
            return
        }
    }
}

extension SweeperMainViewController: SweeperMapViewDataSource {
    func area(_ view: UIView, customCleanConfigurationIn areaID: Int) -> SweeperGlobalCleaningConfiguration? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaCleaningConfiguration
    }

    func area(_ view: UIView, infomationLayerMarkIn areaID: Int) -> String? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaLabel
    }

    func areaIDSet(_ in: UIView) -> [Int]? {
        return sweeperControl?.mapModel?.areaModel.areaIDs
    }

    func areaLabelLocation(_ view: UIView, areaID: Int) -> CGPoint? {
        return sweeperControl?.mapModel?.areaModel.areaLabelLocation[areaID]
    }

    func bitmapImage(_ view: UIView) -> CGImage? {
        return sweeperControl?.mapModel?.bitmapImage()
    }

    func bitmapOffset(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.offset
    }

    func bitmapSize(_ view: UIView) -> CGSize? {
        return sweeperControl?.mapModel?.bitmapSize
    }

    func areaData(_ view: UIView) -> [UInt8]? {
        return sweeperControl?.mapModel?.areaModel.areaData
    }

    func routeAllPointArray(_ view: UIView) -> [RoutePoint]? {
        return sweeperControl?.routeModel?.routePoints
    }

    func virtualWallIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.virtualWallModel?.wallIDs
    }

    func virutalWall(_ view: UIView, wallID: Int, isInEditMap: Bool) -> (CGPoint, CGPoint)? {
        return sweeperControl?.virtualWallModel?.couplePiontDictionary[wallID]
    }

    func forbiddenAreaIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.forbiddenAreaModel?.areaIDs
    }

    func forbiddenArea(_ view: UIView, areaID: Int, isInEditMap: Bool) -> RectangleArea? {
        return sweeperControl?.forbiddenAreaModel?.couplePiontDictionary[areaID]
    }

    func equipmentLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.routeModel?.equipmenLocation
    }

    func equipmentAngle(_ view: UIView) -> CGFloat? {
        return sweeperControl?.routeModel?.equipmenOritention
    }

    func chargePileLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.chargePileLocation
    }

    func barrierIDSet(_ view: UIView) -> [Int]? {
        if let keys = sweeperControl?.barriersModel?.barrierDictionary.keys {
            return Array(keys)
        } else {
            return nil
        }
    }

    func barrier(_ view: UIView, barrierModelIn barrierID: Int) -> SweeperBarrier? {
        return sweeperControl?.barriersModel?.barrierDictionary[barrierID]
    }

    func rectClean(_ view: UIView) -> (leftTopPoint: CGPoint, rightBottomPoint: CGPoint)? {
        if cleaningMode.leftTopPoint != .zero && cleaningMode.rightBottomPoint != .zero {
            return (cleaningMode.leftTopPoint, cleaningMode.rightBottomPoint)
        } else {
            return nil
        }
    }

    func mapScale(_ view: UIView) -> CGFloat? {
        return sweeperControl?.capability?.mapScale
    }
}

extension SweeperMainViewController: SweeperHomeMapViewDelegate {
    func hadMapFrame(_ view: SweeperHomeMapView) -> Bool? {
        return sweeperControl?.hadFrame
    }

    func areaSelected(_ view: SweeperHomeMapView) -> [Int]? {
        if cleaningModeType == .areaClean {
            return selectedLayerID
        } else {
            return nil
        }
    }

    func homeMapViewIsSetPreference(_ view: SweeperHomeMapView) -> Bool {
        return isSetPreference()
    }

    func homeMapViewIsSetSeq(_ view: SweeperHomeMapView) -> Bool {
        return isSetSweepSeq()
    }

    func layer(_ view: SweeperHomeMapView, layerSelectedSequence layerID: Int) -> Int? {
        if cleaningModeType == .areaClean, let orderID = selectedLayerID.firstIndex(of: layerID) {
            return orderID
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, layerCleaningOrder layerID: Int) -> Int? {
        if let order = sweeperControl?.mapModel?.areaModel.areaCleaningOrder,
           let orderID = order.firstIndex(of: layerID) {
            return orderID + 1
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, selectedLayer layerID: Int) {
        if let index = selectedLayerID.firstIndex(of: layerID) {
            selectedLayerID.remove(at: index)
        } else {
            selectedLayerID.append(layerID)
        }
        if cleaningModeType == .areaClean && !selectedLayerID.isEmpty {
            ToastView.showWarningToast(title: "已选择(selectedLayerID.count)个区域", existTime: nil, centerY: .low)
        }
        updateClearingAreaButton()
        mapView.refreshAreaAndLabelView()
    }
}

extension SweeperMainViewController {

    // 物体抓拍气泡展示
    private func captureBubbleViewShow(captureView: UIImageView, titleText: String, iconImage: UIImage, status: CaptureImageLoadingStatus, obstacleID: Int, thumbnail: UIImage? = nil) {
        sweepCaptureView.removeFromSuperview()
        captureBubbleViewLayout(captureView: captureView)
        sweepCaptureView.delegate = self

        // 更新障碍物抓拍气泡的展示
        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: thumbnail, obstacleID: obstacleID)

        // 更新障碍物抓拍是否有缩略图以及缩略图状态
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl?.barrierRecognitionEnabled ?? false, captureImageStatus: status)

        self.view.layoutIfNeeded()
        self.autoSuitPosition()
    }

    private func captureBubbleViewLayout(captureView: UIImageView) {
        self.mapView.addSubview(sweepCaptureView)
        sweepCaptureView.snp.remakeConstraints { make in
            make.centerX.equalTo(captureView.snp.centerX)
            make.bottom.equalTo(captureView.snp.top).offset(-12)
            make.width.equalTo(159)
            if sweeperControl?.barrierRecognitionEnabled ?? false {
                make.height.equalTo(128)
            } else {
                make.height.equalTo(40)
            }
        }
    }

    // 物体抓拍气泡隐藏
    private func captureBubbleViewDismiss() {
        sweepCaptureView.dismiss()
    }

    private func autoSuitPosition() {
        var offsetX: CGFloat = 0
        var offsetY: CGFloat = 0
        let maxXCoordinate = mapView.frame.width - sweepCaptureView.frame.width - 16
        if sweepCaptureView.frame.origin.x < 16 {
            offsetX = 16 - sweepCaptureView.frame.origin.x
        } else if sweepCaptureView.frame.origin.x > maxXCoordinate {
            offsetX = maxXCoordinate - sweepCaptureView.frame.origin.x
        }

        if sweepCaptureView.frame.origin.y < 16 {
            offsetY = 16 - sweepCaptureView.frame.origin.y
        }
        // 不用考虑底部超出边界，因为弹窗从顶部出现

        mapView.moveBy(x: offsetX, y: offsetY)
    }

    /// 刷新当前正在展示的气泡及其内容
    private func refreshBubbleView() {
        guard let sweeperControl = sweeperControl,
              let obstacleID = obstacleID,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              let iconImage = barrier.type.bigImage,
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            captureBubbleViewDismiss()
            return
        }
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
            return
        }

        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: .loading)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { [weak self] (status, image) in
            self?.sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: image, obstacleID: obstacleID)
            self?.sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: status)
        }
    }

}

extension SweeperMainViewController: SweeperMapManagerViewControllerDelegate {
    func mapManagerBeginSweep(_ controller: SweeperMapManagerViewController) {
        // 强制扫地机进入新建地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .autoClean)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    func mapManagerFastMap(_ controller: SweeperMapManagerViewController) {
        // 开始快速建图
        startFastMapAlert()
    }
}

extension SweeperMainViewController: SweeperCaptureBubbleViewDelegate {
    func captureNextButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.titleLabel.textColor = UIColor.black.withAlphaComponent(0.5)
        // 获取全部障碍物的详情页
        let sweepCaptureNextPageViewController = SweeperCaptureNextPageViewController(deviceID: deviceID, listType: listType)
        sweepCaptureNextPageViewController.delegate = self

        // 更新详情页跳转到具体哪个页面
        sweepCaptureNextPageViewController.obstacleID = captureView.obstacleID
        self.navigationController?.pushViewController(sweepCaptureNextPageViewController, animated: true)
    }

    func reloadButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.imageStatus = .loading
        let barrierID = captureView.obstacleID
        guard let fileID = sweeperControl?.barriersModel?.barrierDictionary[barrierID]?.fileID else {
            return captureView.imageStatus = .loadNoImage
        }

        SweeperDownloader.downloadObstacleImage(forDevice: deviceID, listType: listType, fileID: fileID) { status, image in
            captureView.imageStatus = status
            captureView.titleImageView.image = image
        }
    }

    func handleGestures(enable: Bool) {
        mapView.isGestureEnable = enable
    }
}

extension SweeperMainViewController: SweeperMainMapLoadingViewDelegate {
    func reloadButtonDidClick(_ UIView: SweeperMainMapLoadingView) {
        refreshMediaPlayerAndSweeperControl()
    }
}

extension SweeperMainViewController: SweeperIconMapViewDelegate {
    func didTapBaseStation(in view: SweeperIconMapView) {
        baseStationButtonDidClick()
    }

    func iconMap(_ view: SweeperIconMapView, transforToScreenPointFrom realPoint: CGPoint) -> CGPoint? {
        // 之前未调用
        return nil
    }

    func didTapObstacle(in view: UIImageView, obstacleID: Int) {

        guard let sweeperControl = sweeperControl,
              let iconImage = sweeperControl.barriersModel?.barrierDictionary[obstacleID]?.type.bigImage,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            return
        }
        self.obstacleID = obstacleID
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loadNoImage, obstacleID: obstacleID)
            return
        }

        self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loading, obstacleID: obstacleID)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { status, image in
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: status, obstacleID: obstacleID, thumbnail: image)
        }
    }
}

extension SweeperMainViewController: SweeperNewPasswordProtocol {
    func checkUnAuthenticated() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperModule.shared.requiredService?.checkUserInfo(deviceID: deviceID, listType: listType, completion: { [weak self] (success, errorCode) in
            ToastView.dismissLoadingToast()
            guard let self = self else {
                return
            }
            if success {
                self.goToPreview()
                return
            }

            if errorCode == TPSS_ASYNC_EC_TIMEOUT || errorCode == TPSS_COMM_EC_SYSTEM {
                /* 请求超时 */
                ToastView.showWarningToast(warningMessage: "网络错误")
                return
            }

            /* 设备锁定 */
            if errorCode == TPSS_COMM_EC_PREVIEW_LOCKED {
                self.showAlertWith(title: SharedResource.sharedString(key: sweeperPreviewLockedAlertTitle), defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil)
                return
            }

            /* 鉴权失败,弹出密码输入框 */
            self.presentInputPasswordVC(deviceID: self.deviceID, listType: self.listType)

        })
    }
}

extension SweeperMainViewController: SweeperVerifyPasswordProtocol {
    func verifySuccessHandler() {
        goToPreview()
    }
}

extension SweeperMainViewController: SweeperCaptureNextPageViewControllerDelegate {
    func ignoreButtonDidClick(sweeperCaptureNextPageViewController: SweeperCaptureNextPageViewController, barrierID: Int) {
        // 点击障碍物抓拍详情页的“忽略”所对应的障碍物Id
        guard let mapID = map?.currentMapID else {
             return
        }
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestIgnoreBarrier(device: deviceID, channel: channel, listType: listType, barrierID: "(barrierID)", mapID: mapID).always {
            ToastView.dismissLoadingToast()
        }.then { [weak self] (_) in
            ToastView.showWarningToast(warningMessage: "已忽略该物体")
            self?.sweepCaptureView.dismiss()
            self?.goBackToSweeperMainViewController()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperMechanicalOffViewDelegate {
    func refreshButtonDidClick(in: SweeperMechanicalOffView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        sweeperMechanicalOffView.refreshLoadingUI(connectedState: .loading)
        view.bringSubviewToFront(sweeperMechanicalOffView)
        SweeperService.getSweeperState(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType).then { [weak self] (state) in
            guard let state = state else {
                return
            }
            self?.showMechanicalOffView(switchOn: state.mechanicalSwitchOn)
        }
    }

    func showMechanicalOffView(switchOn: Bool) {
        // 若开关关闭
        if !switchOn {
            isShowingMechanicalView = true
            sweeperMechanicalOffView.refreshLoadingUI(connectedState: .off)
        } else {
            isShowingMechanicalView = false
        }
    }
}

extension SweeperMainViewController: SweeperMoreActionViewControllerDelegate {
    func cleanWholeHouse(in vc: SweeperMoreActionViewController) {
        showSweepTipsAlert()
    }
}

extension SweeperMainViewController: SweeperFastMapSheetDelegate {
    func startFastMap(view: SweeperFastMapSheet) {
        startFastMapAlert()
    }
}

extension String {
    func separatedBySemiColon(isAutoFill: Bool = true) -> (String, String?) {
        let seperator = self.contains(":") ? ":" : "："
        let separatedTexts: [String] = self.components(separatedBy: seperator)
        if !isAutoFill && separatedTexts.count == 1 {
            return (separatedTexts[0], nil)
        } else {
            return (separatedTexts.count >= 1 ? separatedTexts[0] : "", separatedTexts.count >= 2 ? separatedTexts[1] : "")
        }
    }
}
//
//  OnlineDeviceListMasterViewController.swift
//  SurveillanceHome
//
//  Created by Li Linfeng on 2019/12/9.
//  Copyright © 2019 tplink. All rights reserved.
//

import UIKit
import SurveillanceHomeBase
import SharedResource
import TPFoundation
import DeviceDetailModule
import NetService

private var pageIndexAssociatedObjectHandle: UInt8 = 0

final class OnlineDeviceListMasterViewController: BaseViewController {
    @IBOutlet private weak var groupCollectionView: UICollectionView!
    @IBOutlet private weak var groupToolbarShadowView: UIView!
    @IBOutlet private weak var groupToolbarContainer: UIView!
    @IBOutlet private weak var groupToolbarDropMenuButton: UIButton!
    @IBOutlet private weak var recentPreviewView: RecentPreviewView!
    @IBOutlet private weak var containerViewBottom2SuperViewBottomConstraint: NSLayoutConstraint!
    @IBOutlet private weak var containerViewTop2TopLayoutGuideBottomConstraint: NSLayoutConstraint!

    override var navigationBarTraits: [NavigationBarTrait] {
        return NavigationBarTrait.noSeparator
    }

    private var deviceGroups: [TPSSDeviceGroup] = []
    private var currentGroupIndex: Int = 0

    private var newCreateGroupName = ""

    private var pageController: UIPageViewController!
    private var deviceListVCCacheDictionary = [TPSSDeviceGroupID: OnlineDeviceListViewController]()
    private var transitionVCForPageController = UIViewController()
    lazy private var loginCacheVC = DeviceListLoginViewController.create()

    private var firstAppear = true
    private var shouldRecreate: Bool = false

    /// for routers' entry
    private var isLoginBefore = false

    var sdCardStatusShowed: SDCardStatusShowed = .none
    var diskStatusShowed: SDCardStatusShowed = .none

    // camera display
    private var shouldShowCameraDisplayNoActiveChannelAlert = false
    private var addChannelCameraDisplay: TPSSDeviceForDeviceList?

    // navigation
    private lazy var moreToolBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(moreToolsButtonClicked(_:)))
    }()

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_add_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(addDeviceButtonClicked(_:)))
    }()

    // MARK: guides and overlays
    private weak var addDeviceGuideView: GuidePresentationView?
    private weak var moreToolsPopoverView: GuidePresentationView?

    private lazy var groupPresenter = GroupListPresentationManager()
    private var presentedGroupList: GroupListViewController? {
        return presentedViewController as? GroupListViewController
    }

    private var currentList: OnlineDeviceListViewController {
        if let viewControllers = pageController.viewControllers, let firstViewController = viewControllers.first as? OnlineDeviceListViewController {
            return firstViewController
        }
        return OnlineDeviceListViewController()
    }

    private var isCloudLogin: Bool {
        return DeviceListModule.shared.requiredService?.isCloudLogin ?? false
    }

    private var isReordering = false                // 是否正在处于排序模式
    private var shouldToggleGroupModeAfterGetList = false   // 是否需要在获取列表结束后切换防护模式，仅在列表还未获取完时触发防护模式切换使用

    private var isShowing: Bool {
        return isShowing(ignorePresentedClasses: [UIAlertController.classForCoder()])
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        setupView()

        NotificationCenter.default.addObserver(self, selector: #selector(handleShowCameraDisplayNoActiveChannelAlertNotification(_:)), name: .ShowCameraDisplayNoActiveChannelAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleShowStorageDetectAlertNotification(_:)), name: .ShowStorageDetectAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListInvalidated), name: .DeviceListInvalidated, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListUpdated), name: .DeviceListUpdated, object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderBegined(_:)),
                                               name: .DeviceListReorderBegined,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderEnded(_:)),
                                               name: .DeviceListReorderEnded,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupAndDeviceList(_:)),
                                               name: .UpdateGroupAndDeviceListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: DeviceListNetworkObserver.localDeviceRefreshed,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupList(_:)),
                                               name: .UpdateGroupListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: .unbindDiscoveryFinished,
                                               object: nil)

        _ = DeviceListModule.shared.requiredService?.addEntrustObserver(observeTypes: [.entrustmentStop, .entrustmentExitByTrustee], { (_, _) in
            DeviceListManager.shared.updateDeviceList(of: DeviceListManager.shared.defaultGroupID).always {
                self.currentList.reload()
            }
        })
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        showGroupAndNavigationButton(true)
        if !isCloudLogin {
            showEmpty()
        } else if firstAppear {
            firstAppear = false
            restore()
        } else if shouldRecreate {
            shouldRecreate = false
            reload()
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        checkUpdateIfNeeded()

        if isCloudLogin {
            showPopoverGuideIfNeeded()
        }

        if shouldShowCameraDisplayNoActiveChannelAlert {
            shouldShowCameraDisplayNoActiveChannelAlert = false
            showCameraDisplayNoActiveChannelAlert()
        }
        updateGroupShadow()
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)

        dismissPresentedViews()
    }

    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let vc = segue.destination as? UIPageViewController {
            pageController = vc
            pageController.dataSource = self
            pageController.delegate = self
        }
    }

    private func refreshAfterGroupUpdated() {
        guard !isReordering else {
            return
        }

        guard isShowing else {
            // 如果分组刷新完，此时页面不是正在显示，则不进行页面刷新，仅记录状态，等回到本页面才统一进行刷新。
            // 需要注意通过记录状态后续回到页面才处理的逻辑，要与本方法后续处理逻辑要保持一致
            shouldRecreate = true
            return
        }

        reload()
    }

    private func showEmpty() {
        deviceGroups = []
        currentGroupIndex = -1

        showGroupAndNavigationButton(false)

        let emptyVC: UIViewController?
        // 有发现出来的/已绑定到局域网的设备时显示带登陆按钮的设备列表；没有则显示普通的登陆提示页
        if DeviceListManager.shared.unbindDetailDeviceList().count > 0 {
            emptyVC = createUnloginPage()
        } else {
            emptyVC = loginCacheVC
        }
        if let emptyVC = emptyVC {
            pageController.setViewControllers([emptyVC], direction: .forward, animated: false, completion: nil)
        }
        groupCollectionView.reloadData()
    }

    private func showGroupAndNavigationButton(_ shouldShow: Bool) {
        if shouldShow {
            navigationItem.leftBarButtonItem = moreToolBarButtonItem
            groupToolbarDropMenuButton.isHidden = false
        } else {
            navigationItem.leftBarButtonItem = nil
            groupToolbarDropMenuButton.isHidden = true
        }
    }

    private func restore() {
        deviceGroups = DeviceListManager.shared.groupList

        loadGroup(with: DeviceListManager.shared.lastSelectedGroupID)
    }

    private func reload(with preferredGroupID: String? = nil) {
        let oldGroupID = preferredGroupID ?? DeviceListManager.shared.lastSelectedGroupID
        deviceGroups = DeviceListManager.shared.groupList
        presentedGroupList?.groups = deviceGroups

        loadGroup(with: oldGroupID)
    }

    private func loadGroup(with groupID: String) {
        let currentGroup = DeviceListManager.shared.group(of: groupID) ?? DeviceListManager.shared.defaultGroup

        guard let groupIndex = deviceGroups.firstIndex(where: { $0.groupID == currentGroup.groupID }) else {
            return
        }

        currentGroupIndex = groupIndex

        presentedGroupList?.currentGroupID = currentGroup.groupID
        presentedGroupList?.reload()

        commonLoad()
    }

    private func commonLoad(animated: Bool = false, recreate: Bool = true) {
        groupCollectionView.reloadData()

        guard currentGroupIndex >= 0 else {
            return
        }

        groupCollectionView.scrollToItem(at: IndexPath(item: currentGroupIndex, section: 0), at: .right, animated: false)
        updateGroupShadow()

        if recreate, let vc = createPage(for: currentGroupIndex) {
            pageController.setViewControllers([vc], direction: .forward, animated: false, completion: nil)
        }

        storeGroupParameter()
    }

    private func updateGroupShadow() {
        groupToolbarShadowView.isHidden = groupCollectionView.bounds.maxX >= (groupCollectionView.contentSize.width - 1)
    }

    private func refreshAllDeviceLists() {
        if let viewController = pageController.viewControllers {
            viewController.forEach {
                if let vc = $0 as? OnlineDeviceListViewController {
                    vc.reload()
                }
            }
        }
    }

    private func createPage(for index: Int) -> OnlineDeviceListViewController? {
        let group = deviceGroups[index]
        guard let vc = createPage(for: group.groupID as TPSSDeviceGroupID) else {
            return nil
        }
        objc_setAssociatedObject(vc, &pageIndexAssociatedObjectHandle, index, .OBJC_ASSOCIATION_COPY_NONATOMIC)
        vc.realGroup = deviceGroups[index]
        return vc
    }

    private func createUnloginPage() -> OnlineDeviceListViewController? {
        return createPage(for: "unlogin page")
    }

    private func createPage(for key: TPSSDeviceGroupID) -> OnlineDeviceListViewController? {
        let vc: OnlineDeviceListViewController?
        if let item = deviceListVCCacheDictionary[key] {
            vc = item
        } else {
            vc = OnlineDeviceListViewController.create()
            deviceListVCCacheDictionary[key] = vc
        }
        return vc
    }
}

extension OnlineDeviceListMasterViewController: DeviceListUnwindDestination {}

// MARK: Popover handler
extension OnlineDeviceListMasterViewController {
    private func updateMenu() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let networkAvailable = NetworkManager.shared.isConnected
        let isInHomeMode = deviceGroups[currentGroupIndex].activeMode != .goOut
        let isBigCardMode = deviceGroups[currentGroupIndex].displayMode != .smallCard
        let homeModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_home_active") : DeviceListModule.image(named: "devicelist_home_disabled")
        let outModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_out_active") : DeviceListModule.image(named: "devicelist_out_disabled")
        DeviceGroupMenuItem.alarmMode.image = (isInHomeMode ? homeModeImage : outModeImage)?.withRenderingMode(.alwaysOriginal)
        DeviceGroupMenuItem.alarmMode.enabled = networkAvailable
        DeviceGroupMenuItem.alarmMode.title = isInHomeMode ? LocalizedString(key: deviceListModeHome) : LocalizedString(key: deviceListModeOut)
        DeviceGroupMenuItem.alarmMode.subtitle = isInHomeMode ? LocalizedString(key: deviceListSwitchModeToOut) : LocalizedString(key: deviceListSwitchModeToHome)
        DeviceGroupMenuItem.viewMode.title = isBigCardMode ? LocalizedString(key: deviceListViewGrid) : LocalizedString(key: deviceListViewList)
        DeviceGroupMenuItem.viewMode.subtitle = isBigCardMode ? LocalizedString(key: deviceListSwitchViewToList) : LocalizedString(key: deviceListSwitchViewToGrid)
        DeviceGroupMenuItem.viewMode.image = isBigCardMode ?  DeviceListModule.image(named: "devicelist_grid")?.withRenderingMode(.alwaysOriginal) : DeviceListModule.image(named: "devicelist_list")?.withRenderingMode(.alwaysOriginal)
    }

    private func handleDeviceGroupMenu(item: DeviceGroupMenuView.Item) {
        switch item {
        case .alarmMode:
            toggleGroupMode()
        case .search:
            navigateToSearch()
        case .viewMode:
            toggleDisplayMode()
        }
    }

    private func toggleGroupMode() {
        dismissPresentedViews()

        let deviceListUpdateStatus = DeviceListManager.shared.deviceListUpdateStatus
        if !deviceListUpdateStatus.cloudUpdateNecessaryInfoFinished {
            // 列表必要信息没获取到，此时若需要改变防护模式，就先请求获取数据并且loading，等所有信息获取完处理，避免数据不完整导致处理出错
            if !deviceListUpdateStatus.isUpdatingList {
                DeviceListManager.shared.updateGroupAndDeviceList()
            }
            shouldToggleGroupModeAfterGetList = true
            ToastView.showLoadingToast(cirleWithMessage: nil)
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.activeMode
        let newMode = group.activeMode == .goOut ? TPSSDeviceGroupMode.atHome : .goOut
        group.activeMode = newMode
        ToastView.showLoadingToast(cirleWithMessage: nil)
        DeviceListManager.shared.changeActiveMode(with: deviceGroups[currentGroupIndex]).then { () in
            self.currentList.reload()
            self.currentList.showToastForActiveMode(newMode)
        }.catch { (_) in
            group.activeMode = originalMode
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func toggleDisplayMode() {
        dismissPresentedViews()

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.displayMode
        let newMode = originalMode == .bigCard ? DeviceUIDisplayType.smallCard : .bigCard

        DeviceListManager.shared.changeDisplayMode(for: group.groupID, with: newMode)

        for section in 0..<currentList.collectionView.numberOfSections {
            for item in 0..<currentList.collectionView.numberOfItems(inSection: section) {
                if newMode == .smallCard {
                    currentList.fold(at: IndexPath(row: item, section: section))
                } else {
                    currentList.unfold(at: IndexPath(row: item, section: section))
                }
            }
        }

        currentList.reload()
    }

    private func navigateToSearch() {
        dismissPresentedViews()
        let allDevices = DeviceListManager.shared.allDetailDevices
        let allGroups = DeviceListManager.shared.groupList
        let vc = RemoteDeviceListSearchViewController(devices: allDevices, groups: allGroups)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }
}

extension OnlineDeviceListMasterViewController {
    // MARK: Popover
    private func showPopoverGuideIfNeeded() {
        // add device popover
        if UserDefaults.standard.object(forKey: deviceListLaunchKey) == nil {
            showAddDevicePopover()
            UserDefaults.standard.set(true, forKey: deviceListLaunchKey)
        }
    }

    private func showAddDevicePopover() {
        if !isShowing() {
            /* 如果界面切换了不要加载 */
            return
        }
        if let source = (navigationItem.rightBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            navigationController?.navigationBar.layoutIfNeeded()
            dismissPresentedViews()
            addDeviceGuideView = presentGuideWith(viewToPresent: TutorialGuideView.addDevice, size: TutorialGuideView.addDevice.frame.size, source: source, clickThrough: true)
            addDeviceGuideView?.delegate = self
        }
    }
}

extension OnlineDeviceListMasterViewController: GuidePresentationViewDelegate {
    func guidePresentationViewDidDismiss(_ view: GuidePresentationView) {
        if view == moreToolsPopoverView {
            navigationItem.leftBarButtonItem?.tintColor = UIColor(white: 0, alpha: 0.8)
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        }
    }
}

// MARK: - util
extension OnlineDeviceListMasterViewController {
    private func storeGroupParameter() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        DeviceListManager.shared.updateLastSelectGroupID(deviceGroups[currentGroupIndex].groupID)
    }
}

extension OnlineDeviceListMasterViewController {

    private func presentUpgradeInfo(appVersionInfo: AppUpgradeModuleBaseUpgradeInfo) {
        let alertViewController = DeviceListUpgradeAlertController(versionInfo: appVersionInfo)
        present(alertViewController, animated: true, completion: nil)
    }

    private func checkUpdateIfNeeded() {
        let requiredService = DeviceListModule.shared.requiredService
        guard requiredService?.shouldShowNewAppVersion() ?? false else {
            return
        }

        // 仅跳转至需要更新的包中（若对应版本的升级包needNotify为false，而另外版本的needNotify为true，会跳转至另一版本）
        if TPAppUtils.isTestFlightBeta() {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, appVersionInfo.needNotify, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        } else {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo, appVersionInfo.needNotify {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        }

    }
}

extension OnlineDeviceListMasterViewController: DeviceListSearchViewControllerDelegate {
    func navigateToGroup(group: TPSSDeviceGroup) {
        navigationController?.popViewController(animated: true)
        DispatchQueue.main.async {
            self.loadGroup(with: group.groupID)
        }
    }

    func navigateToSyncPreviewViewController(device: DeviceDetail) {
        goToSyncPreview(ipc: device, listType: device.listType)
    }

    func navigateToPreviewViewController(device: DeviceDetail, channel: TPSSChannelInfo?) {
        if device.deviceType == .smartLock {
            DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
            return
        }
        goToPreview(device: device, channel: channel)
    }

    func navigateToBatteryDoorbellViewController(device: DeviceDetail, fromNVR nvr: (deviceID: TPSSDeviceIdentifier, channel: UInt)?) {
        DeviceListModule.shared.requiredService?.navigateToBatteryDoorbellViewController(for: device.identifier, group: DeviceListManager.shared.defaultGroupID, listType: device.listType, navigator: navigationController, from: nvr?.deviceID, channelInNVR: nvr?.channel.intValue)
    }

    func navigateToNVRViewController(nvr: DeviceDetail) {
        var groupId = DeviceListManager.shared.defaultGroup.groupID
        if currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex {
            groupId  = deviceGroups[currentGroupIndex].groupID
        }
        goToNVR(nvr: nvr, groupID: groupId)
    }

    func navigateToSolarControllerManagerViewController(device: DeviceDetail) {
        goToSolarController(solarController: device)
    }

    func navigateToRouterManagerViewController(device: DeviceDetail) {
        goToRouter(device: device)
    }

    func navigateToSmartLockViewController(device: DeviceDetail) {
        DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
    }
}

// MARK: Navigation
extension OnlineDeviceListMasterViewController: PreviewControllerEntrance {
    func goToPreview(device: DeviceDetail, channel: TPSSChannelInfo?) {
        goToPreview(deviceID: device.identifier, channelID: channel?.channelId.intValue ?? -1, listType: device.listType)
    }

    func goToNVR(nvr: DeviceDetail, groupID: String? = nil) {
        let vc = NVRTabViewController()
        vc.cloudIdentifier = nvr.cloudDeviceID
        vc.deviceIdentifier = nvr.identifier
        vc.listType = nvr.listType
        vc.groupId = groupID
        navigationController?.pushViewController(vc, animated: true)
    }

    func goToSolarController(solarController: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToSolarControllerManagerViewController(deviceID: solarController.identifier, listType: solarController.listType, navigator: navigationController)
    }

    func goToRouter(device: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToRouterDefault(mac: device.mac, listType: device.listType, isOnline: device.online, navigator: navigationController)
    }
}

// MARK: Actions
extension OnlineDeviceListMasterViewController {
    private func dismissPresentedViews() {
        addDeviceGuideView?.dismiss()
        moreToolsPopoverView?.dismiss()

        presentedGroupList?.dismiss(animated: true, completion: nil)

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }

    @IBAction private func addDeviceButtonClicked(_ sender: Any) {
        guard isCloudLogin else {
            showAlertWith(title: LocalizedString(key: deviceListNotLogin), defaultButtonTitle: LocalizedString(key: deviceListLogin), defaultButtonHandler: { (_) in
                DeviceListModule.shared.requiredService?.navigateToLoginViewController(navigator: self.navigationController)
            })
            return
        }
        dismissPresentedViews()

        DeviceListModule.shared.requiredService?.presentDeviceAddViewController(viewController: self, listType: listType)
    }

    @IBAction private func moreToolsButtonClicked(_ sender: Any) {
        guard isCloudLogin else { return }

        if moreToolsPopoverView != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let size = CGSize(width: 212, height: 16 + DeviceGroupMenuView.Item.allCases.count * 44)
        let menuView = DeviceGroupMenuView(frame: CGRect(origin: .zero, size: size))
        menuView.action = handleDeviceGroupMenu

        dismissPresentedViews()

        updateMenu()

        if let source = (navigationItem.leftBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
            menuView.configurePopoverShadow(cornerRadius: 8)
            moreToolsPopoverView = presentGuideWith(viewToPresent: menuView, size: size, backgroundColor: .clear, source: source, offset: CGPoint(x: -12, y: 4))
            moreToolsPopoverView?.delegate = self
        }
        navigationItem.leftBarButtonItem?.tintColor = .theme1
    }

    @IBAction private func groupMenuToggled(_ sender: UIButton) {
        guard isCloudLogin else { return }

        if presentedViewController != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_up_small_normal"), for: .normal)

        let groups = DeviceListManager.shared.groupList
        guard let vc = GroupListViewController.create() else {
            return
        }
        let height = CGFloat(groups.count) * 52 + 72
        vc.preferredContentSize = CGSize(width: UIScreen.main.bounds.width, height: height)
        vc.modalPresentationStyle = .custom
        vc.transitioningDelegate = groupPresenter
        vc.groups = groups
        vc.currentGroupID = deviceGroups[currentGroupIndex].groupID
        vc.delegate = self
        present(vc, animated: true, completion: nil)
    }

    @IBAction private func recentPreviewClicked(_ sender: Any) {
        // 不会用到此按钮，但暂时保留
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDataSource {
    private func groupInformation(at index: Int) -> (String, Bool) {
        if deviceGroups.isEmpty { return (LocalizedString(key: deviceListMyDevice), true) }
        return (deviceGroups[index].groupName, index == currentGroupIndex)
    }

    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }

    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return max(1, deviceGroups.count)
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        return collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)
    }
}

extension OnlineDeviceListMasterViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        updateGroupShadow()
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDelegate {
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        if deviceGroups.isEmpty { return }
        dismissPresentedViews()
        loadGroup(with: deviceGroups[indexPath.item].groupID)
    }
}

extension OnlineDeviceListMasterViewController: DeviceGroupNameLayoutDelegate {
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, groupForItemAt indexPath: IndexPath) -> (name: String, selected: Bool) {
        return groupInformation(at: indexPath.item)
    }
}

// MARK: Page Management
extension OnlineDeviceListMasterViewController: UIPageViewControllerDataSource {
    func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex > 0 && currentGroupIndex < deviceGroups.count else { return nil }
        return createPage(for: currentGroupIndex - 1)
    }

    func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex >= 0 && currentGroupIndex < deviceGroups.count - 1 else { return nil }
        return createPage(for: currentGroupIndex + 1)
    }
}

extension OnlineDeviceListMasterViewController: UIPageViewControllerDelegate {
    func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
        if completed {
            if let viewControllers = pageViewController.viewControllers, let firtViewController = viewControllers.first {
                if let currentGroupIndex = objc_getAssociatedObject(firtViewController, &pageIndexAssociatedObjectHandle) as? Int {
                    self.currentGroupIndex = currentGroupIndex
                    commonLoad(animated: true, recreate: false)
                }
            }
        }
    }
}

// MARK: Group Management
extension OnlineDeviceListMasterViewController: GroupListViewControllerDelegate {
    func groupListViewController(_ groupListViewController: GroupListViewController, canMoveGroupTo destinationIndex: Int) -> Bool {
        guard deviceGroups.count > destinationIndex else {
            return false
        }
        let group = deviceGroups[destinationIndex]
        return !group.isDefaultGroup
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didMoveGroupAt sourceIndex: Int, to destinationIndex: Int) {
        // check if current group index has changed
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let originalGroup = deviceGroups[currentGroupIndex]
        deviceGroups.swapAt(sourceIndex, destinationIndex)
        if let newIndex = deviceGroups.firstIndex(of: originalGroup), currentGroupIndex != newIndex {
            currentGroupIndex = newIndex
        }
        // always invalidate page controller cache
        pageController.setViewControllers([currentList], direction: .forward, animated: false, completion: nil)
        groupCollectionView.moveItem(at: IndexPath(item: sourceIndex, section: 0), to: IndexPath(item: destinationIndex, section: 0))
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didSelectGroupAt index: Int) {
        dismissPresentedViews()
        loadGroup(with: deviceGroups[index].groupID)
    }

    func groupListViewControllerDidSelectCreatingNewGroup(_ groupListViewController: GroupListViewController) {
        dismissPresentedViews()
        guard let vc = CommonNameInputViewController.create() else {
            return
        }
        vc.navigationTitle = LocalizedString(key: deviceListSetGroupNameTitle)
        vc.doneButtonTitle = LocalizedString(key: commonNextStep)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didRequestEditingGroupAt index: Int) {
        dismissPresentedViews()
        guard let vc = GroupSettingViewController.create() else {
            return
        }
        vc.group = deviceGroups[index]
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewControllerDidDismiss(_ groupListViewController: GroupListViewController) {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
        _ = DeviceListManager.shared.updateGroupOrder(newGroup: deviceGroups)
    }
}

extension OnlineDeviceListMasterViewController: CommonNameInputViewControllerDelegate {
    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didCancelWith text: String) {
        navigationController?.popViewController(animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didFinishWith text: String) {
        guard deviceGroups.count > 0 else {
            navigationController?.popToViewController(self, animated: true)
            return
        }
        newCreateGroupName = text
        let vc = DeviceSelectionViewController(entry: .groupAddIndependent, group: DeviceListManager.shared.defaultGroupID, canProceedWithNoSelection: true)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, errorMessageFor text: String) -> (allowed: Bool, message: String?) {
        let error = TPSSDeviceListValidate.validateDeviceGroupName(text)
        if error != nil {
            return (true, error?.message)
        }

        if DeviceListManager.shared.groupList.contains(where: { $0.groupName == text }) {
            return (true, LocalizedString(key: deviceListNameExists))
        }
        return (true, nil)
    }

    func placeholderForNameInputViewController(_ nameInputViewController: CommonNameInputViewController) -> String? {
        return SharedResource.sharedString(key: shareStringLengthConstraint)
    }
}

extension OnlineDeviceListMasterViewController {
    @objc func handleShowCameraDisplayNoActiveChannelAlertNotification(_ noti: NSNotification) {
        if let (device, listType) = noti.object as? (DeviceDetail, TPSSDeviceListType), listType == .remote {
            shouldShowCameraDisplayNoActiveChannelAlert = true
            addChannelCameraDisplay = DeviceListManager.shared.device(with: device.identifier)
        }
    }

    @objc func handleShowStorageDetectAlertNotification(_ noti: NSNotification) {
        diskStatusShowed = .none
        sdCardStatusShowed = .none
    }

    private func showCameraDisplayNoActiveChannelAlert() {
        showAlertWith(title: LocalizedString(key: deviceAddCameraDisplayNoActiveChannelsTitle), defaultButtonTitle: LocalizedString(key: deviceAddAddNext), cancelButtonTitle: LocalizedString(key: commonNotNow), cancelButtonHandler: nil) { (_) in
            if let cameraDisplay = self.addChannelCameraDisplay {
                DeviceListModule.shared.requiredService?.navigateToCameraDisplayDiscoverViewController(deviceID: cameraDisplay.identifier, discoverType: .cameraDisplay, listType: self.listType, navigator: self.navigationController)
                // 需要在中间插一个ViewController
                let vc = NVRTabViewController()
                vc.cloudIdentifier = cameraDisplay.cloudDeviceId
                vc.deviceIdentifier = cameraDisplay.identifier
                vc.listType = .remote
                vc.hidesBottomBarWhenPushed = true
                if var tmpViewControllers = self.tpNavigationController?.viewControllers {
                    tmpViewControllers.insert(vc, at: tmpViewControllers.count - 1)
                    self.tpNavigationController?.setViewControllers(tmpViewControllers, animated: true)
                }
            }
        }
    }
}

extension OnlineDeviceListMasterViewController: DeviceSDCardStatusChecker {
    var listType: TPSSDeviceListType { return .remote }

    func formatProcessDidFinish() {
        currentList.reload()
    }
}

extension OnlineDeviceListMasterViewController: DeviceSelectionViewControllerDelegate {
    func deviceSelectionViewController(_ deviceSelectionViewController: DeviceSelectionViewController, didPressRightBarButtonItemWithDeviceChannels selectedDeviceChannels: [DeviceDetail: [ChannelId]]) {
        switch deviceSelectionViewController.entryType {
        case .groupAddIndependent:
            ToastView.showLoadingToast(cirleWithMessage: nil)

            let targetDeviceChannels = DeviceSelectionViewController.covertDeviceChannel(selectedDeviceChannels)
            DeviceListManager.shared.createGroup(name: newCreateGroupName, deviceChannelMap: targetDeviceChannels).always {
                ToastView.dismissLoadingToast()
            }.then { (groupID) in
                self.navigationController?.popToViewController(self, animated: true)
                self.reload(with: groupID)
            }.catch { (error) in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }
        default:
            break
        }
    }
}

// MARK: - notification
extension OnlineDeviceListMasterViewController {
    @objc private func handleDeviceListInvalidated() {
        shouldRecreate = true
        deviceListVCCacheDictionary.removeAll()
    }

    @objc private func handleDeviceListUpdated() {
        showUpdateAlertIfAny()
    }

    @objc private func handleReorderBegined(_ notification: Notification) {
        enterReorderMode()
    }

    @objc private func handleReorderEnded(_ notification: Notification) {
        exitReorderMode()
    }

    @objc private func handleUpdateGroupAndDeviceList(_ notification: Notification) {
        if isCloudLogin {
            handleGroupModeToggleAfterGetList(notification)
        } else if isShowing {
            // 处理非登录场景

            // 仅页面正在显示才处理数据获取结果更新页面状态，否则等viewWillAppear再处理。避免正在获取列表
            // 时切换到其它页面，列表获取有结果后触发本逻辑使得子VC触发viewWillAppear，后续真正展示页面时
            // 就不再触发viewWillAppear导致数据异常
            showEmpty()
        }
    }

    @objc private func handleLocalDeviceRefreshed(_ notification: Notification) {
        if !isCloudLogin && isShowing {
            // 非登录且页面正在显示时才需要处理因网络状态变化重新发现完的通知，因为此时可能需要在有/无设备的页面之间切换。
            // 如果页面没有在显示则不需要处理，因为viewWillAppear会触发该逻辑
            showEmpty()
        }
    }

    @objc private func handleUpdateGroupList(_ notification: Notification) {
        if let dic = notification.object as? [String: Any],
           let error = dic[DeviceListManager.notificationKeyError] as? Error {
            ToastView.showWarningToast(title: error.localizedDescription, existTime: nil, centerY: .lowest)
            return
        }
        // 失败也更新，此时显示默认分组
        refreshAfterGroupUpdated()
    }

    private func handleGroupModeToggleAfterGetList(_ notification: Notification) {
        let finishHandler: (() -> Void) = {
            if self.shouldToggleGroupModeAfterGetList {
                ToastView.dismissLoadingToast()
                self.shouldToggleGroupModeAfterGetList = false
                self.toggleGroupMode()
            }
        }

        guard let dic = notification.object as? [String: Any],
              let status = dic[DeviceListManager.notificationKeyListUpdateStatus] as? DeviceListUpdateStatus else {
            finishHandler()
            return
        }

        if status.cloudUpdateNecessaryInfoFinished {
            finishHandler()
        }
    }
}

extension OnlineDeviceListMasterViewController: Storyboarded {
    static var storyboardName: String { return "DeviceList" }
    static var storyboardBundle: Bundle? { return Bundle.deviceListModuelBundle }
}

extension Notification.Name {
    static var DeviceListUpdated: Notification.Name { return Notification.Name("DeviceListUpdated") }
}

// MARK: - setup
extension OnlineDeviceListMasterViewController {
    private func setupView() {
        setupBarButtonItems()
        setupButtons()
    }

    private func setupBarButtonItems() {
        navigationItem.leftBarButtonItem = moreToolBarButtonItem
        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
    }

    private func setupButtons() {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }
}

// MARK: - reorder
extension OnlineDeviceListMasterViewController {
    // 本vc不会主动进入排序模式，而是依赖于OnlineDeviceListViewController的通知
    private func enterReorderMode() {
        isReordering = true
        tabBarController?.tabBar.isUserInteractionEnabled = false
        groupToolbarContainer.isUserInteractionEnabled = false

        pageController.scrollEnable = false

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
    }

    private func showUpdateAlertIfAny() {
        if DeviceListManager.shared.allDetailDevices.contains(where: {(DeviceListModule.shared.requiredService?.onboardingTypeFromQRCode(qrCode: $0.qrCode) ?? 0) == TPSS_EC_GENERAL} ) || DeviceListManager.shared.hasUnsupportedDevice {
            // 二维码获取不支持的设备或者读取设备列表中有不支持的设备时，弹出升级提示
            let lastVersion: (isShow: Bool, versionCode: Int) = DeviceListModule.shared.requiredService?.checkShowUpdateAlert() ?? (false, 0)
            if lastVersion.isShow {
                showAlertWith(title: LocalizedString(key: commonNoticeUpdateAPP), message: nil, messageTextAlignment: nil,
                              defaultButtonTitle: LocalizedString(key: commonUpdateNow), defaultButtonColor: .theme1,
                              cancelButtonTitle: LocalizedString(key: commonIgnoreNotice), cancelButtonColor: .black.withAlphaComponent(0.8),
                              cancelButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.updateUserNoMoreNotify(version: lastVersion.versionCode)
                    self.showDiskAlertIfAny()
                }, defaultButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.jumpAndCheckAppVersion()
                    self.showDiskAlertIfAny()
                })
            } else {
                showDiskAlertIfAny()
            }
        } else {
            showDiskAlertIfAny()
        }
    }

    private func exitReorderMode() {
        tabBarController?.tabBar.isUserInteractionEnabled = true
        groupToolbarContainer.isUserInteractionEnabled = true

        pageController.scrollEnable = true

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }

        isReordering = false
    }
}
//
//  SweeperMainViewController.swift
//  Pods
//
//  Created by 爱迪生 on 2021/8/2.
//

import UIKit
import SurveillanceHomeBase
import Promises
import SwiftyJSON
import SharedResource
import TPFoundation
import SimplePlayer
import DeviceDetailModule
import SnapKit
import NetService
import ThemeTool

enum CaptureImageLoadingStatus: Equatable {
    case loadSuccess
    case failure
    case loading
    case loadNoImage
    case model(SweeperBarrierType)
}

enum MainMapLoadingState {
    case loading
    case failure
    case noMap
    case hasMap
}

class SweeperMainViewController: SweeperGlobalConfigurationViewController {
    var needShowFastMapGuide: Bool = false
    // MARK: subviews
    private var previewButton: SweeperButton?
    weak var inputPasswordVC: UIViewController?
    var inputPassword: String?
    private var editButton: SweeperButton?
    private var baseStationButton: SweeperButton?
    private var moreButton: SweeperButton?
    private var parameterButton = SweeperButton()
    private var navigationTitleView = SweeperTitleBatteryView()
    private var chargeButton = SweeperButton()
    private var createMapContainer: SweeperCreateMapView?
    private var sweepAreaPopView: SweeperClearAreaPopView?
    private var sweeperAlarmViewController: (UIViewController & SweeperAlarmWindowSuitable)?
    private var startCleanAnimationView: SweeperStartCleanAnimationView?
    private var mapView = SweeperHomeMapView(frame: .zero, mapSize: .init(width: 1200, height: 1200))
    private var loadingView = SweeperMainMapLoadingView(frame: .zero)
    private var buttonContainerStackView = UIStackView()
    private var environmentView = UIView(frame: .zero)
    private var temperatureView = UILabel(frame: .zero)
    private var humidityView = UILabel(frame: .zero)
    private var equipmentOfflineView: SweeperRobotOfflineView?

    private var sweepControlView = SweeperControlView()
    private var sweepCaptureView = SweeperCaptureBubbleView()
    private var sweeperBaseUpgradingView = SweeperBaseStationUpgradingView()
    private var sweeperMechanicalOffView = SweeperMechanicalOffView()

    private var sweepControlViewHeightConstraint: NSLayoutConstraint?
    private var heightForControlView: CGFloat {
        switch status {
        case .stop:
            return 88 + bottomSafeAreaInset
        case .fastMap, .fastMapPause:
            return 69 + bottomSafeAreaInset
        case .sweepingPause, .sweeping:
            return 143 + bottomSafeAreaInset
        }
    }

    enum AlarmButtonClickMode {
        case exit
        case more
        case none
    }
    private var alarmButtonClickMode: AlarmButtonClickMode = .exit

    // 快速建图引导view
    private var fastMapImageView: UIImageView?
    private var fastMapGuideView: GuidePresentationView?


    // 地图已自动保存通知
    private var savedMapNoticeView: UIImageView?
    private var saveMapGuideView: GuidePresentationView?
    // 存储设备详细信息
    private var deviceDetail: DeviceDetail?
    private var isSharedDevice: Bool {
        return deviceDetail?.isSharedDevice ?? false
    }

    private var robotOffline = false
    private var hadStartWaveAnimation = false

    /// 首次载入
    /// 第一帧地图帧/路径帧到来时刷新所有界面
    private var needRefreshMapViewInMediaPlayer = true
    private var needEntrySaveMapLogic = true
    private var needShowCleaningLog = true

    /// 该属性用于，当前保存地图弹窗弹出时，扫地机正在清扫。保存该弹出状态，在清扫结束后再进入一遍保存地图逻辑。
    private var needEntrySaveMapLogicAfterBasicStateChanged = false


    /// 在地图变化时，将下列是否需要展示“地图保存”弹窗标识为true
    /// 在dataloading成功时，进行展示
    private var needShowSaveMapMultiFloor = false
    private var needShowSaveMapSingleFloor = false
    private var needShowMapHasSavedTip = false

    /// 基站升级与关机页面展示
    private var isShowingUpgradingView: Bool {
        get {
            return !sweeperBaseUpgradingView.isHidden
        }
        set {
            sweeperBaseUpgradingView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var isShowingMechanicalView: Bool {
        get {
            return !sweeperMechanicalOffView.isHidden
        }
        set {
            sweeperMechanicalOffView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var shouldShowChargeButton: Bool {
        get {
            guard let state = state else {
                return false
            }
            // 清扫完成并且不在基站上
            return state.cleanFinished && !state.onboard
        }
    }

    private var firstTimeUpdateNavigationTitle: Bool = true

    private var cleaningMode: SweeperCleaningMode {
        get {
            return sweeperControl?.cleaningMode ?? SweeperCleaningMode.init(type: .autoClean)
        }
        set {
            sweeperControl?.cleaningMode = newValue
            updateCleaningModeUI()
        }
    }

    private var cleaningModeType: CleaningModeType {
        get {
            return cleaningMode.type
        }
        set {
            cleaningMode.type = newValue
        }
    }

    override var sweeperCustomOrAutoMode: SweeperCustomOrAutoMode {
        get {
            return (sweeperControl?.customCleanEnabled ?? false) ? .custom : .auto
        }
        set { }
    }

    private var map: SweeperMap? {
        get {
            return sweeperControl?.map
        }
        set {
            let preMap = map
            sweeperControl?.map = newValue
            currentMapDidChanged(preMap: preMap)
        }
    }

    private var status: SweeperProcedure = .stop

    private var state: SweeperState? {
        get {
            return sweeperControl?.basicState
        }

        set {
            sweeperControl?.basicState = newValue
            basicStateChangeAction(showToast: true)
        }
    }

    private var temperatureText: String {
        get {
            var text = "环境温度："
            if let temperature = state?.temperature {
                let temperatureValue = Int(temperature)
                if temperatureValue == 127 || temperatureValue < -40 {
                    text += "--"
                } else {
                    text += "(Int(temperature))℃"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var humidityText: String {
        get {
            var text = "环境湿度："
            if let humidity = state?.humidity {
                let humidityValue = Int(humidity)
                if humidityValue < 0 || humidityValue > 100 {
                    text += "--"
                } else {
                    text += "(Int(humidity))%"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var cleaningState: SweeperCleaningState? {
        get {
            return sweeperControl?.cleaningState
        }

        set {
            sweeperControl?.cleaningState = newValue
            updateCleaningStateUI()
        }
    }

    private var isRecharging: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .recharge
    }

    private var forbiddenRechargeAndClean: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .assignLocation || state.mainState == .remoteControl
    }

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = SharedResource.sharedImage(named: "shared_setting_icon_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(settingBarButtonItemDidClick))
    }()

    // selected layerID backup
    private var selectedLayerID = [Int]()

    // 当前展示的障碍物ID
    private var obstacleID: Int?

    override var navigationBarTraits: [NavigationBarTrait] {
        return [.hidden(on: false), .style(style: .default), .translucent(on: false), .barTint(color: .init(hexString: lightGray10Color)), .separatorStyle(color: .clear, height: 0.0), .backgroundImage(image: UIImage())]
    }

    // MARK: - Constants
    private let chargeButtonPadding = 8.0
    private let defaultButtonPadding = 12.0
    private let defaultButtonInterval = 59.0
    private let battreyThreshold = 20
    private let bottomSafeAreaInset = TPUIUtils.safeAreaInsets().bottom

    override init(deviceID: TPSSDeviceIdentifier, listType: TPSSDeviceListType) {
        super.init(deviceID: deviceID, listType: listType)

        SweeperModule.shared.registerControlListener(listener: self, deviceID: deviceID, listType: listType)
        SweeperModule.shared.registerMapListener(mapListener: self)
        NotificationCenter.default.addObserver(self, selector: #selector(willEnterForeground), name: UIApplication.willEnterForegroundNotification, object: nil)
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        view.backgroundColor = .init(hexString: lightGray10Color)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        setupNavigation()
        setupControlView()
        setupMapView()
        setupSweeperAlarmView()
        setupButtons()
        setupOfflineView()
        setupEnvironmentView()
        setupLoadingView()
        setupUpgradingView()
        setupMechanicalOffView()
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true

        // 离开当前页面时，会使动画失效，若正在展示动画，再重新进入时，需要重新开始动画
        if hadStartWaveAnimation {
            startWaveAnimation()
        }

        if let loadingState = sweeperControl?.dataLoadingState {
            dataLoadingStateChangeAction(loadingState: loadingState)
        } else {
            updateViewShowState(state: .failed)
        }
        captureBubbleViewDismiss()
        // 横幅始终展示在最前方
        if let alarmView = sweeperAlarmViewController?.view {
            view.bringSubviewToFront(alarmView)
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        if needShowFastMapGuide {
            showFastMapGuideView()
            needShowFastMapGuide = false
        }
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        savedMapNoticeView?.removeFromSuperview()
    }

    deinit {
        SweeperModule.shared.removeControlListener(listener: self)
        SweeperModule.shared.removeMapListener(mapListener: self)
        NotificationCenter.default.removeObserver(self)
    }

    // 将从后台切换到前台，看作视图willAppear，方法作相同处理
    @objc func willEnterForeground() {
        cleanAllFlag()

        // 若当前的载入状态为loading时，对UI进行loading状态的刷新。
        // 否则等待dataLoadingStateDidChanged方法回调(从 loading -> 其他状态)。
        // 注：dataLoadingStateDidChanged方法在 loading -> loading 时不会被调用。
        if sweeperControl?.dataLoadingState == .loading {
            dataLoadingStateChanged(loadingState: .loading)
        }
    }

    /// 根据载入状态更新主页面View的展示情况
    /// -主页面加载状态 -
    /// 需要管理的控件：创建地图按钮、主页面地图、载入（载入失败）页面、编辑地图按钮、边扫边拖（定制清扫）悬浮按钮
    private func updateViewShowState(state: SweeperDataLoadingState) {
        switch state {
            case .loading:
                loadingView.isHidden = false
                loadingView.isLoadingFailure = false
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
            case .failed:
                loadingView.isLoadingFailure = true
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
                // 若扫地机离线，则展示离线页面，否则展示加载失败页面
                loadingView.isHidden = robotOffline
                equipmentOfflineView?.isHidden = !robotOffline
            case .noMap:
                createMapContainer?.isHidden = false
                loadingView.isHidden = true
                mapView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                parameterButton.isHidden = false
                moreButton?.isHidden = false
                editButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
            case .success:
                loadingView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                mapView.isHidden = false
                createMapContainer?.isHidden = true
                parameterButton.isHidden = false
                editButton?.isHidden = false
                moreButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
        }
    }

    override func willUpdateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode, showAlert: Bool) -> Bool {
        /// 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            if showAlert {
                showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap)
            }
            return false
        }
        return super.willUpdateSweeperCustomOrAutoMode(newMode: newMode, showAlert: showAlert)
    }

    override func updateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode) {
        /// 1. 若切换时当前清扫模式与newMode相同，则无需进入后续逻辑
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap,
              let sweeperControl = sweeperControl,
              let mapID = sweeperControl.map?.currentMapID,
              newMode != sweeperCustomOrAutoMode else {
            return
        }

        /// 2. 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap) { [weak self] (_) in
                self?.configurationView?.selectSegment(type: .auto)
            }
            return
        }

        /// 3. 切换为定制清扫时，无设置清扫顺序与清扫偏好，则不向设备发送请求（并在退出弹窗时（configurationFinished）切换回变扫边拖）
        if newMode == .custom && !isSetPreference() && !isSetSweepSeq() {
            return
        }

        /// 4. 发送切换清扫模式的接口，并修改主页面UI
        let customCleanEnabled = newMode == .custom
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestSetCleaningParam(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: mapID, customEnabled: customCleanEnabled).always {
            ToastView.dismissLoadingToast()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }

    override func configurationFinished() {
        /// 若configurationView当前处于定制清扫页面（“1”状态），则判断是否已设置定制清扫，若否切回边扫边拖。
        if !isSetPreference() && !isSetSweepSeq() && !settingButtonDidClickFlag && configurationView?.segmentedControl.selectedSegmentIndex == 1 {
            ToastView.showWarningToast(title: "未设置定制清扫，只能使用普通清扫", existTime: nil, centerY: .low)
            // 0 - means auto cleaning
            configurationView?.selectSegment(type: .auto)
        }
    }

    override func preferenceButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.preferenceButtonClickOperation()
    }

    override func sweepOrderButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.sweepOrderButtonClickOperation()
    }

    private func refreshMediaPlayerAndSweeperControl() {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.refreshSweeperControl()
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
    }

    private func updateConfigurationView() {
        configurationView?.selectSegment(type: sweeperCustomOrAutoMode)
        if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
            cleanMethodMode = mode
        }
    }

    private func updateClearingAreaButton() {
        var text = "全屋"
        var imagePath = "sweep_home"
        var title = text
        switch cleaningModeType {
        case .pointClean:
            text = "选框"
            title = text
            imagePath = "sweep_frame"
        case .areaClean:
            text = "区域"
            title = text
            imagePath = "sweep_region"
        case .autoClean:
            text = "全屋"
            title = text
            imagePath = "sweep_home"
        case .partClean:
            // 仅在sweepControlView的RangeTitle中修改
            updateData(with: .autoClean)
            title = "局部"
        case .fastMap:
            // DO NOTHING
            return
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
        sweepControlView.clearAreaButton?.titleLabel.text = text
        sweepControlView.clearAreaButton?.titleImageView.image = UIImage.image(named: imagePath)
        sweepControlView.rangeTitleLabel.text = title
        sweepControlView.clearAreaButton?.selectedAreaNumber = cleaningModeType == .areaClean ? selectedLayerID.count : 0
    }

    private func updateSweeperHomeMapViewCleanMode() {
        switch cleaningModeType {
        case .pointClean:
            mapView.cleaningModeType = .pointClean
        case .areaClean:
            mapView.cleaningModeType = .areaClean
        case .autoClean:
            mapView.cleaningModeType = .autoClean
        case .partClean:
            mapView.cleaningModeType = .partClean
        case .fastMap:
            mapView.cleaningModeType = .fastMap
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
    }

    private func updateSelectedLayerID() {
        if let seq = sweeperControl?.cleaningMode.areaIDs {
            selectedLayerID = seq
        }
    }

    private func updateParamUI() {
        var text = ""
        var imagePath = ""
        switch sweeperCustomOrAutoMode {
        case .auto:
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                switch mode {
                case .sweep:
                    text = LocalizedString(key: sweeperCleanOnlySweep)
                    imagePath = "mode_sweep"
                case .mop:
                    text = LocalizedString(key: sweeperCleanOnlyMop)
                    imagePath = "mode_mop"
                case .both:
                    text = LocalizedString(key: sweeperCleanSweepAndMop)
                    imagePath = "mode_sweep_mop"
                }
            }
        case .custom:
            text = LocalizedString(key: sweeperCustomClean)
            imagePath = "mode_diy"
        }
        let image = UIImage.image(named: imagePath)
        // 控制栏的参数按钮
        sweepControlView.parameterButton?.titleLabel.text = text
        sweepControlView.parameterButton?.titleImageView.image = image

        // 悬浮的参数按钮
        parameterButton.titleLabel.text = text
        parameterButton.titleImageView.image = image
    }

    private func updateSweeperHomeMapViewCustomOrAutoMode() {
        switch sweeperCustomOrAutoMode {
        case .auto:
            mapView.sweeperCustomOrAutoMode = .auto
        case .custom:
            mapView.sweeperCustomOrAutoMode = .custom
        }
    }

    private func dataLoadingStateChangeAction(loadingState: SweeperDataLoadingState) {
        // 1. 判断设备是否离线（deviceDetail.online）
        if loadingState == .failed {
            robotOffline = !(deviceDetail?.online ?? false)
        }

        // 2. 判断基站是否升级，若是，则不展示所有UI（除了导航栏）
        if state?.chargeBaseUpgrading == true {
            isShowingUpgradingView = true
            updateNavigation()
            return
        }

        if let switchOn = state?.mechanicalSwitchOn {
            showMechanicalOffView(switchOn: switchOn)
        }

        // 3. 刷新UI状态(是否hidden)
        updateViewShowState(state: loadingState)

        // 4. 载入成功（success or nomap）按照其他状态展示UI
        if loadingState == .success {
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            mapView.updateCleanningModeAndSweepingState()
            mapView.updateCustomOrAutoMode()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            sweeperAlarmViewController?.showAlarm()
            sweeperAlarmViewController?.showNotify()
            if needShowCleaningLog {
                sweeperAlarmViewController?.showCleaningLog()
                needShowCleaningLog = false
            }
            if needEntrySaveMapLogic {
                currentMapDidChanged(preMap: nil)
                needEntrySaveMapLogic = false
            }
            saveMapLogic()
        } else if loadingState == .noMap {
            // 尽管当前map id 为-2，但当设备发送地图帧过来时，仍然需要展示地图，故仍然需要刷新mapView
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            sweeperAlarmViewController?.showCleaningLog()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            // 用户未进入引导页，且当前不在清扫、建图中，需要进入快速建图引导页
            if UserDefaults.standard.shouldShowGuideForFastMap(for: deviceID) && (state?.cleanFinished ?? true) {
                let vc = SweeperFastMapGuideViewController(deviceID: deviceID, listType: listType)
                navigationController?.pushViewController(vc, animated: true)
            }
        }
    }

    private func saveMapLogic() {
        // 若需要展示弹窗，但当前在清扫中，则将弹窗状态保存起来，待扫地机状态变化时重新进入。
        if state?.cleanFinished == false && (needShowSaveMapSingleFloor || needShowSaveMapMultiFloor) {
            needEntrySaveMapLogicAfterBasicStateChanged = true
            return
        }
        if needShowMapHasSavedTip {
            showMapHasSavedTip()
            needShowMapHasSavedTip = false
        }
        if needShowSaveMapSingleFloor {
            saveMapSingleFloor()
            needShowSaveMapSingleFloor = false
        }
        if needShowSaveMapMultiFloor {
            saveMapMultiFloor()
            needShowSaveMapMultiFloor = false
        }
    }

    private func basicStateChangeAction(showToast: Bool) {
        // 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 展示波纹动画: 1. 当前地图ID为-2；
        //             2. 当前在清扫中；
        //             3. 未展示过动画
        //             4. 无地图帧
        if map?.currentMapID == noMapID
            && state?.cleanFinished == false && !hadStartWaveAnimation && sweeperControl?.hadFrame == false {
            startWaveAnimation()
        }
        if (state?.cleanFinished == true) {
            stopWaveAnimation()
        }
        // 特殊情况处理，当扫地机进入清扫状态时
        // 且当前处于无地图时，需要显示地图（而非等到map更改的信令进行变化）
        // 再次变为非清扫状态，且无地图时，需要展示无地图Image
        if map?.currentMapID == noMapID && state?.cleanFinished == false {
            updateViewShowState(state: .success)
        } else if map?.currentMapID == noMapID && state?.cleanFinished == true {
            updateViewShowState(state: .noMap)
        }

        // 扫地机关机状态更新
        showMechanicalOffView(switchOn: state?.mechanicalSwitchOn ?? false)

        if showToast {
            updateBasicStateToastView()
        }
        // 更新扫地机当前的清扫状态（将扫地机状态分为清扫中、暂停中、未清扫，后续根据该status更新清扫UI）
        updateSweepProduce()

        updateUI()
    }

    /// 使用Clean Finished，fast Map  字段与 basic state字段联合判断当前清扫是否结束
    private func updateSweepProduce() {
        guard let state = state else {
            status = .stop
            return
        }
        if state.cleanFinished && state.mainState != .paused && state.mainState != .cleaning {
            // 若设备清扫完成且设备主状态不在清扫、暂停时
            status = .stop
        } else {
            if state.fastMap {
                // 若为快速建图
                if state.mainState == .cleaning {
                    status = .fastMap
                } else {
                    status = .fastMapPause
                }
            } else {
                // 若不为快速建图，则展示正常清扫UI
                if state.mainState == .cleaning {
                   status = .sweeping
                } else {
                   status = .sweepingPause
                }
            }
        }
    }

    // 根据信令展示ToastView
    private func updateBasicStateToastView() {
        guard let state = state else {
            return
        }
        // 主状态为回充，遥控，清扫时候，主页均需展示loading
        if ((state.mainState == .cleaning || state.mainState == .recharge || state.mainState == .remoteControl) && state.subState == .relocate) {
            ToastView.showLoadingToast(cirleWithMessage: "定位中...", existTime: 60, existMessage: nil)
        } else {
            ToastView.dismissLoadingToast()
        }
    }

    /// 根据status更新：清扫面板、清扫参数、导航栏里扫地机的状态、回充按钮、提示栏的位置；
    /// status:     sweeping：当cleanFinished为false，且mainState为Cleaning，subState为Sweeping；
    ///        pause：当cleanFinished为false，
    private func updateUI() {
        // 只当地图数据载入完成之后，更新信令收到后的UI
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 每次收到信令后，获取设备状态，更新设备状态同时更新界面UI

        // 控制面板
        sweepControlView.status = status
        sweepControlViewHeightConstraint?.constant = heightForControlView
        if status == .stop {
            // 清扫参数按钮
            parameterButton.isHidden = true
            // 地图控件
            mapView.isSweeping = false
        } else if status == .fastMap || status == .fastMapPause {
            mapView.isSweeping = true
            parameterButton.isHidden = true
        } else {
            parameterButton.isHidden = false
            mapView.isSweeping = true
        }
        // 导航栏的状态和电量
        updateNavigation()
        // 温度湿度更新
        updateEnvironmentView()
        // 充电按钮
        updateChargeButton()
        refreshBubbleView()
    }

    private func updateCleaningStateUI() {
        guard let state = cleaningState else {
            return
        }
        sweepControlView.areaTitleLabel.text = "(state.cleaningArea)㎡"
        sweepControlView.timeTitleLabel.text = "(state.cleaningTime)min"
    }

    private func updateCleaningModeUI() {
        /// 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        /// 修改设置清扫模式（cleaningMode）按钮的样式
        updateClearingAreaButton()
        /// 修改地图的清扫模式
        updateSweeperHomeMapViewCleanMode()
        /// 根据获取到的cleaningMode中区域清扫的ID，更新地图区域的清扫顺序数组
        updateSelectedLayerID()
        /// 修改定制清扫/边扫边拖属性 - 通过回调去更新该属性更新后主页后续的UI。回调中调用的方法 - updateSweeperCustomOrAutoMode()
        updateConfigurationView()
        /// 修改定制清扫/边扫边拖按钮的样式
        updateParamUI()
        /// 修改定制清扫/边扫边拖地图的样式
        updateSweeperHomeMapViewCustomOrAutoMode()
    }

    private func showAlertWithWholeHouseClean() {
        showAlertWith(title: "进行一次全屋清扫", message: "清扫完成后，将建立家居地图。", messageTextAlignment: .center, defaultButtonTitle: "进行全屋清扫", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonHandler: nil) { [weak self] (_) in
            self?.showSweepTipsAlert()
        }
    }

    private func startFastMap() {
        if sweeperControl?.basicState?.mainState == .remoteControl {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFastMapDuringRemoteControl))
            return
        }
        if sweeperControl?.basicState?.mainState == .assignLocation {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFAstMapDuringAssignLocation))
            return
        }
        // 强制扫地机进入新建快速地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .fastMap)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: self.deviceID, channel: self.channel, listType: self.listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func startFastMapAlert() {
        let alert = SweeperTipsAlert(type: .fastMap) { [weak self] () in
            guard let self = self else { return }
            self.startFastMap()
        }
        alert.show()
    }

    private func showAlertWithFastMapEnd() {
        showAlertWith(title: "尚未得到完整地图，确定要结束吗？", message: nil, messageTextAlignment: .center, defaultButtonTitle: "结束建图", defaultButtonColor: .theme1, cancelButtonTitle: "继续", cancelButtonHandler: nil) { [weak self] (_) in
            self?.setCleaningMode(type: .stop)
        }
    }

    private func showSweepTipsAlert() {
        let alert = SweeperTipsAlert(type: .clean) { [weak self] () in
            self?.setCleaningMode(type: .sweeping)
        }
        alert.show()
    }

    private func setCleaningMode(type: SweeperProcedure) {
        switch type {
        case .sweeping:
            if sweeperControl?.basicState?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringRemoteControl))
                return
            }
            if sweeperControl?.basicState?.mainState == .assignLocation {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringAssignLocation))
                return
            }
            // 若扫地机当前无地图，则所有“清扫”操作为全屋清扫。
            if map?.currentMapID == noMapID {
                self.cleaningMode = SweeperCleaningMode.init(type: .autoClean)
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: SweeperCleaningMode.init(type: .autoClean)).catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
                return
            }

            if cleaningModeType == .areaClean {
                if selectedLayerID.count == 0 {
                    ToastView.showWarningToast(title: "请选择需要清扫的区域", existTime: nil, centerY: .low)
                    return
                }
                sweeperControl?.cleaningMode.areaIDs = selectedLayerID
            } else if cleaningModeType == .pointClean,
                      let partArea = mapView.getSelectionRect() {
                // 若能够从SelectionRect获取到数据，则修改cleaningMode的PointRect
                sweeperControl?.cleaningMode.leftTopPoint = partArea.leftTopPoint
                sweeperControl?.cleaningMode.rightBottomPoint = partArea.rightBottomPoint
            } else {
                sweeperControl?.cleaningMode = .init(type: .autoClean)
            }

            ToastView.showLoadingToast(cirleWithMessage: nil)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: sweeperControl?.cleaningMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .sweepingPause, .fastMapPause:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .pause)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .stop:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .stop)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .fastMap:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .fastMap)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func saveMapSingleFloor() {
        let deleteMapID = map?.allMapNames.keys.first(where: { (mapID) -> Bool in
                  return mapID != temporaryMapID
              })
        guard let sweeperControl = sweeperControl,
              let deleteMapID = deleteMapID,
              let deleteMapName = map?.allMapNames[deleteMapID] else {
            return
        }
        showAlert(title: "是否保存新地图?", buttons: [
            .init(style: .default, text: "更新“(deleteMapName)”", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                ToastView.showLoadingToast(cirleWithMessage: "正在更新")
                SweeperService.deleteMap(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: deleteMapID).then { (_) in
                    ToastView.showWarningToast(title: "更新成功", existTime: nil, centerY: .low)
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
            }),
            .init(style: .default, text: "另存为新地图", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let alert = SweeperSelectionAlert(title: "相同环境请勿保存多张地图，有可能影响机器人的定位。", message: "我家为多楼层户型") {
                    guard self?.isCurrentMapSaved() == true else {
                        ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                        return
                    }
                    ToastView.showLoadingToast(cirleWithMessage: "正在保存")
                    SweeperService.setMultiFloorEnabled(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, enabled: true, mapID: nil).always {
                        ToastView.dismissLoadingToast()
                    }.then { _ in
                        ToastView.showWarningToast(title: "保存成功", existTime: nil, centerY: .low)
                    }.catch { (error) in
                        ToastView.showWarningToast(warningMessage: error.localizedDescription)
                    }
                } cancelHandler: { [weak self] () in
                    self?.saveMapSingleFloor()
                }
                alert.show()
            }, isPreferred: true),
            .init(style: .default, text: LocalizedString(key: notSaveMap))
        ])
    }

    private func saveMapMultiFloor() {
        showAlert(title: "地图数量已达上限，是否保存新地图？", message: "如点击“保存”，请选择新地图要覆盖哪张旧地图。", messageTextAlignment: .center, buttons: [
            .init(style: .default, text: LocalizedString(key: notSaveMap), color: .theme1),
            .init(style: .default, text: "保存", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let vc = SweeperCoverOldMapController()
                vc.sweeperControl = self?.sweeperControl
                self?.navigationController?.pushViewController(vc, animated: true)
            }, isPreferred: true)
        ])
    }

    private func isCurrentMapSaved() -> Bool {
        return map?.currentMapID == temporaryMapID
    }

    /// preMapID 为 nil，表示为第一次赋值
    private func currentMapDidChanged(preMap: SweeperMap?) {
        guard let map = map else {
            return
        }
        // 展示波纹动画条件： 1. 当前地图id为-2
        //                 2. 当前主状态为清扫中
        //                 3. 第一次进入主页面
        //                 4. 当前无地图I帧
        let needShowRobotWave = map.currentMapID == noMapID && sweeperControl?.basicState?.mainState == .cleaning && (preMap == nil || !hadStartWaveAnimation) && sweeperControl?.hadFrame == false
        if needShowRobotWave {
            startWaveAnimation()
        }
        /// preMapID 从 nil -> 0，未处理后退出主页重新进入
        /// 或 从 “-1” -> 0  表示成功创建，但还未自动保存新地图
        let preMapID = preMap?.currentMapID
        if (preMapID == nil || preMapID == isCreatingMapID) && map.currentMapID == temporaryMapID {
            ///  生成临时地图： 需要判断是多楼层还是单楼层来决定保存方式；
            guard let multiFloorEnabled = sweeperControl?.multiFloorEnabled, let maxMapNumber = sweeperControl?.capability?.maxMapNumber else {
                return
            }
            if multiFloorEnabled {
                if map.mapNumber > maxMapNumber && maxMapNumber > 0 && map.currentMapID == temporaryMapID {
                    // 地图已达上限且能力集中多楼层地图上限不为0，且当前地图是临时地图时，展示多楼层地图上限弹窗
                    needShowSaveMapMultiFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            } else {
                if map.mapNumber > 1 && map.currentMapID == temporaryMapID {
                    // 已经有一张地图且当前地图时临时地图时，展示单楼层地图上限弹窗。
                    needShowSaveMapSingleFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            }
            return
        }

        /// 成功创建，mapID 从 “-1” -> 大于0
        if preMapID == isCreatingMapID && map.currentMapID != noMapID && map.currentMapID != temporaryMapID && map.allMapNames.count == (preMap?.allMapNames.count ?? 0) + 1 {
            ///  生成完整地图：直接进入“已自动保存逻辑”
            needShowMapHasSavedTip = true
        }
    }

    private func showMapNotCompletedAlert(alertMessage: String, cancelHandler: ((UIAlertAction) -> Void)? = nil, defaultHandler: (() -> Void)? = nil) {
        showAlertWith(title: alertMessage, message: nil, messageTextAlignment: nil, defaultButtonTitle: "查看帮助", defaultButtonColor: .theme1, cancelButtonTitle: "关闭", cancelButtonColor: .theme1, cancelButtonHandler: cancelHandler, defaultButtonHandler: { [weak self] (_) in
            let vc = SweeperMapHelpViewController(type: .incomplete)
            self?.navigationController?.pushViewController(vc, animated: true)
            defaultHandler?()
        })
    }

    private func showCanNotCustomCleanAlert(isCreatingMap: Bool, defaultButtonhandler: ((UIAlertAction) -> Void)? = nil) {
        if isCreatingMap {
            showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持定制清扫", defaultHandler: { [weak self] () in
                self?.configurationView?.dismiss()
            })
        } else {
            showAlertWith(title: "请创建地图后再设置定制清扫", defaultButtonTitle: SharedResource.sharedFormatString(key: commonSure), defaultButtonColor: UIColor.black, cancelButtonTitle: nil, defaultButtonHandler: defaultButtonhandler)
        }
    }

    func showFastMapGuideView() {
        if fastMapImageView == nil {
            fastMapImageView = UIImageView()
            fastMapImageView?.image = UIImage.image(named: "quick_build_map")
            fastMapImageView?.sizeToFit()
        }
        guard let imageView = fastMapImageView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            fastMapGuideView?.dismiss()
            var offset: CGFloat = defaultButtonInterval
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            fastMapGuideView = presentGuideWith(viewToPresent: imageView, size: imageView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    func showMapHasSavedTip() {
        if savedMapNoticeView == nil {
            savedMapNoticeView = UIImageView()
            savedMapNoticeView?.image = UIImage.image(named: "edit_map")
            savedMapNoticeView?.sizeToFit()
        }
        guard let noticeView = savedMapNoticeView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            saveMapGuideView?.dismiss()
            var offset: CGFloat = 0
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            saveMapGuideView = presentGuideWith(viewToPresent: noticeView, size: noticeView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    override func collectionViewCell(_ cell: SweeperGlobalCleaningConfigurationCollectionViewCell, didSelectItemAt indexPath: IndexPath) {
        super.collectionViewCell(cell, didSelectItemAt: indexPath)

        let itemIndex = indexPath.section
        let row = indexPath.row
        let parameter = settingItems[itemIndex].paramters[row].type
        if parameter == .suctionForce(.none) {
            showAlertWith(title: "静音模式下吸尘能力将暂时降低，仅本次清扫任务生效。", message: nil, messageTextAlignment: nil, defaultButtonTitle: "确定", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonColor: .black, cancelButtonHandler: nil) { [weak self] (_) in
                self?.setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
            }
        } else {
            setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
        }
    }

    func setGlobalConfig(parameter: SweeperGlobalConfigurationType, itemIndex: Int) {
        var pendingConfig = sweeperControl?.globalCleaningConfig

        switch parameter {
        case .suctionForce(_):
            pendingConfig?.suction = parameter
        case .waterYield(_):
            pendingConfig?.waterYield = parameter
        case .sweepTimes(_):
            pendingConfig?.cleanTimes = parameter
        case .cleanMethod(_):
            pendingConfig?.cleanMethod = parameter
        case .mopMode(_):
            pendingConfig?.mopMode = parameter
        }


        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setGlobalCleaningConfig(device: deviceID, channel: channel, listType: listType, config: pendingConfig).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.then { [weak self] (_) in
            self?.sweeperControl?.globalCleaningConfig = pendingConfig
            self?.configurationView?.collectionView.reloadData()
            self?.updateParamUI()
        }
    }

    func startWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        let animationView = SweeperStartCleanAnimationView(frame: .zero)
        view.addSubview(animationView)

        animationView.snp.makeConstraints { make in
            make.centerX.equalToSuperview().offset(28)
            make.centerY.equalToSuperview().multipliedBy(0.764).offset(28)
            make.width.height.equalTo(56)
        }
        self.startCleanAnimationView = animationView
        animationView.startAnimation()
        hadStartWaveAnimation = true
    }

    func stopWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        startCleanAnimationView = nil
        hadStartWaveAnimation = false
    }

    private func cleanAllFlag() {
        needEntrySaveMapLogic = true
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true
        needShowMapHasSavedTip = false
        needShowSaveMapMultiFloor = false
        needShowSaveMapSingleFloor = false
        needEntrySaveMapLogicAfterBasicStateChanged = false
    }
}

// MARK: Button Action
private extension SweeperMainViewController {
    @objc func paramterButtonDidClick() {
        configurationView?.isSetSeq = isSetSweepSeq()
        configurationView?.isSetPreference = isSetPreference()
        configurationView?.show(view: self.navigationController?.view)
    }

    @objc func clearAreaButtonDidClick() {
        sweepAreaPopView = SweeperClearAreaPopView(type: cleaningModeType)
        sweepAreaPopView?.delegate = self
        sweepAreaPopView?.show()
    }

    @objc func startButtonDidClick() {
        guard (map?.currentMapID) != nil  else {
            return
        }
        if sweeperControl?.dataLoadingState == .success {
            setCleaningMode(type: .sweeping)
        } else {
            showAlertWithWholeHouseClean()
        }
    }

    @objc func stopButtonDidClick() {
        if status == .fastMapPause || status == .fastMap {
            showAlertWithFastMapEnd()
        } else {
            setCleaningMode(type: .stop)
        }
    }

    @objc func pasueButtonDidClick() {
        if status == .sweepingPause {
            setCleaningMode(type: .sweeping)
        } else if status == .fastMapPause {
            setCleaningMode(type: .fastMap)
        } else {
            setCleaningMode(type: .sweepingPause)
        }
    }

    @objc func previewButtonDidClick() {
        guard let mediaState = sweeperControl?.mediaState, checkEntryCondition() else {
            return
        }
        checkMediaStateAndJump(state: mediaState)
    }

    func checkMediaStateAndJump(state: SweeperMediaState) {
        // 若为被分享端，则不判断，直接进入人工驾驶页面
        if isSharedDevice {
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            vc.needShowSettingButton = false
            navigationController?.pushViewController(vc, animated: true)
            return
        }

        switch state {
        case .closed, .open:
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        case .openWithPermission:
            if sweeperControl?.mediaEncryptEnabled == true {
                // 视频加密开启，直接验证密码
                checkUnAuthenticated()
                return
            }
            // 视频加密关闭，需要检测设备空密码
            ToastView.showLoadingToast(cirleWithMessage: nil)
            requestCheckEmptyPassword {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func checkEntryCondition() -> Bool {
        if state?.collectDust == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterCollectionDust))
            return false
        }
        if state?.mopWashState == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterWashingMop))
            return false
        }
        return true
    }

    @objc func baseStationButtonDidClick() {
        if sweeperControl?.basicState?.cleanSinkState != .stop {
            let vc = SweeperBaseStationCleanSinkViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        } else {
            let vc = SweeperBaseStationMainViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func moreButtonDidClick() {
        let vc = SweeperMoreActionViewController(deviceID: deviceID, listType: listType)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    @objc func editButtonDidClick() {
        // 大于0的地图数量为0时(无已保存地图)并且没有地图，不允许进入，若mapID为“-1”允许进入
        if sweeperControl?.mapWithoutZero?.count == 0 && sweeperControl?.map?.currentMapID == noMapID {
            // 若扫地机在清扫、建图时，展示暂无地图
            if (state?.cleanFinished ?? true) {
                let fastMapGuideSheet = SweeperFastMapSheet()
                fastMapGuideSheet.delegate = self
                fastMapGuideSheet.show()
            } else {
                ToastView.showWarningToast(title: "暂无地图", existTime: nil, centerY: .low)
            }
            return
        }

        let alertActionSheet = TPActionSheet.init(title: nil)
        let setRigionAction = TPActionSheetAction.init(title: "设置禁区/虚拟墙", detail: "设置不允许扫地机器人进入的区域", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }

            // 清扫过程中进入编辑禁区页面需要暂停扫地机
            if self.status == .sweeping || self.status == .fastMap {
                self.setCleaningMode(type: .sweepingPause)
            }
            // 回充过程中进入编辑进去页面需要设置为待机
            if self.state?.mainState == .recharge {
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setStandBy(deviceID: self.deviceID, listType: self.listType).always {
                    ToastView.dismissLoadingToast()
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }
            }
            // 指哪到哪和遥控时不允许进入禁区页面
            if self.state?.mainState == .assignLocation || self.state?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterMission))
                return
            }
            let vc = SweeperForbiddenAreaVirtualWallViewController(sweeperControl: self.sweeperControl)
            self.navigationController?.pushViewController(vc, animated: true)
        }

        let editMapAreaAction = TPActionSheetAction.init(title: "编辑地图区域", detail: "划分地图区域并进行标记", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }
            /// 清扫、快速建图中不允许进入编辑区域页面
            if self.status != .stop {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterCleaning))
                return
            }
            /// 正在创建地图中不允许进入编辑区域页面
            guard self.map?.currentMapID != isCreatingMapID else {
                self.showMapNotCompletedAlert(alertMessage: LocalizedString(key: sweeperMapIsNotCompleteForEditingArea))
                return
            }
            let vc = SweeperEditMapAreaViewController(sweeperControl: self.sweeperControl)
            vc.isSetPreferenceOrOrder = self.isSetPreference() || self.isSetSweepSeq()
            self.navigationController?.pushViewController(vc, animated: true)
        }


        let manageMapAction = TPActionSheetAction.init(title: "管理地图", style: .leftTitle) { [weak self] (_) in
            guard let self = self else {
                return
            }
            let vc = SweeperMapManagerViewController()
            vc.delegate = self
            vc.deviceID = self.deviceID
            vc.listType = self.listType
            self.navigationController?.pushViewController(vc, animated: true)
        }

        var editActionArray: [TPActionSheetAction] = []
        editActionArray = map?.currentMapID == noMapID ? [manageMapAction] : [setRigionAction, editMapAreaAction, manageMapAction]

        editActionArray.forEach { (action) in
            action.font = .projectFont(ofSize: 16)
            action.detailFont = .projectFont(ofSize: 12)
            alertActionSheet.addAction(action)
        }
        alertActionSheet.separatorColor = .cellSeparatorGray

        alertActionSheet.show()
    }

    @objc func settingBarButtonItemDidClick() {
        if let vc = SweeperSettingViewController.create() {
            vc.deviceID = deviceID
            vc.listType = listType
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func rechargeButtonDidClick() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setRechargeState(device: deviceID, channel: channel, listType: listType, enabled: !isRecharging).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperRobotOfflineViewDelegate {
    func offlineHelpButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.requiredService?.goToOfflineHelp(deviceID: sweeperControl.deviceID, cloudID: sweeperControl.cloudID, listType: sweeperControl.listType, navigator: self.navigationController)
    }

    func offlineRefreshButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
        SweeperModule.shared.refreshSweeperControl()
    }
}

extension SweeperMainViewController: SweeperClearAreaPopViewDelegate {
    func updateData(with type: CleaningModeType) {
        if map?.currentMapID == isCreatingMapID {
            switch type {
            case .areaClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持区域清扫")
            case .pointClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持选框清扫")
            case .autoClean:
                // DO NOTHING
                break
            case .partClean:
                // DO NOTHING
                break
            case .pause:
                // DO NOTHING
                break
            case .stop:
                // DO NOTHING
                break
            case .fastMap:
                // DO NOTHING
                break
            }
            sweepAreaPopView?.dismiss()
            return
        } else {
            if type == .areaClean {
                if map?.currentMapID != noMapID {
                    ToastView.showWarningToast(title: "请选择区域", existTime: nil, centerY: .low)
                }
            }
        }
        self.cleaningModeType = type
        sweepAreaPopView?.dismiss()
    }
}

// MARK: setup UI
private extension SweeperMainViewController {
    func setupNavigation() {

        navigationItem.title = deviceDetail?.alias ?? "扫地机器人"

        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
        addCustomNavigationLeftBarButtonItem(title: nil, image: SharedResource.sharedImage(named: "common_light_back_nor"))
    }

    func setupButtons() {
        var title: String
        var imageName: String
        if isSharedDevice {
            title = "遥控"
            imageName = "ptz"
        } else {
            title = "视频遥控"
            imageName = "preview_light_nor"
        }
        previewButton = SweeperButton(title: title, fontSize: 9, image: UIImage.image(named: imageName))
        let previewTap = UITapGestureRecognizer.init(target: self, action: #selector(previewButtonDidClick))
        previewButton?.addGestureRecognizer(previewTap)
        if let button = previewButton {
            self.view.bringSubviewToFront(button)
        }
        if let previewButton = previewButton {
            buttonContainerStackView.addArrangedSubview(previewButton)
        }

        editButton = SweeperButton(title: "编辑地图", fontSize: 9, image: UIImage.image(named: "map_black_nor"))

        let editTap = UITapGestureRecognizer.init(target: self, action: #selector(editButtonDidClick))
        editButton?.addGestureRecognizer(editTap)
        if let editButton = editButton {
            buttonContainerStackView.addArrangedSubview(editButton)
        }

        baseStationButton = SweeperButton(title: "基站", fontSize: 9, image: UIImage.image(named: "sweeper_home"))

        let stationTap = UITapGestureRecognizer.init(target: self, action: #selector(baseStationButtonDidClick))
        baseStationButton?.addGestureRecognizer(stationTap)
        if let baseStationButton = baseStationButton {
            buttonContainerStackView.addArrangedSubview(baseStationButton)
        }

        moreButton = SweeperButton(title: "更多", fontSize: 9, image: UIImage.image(named: "star"))

        let moreButtonTap = UITapGestureRecognizer.init(target: self, action: #selector(moreButtonDidClick))
        moreButton?.addGestureRecognizer(moreButtonTap)
        if let moreButton = moreButton {
            buttonContainerStackView.addArrangedSubview(moreButton)
        }

        [previewButton, editButton, baseStationButton, moreButton].forEach { button in
            button?.snp.makeConstraints { make in
                make.width.equalTo(44)
                make.height.equalTo(47)
            }
        }

        /* buttonContainerStackView */
        view.addSubview(buttonContainerStackView)
        buttonContainerStackView.axis = .vertical
        buttonContainerStackView.alignment = .center
        buttonContainerStackView.spacing = 12
        buttonContainerStackView.snp.makeConstraints { make in
            make.width.equalTo(44)
            make.top.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }

        /* createMapButton */
        createMapContainer = SweeperCreateMapView()
        if let createMapContainer = createMapContainer {
            view.addSubview(createMapContainer)

            let goldenRatio: CGFloat = 0.382
            createMapContainer.snp.makeConstraints { make in
                make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2).offset(-(88 * goldenRatio))
                make.centerX.equalToSuperview()
                make.width.equalTo(230)
            }
        }
        createMapContainer?.isHidden = true

        /* chargeButton */
        chargeButton = SweeperButton(title: "返回基站", fontSize: 9, image: UIImage.image(named: "robot_charger"), offsetToTop: 5)
        addContraint(for: chargeButton, trailingToSuperView: -defaultButtonPadding)
        chargeButton.isHidden = true
        chargeButton.snp.makeConstraints { make in
            if let sweeperAlarmView = sweeperAlarmViewController {
                make.bottom.equalTo(sweeperAlarmView.view.snp.top).offset(-defaultButtonPadding / 2)
            } else {
                make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding)
            }
        }
        let chargeTap = UITapGestureRecognizer.init(target: self, action: #selector(rechargeButtonDidClick))
        chargeButton.addGestureRecognizer(chargeTap)

        parameterButton = SweeperButton(title: LocalizedString(key: sweeperCleanSweepAndMop), fontSize: 9, image: UIImage.image(named: "mode_general"), offsetToTop: 5)
        addContraint(for: parameterButton, trailingToSuperView: -defaultButtonPadding, bottomToSuperView: nil)
        parameterButton.snp.makeConstraints { (make) in
            make.bottom.equalTo(chargeButton.snp.bottom)
        }

        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        parameterButton.addGestureRecognizer(paramTap)

    }

    func setupOfflineView() {
        let offlineView = SweeperRobotOfflineView(frame: .zero)
        offlineView.delegate = self
        self.view.addSubview(offlineView)

        let goldenRatio: CGFloat = 0.382
        offlineView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2)
        }
        equipmentOfflineView = offlineView
        equipmentOfflineView?.isHidden = true
    }

    func updateNavigation() {
        if firstTimeUpdateNavigationTitle {
            navigationTitleView = SweeperTitleBatteryView(title: deviceDetail?.alias ?? "扫地机器人", stateText: "", power: 0, charge: false)
            navigationTitleView.snp.remakeConstraints { make in
                make.height.equalTo(44)
                make.width.equalTo(screenWidth - 150)
            }
            navigationItem.titleView = navigationTitleView
            firstTimeUpdateNavigationTitle = false
        }

        let stateText = state?.stateDescription ?? "故障中"
        let battery = state?.battery ?? 0
        let isCharging = state?.mainState == .charging
        navigationTitleView.setState(stateText: stateText, power: battery, charge: isCharging)
    }

    func updateEnvironmentView() {
        temperatureView.text = temperatureText
        humidityView.text = humidityText
    }

    func updateChargeButton() {
        chargeButton.isHidden = !shouldShowChargeButton
        if isRecharging {
            chargeButton.setTitle(title: "停止回充", buttonImage: UIImage.image(named: "robot_charge_stop"))
        } else {
            chargeButton.setTitle(title: "返回基站", buttonImage: UIImage.image(named: "robot_charger"))
        }
        if forbiddenRechargeAndClean {
            chargeButton.titleLabel.textColor = .lightGray3Color.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = false
        } else {
            chargeButton.titleLabel.textColor = .black.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = true
        }
    }

    func setupLoadingView() {
        view.addSubview(loadingView)
        loadingView.delegate = self
        loadingView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(0.764)
        }
    }

    func setupMapView() {
        let mapSize = sweeperControl?.mapSize ?? CGSize(width: defaultMapWidth, height: defaultMapHeight)
        mapView = SweeperHomeMapView(frame: .zero, mapSize: mapSize)
        mapView.backgroundColor = UIColor.clear
        view.addSubview(mapView)
        mapView.delegate = self
        mapView.sweeperIconMapView.delegate = self
        mapView.datasource = self
        mapView.isHidden = true

        mapView.snp.makeConstraints { make in
            make.top.trailing.leading.equalToSuperview()
            make.bottom.equalTo(sweepControlView.snp.top)
        }
        setupTapGesture()
    }

    func setupTapGesture() {
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(didTaped(recognizer:)))
        self.mapView.addGestureRecognizer(tapGesture)
    }

    func setupSweeperAlarmView() {
        let sweeperAlarmViewController = SweeperAlarmBannerViewController()
        sweeperAlarmViewController.window(from: .mainPage)
        sweeperAlarmViewController.sweeperControl = self.sweeperControl

        self.addChild(sweeperAlarmViewController)
        view.addSubview(sweeperAlarmViewController.view)
        sweeperAlarmViewController.view.snp.makeConstraints { make in
            make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding / 2)
            make.leading.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }
        self.sweeperAlarmViewController = sweeperAlarmViewController
    }

    @objc func didTaped(recognizer: UITapGestureRecognizer) {
        captureBubbleViewDismiss()
    }

    func setupEnvironmentView() {
        view.addSubview(environmentView)

        environmentView.snp.makeConstraints { make in
            make.height.equalTo(36)
            make.leading.top.equalToSuperview().offset(12)
        }
        environmentView.backgroundColor = .lightGray3Color.withAlphaComponent(0.1964)
        environmentView.layer.cornerRadius = 5

        [temperatureView, humidityView].forEach { label in
            environmentView.addSubview(label)

            label.backgroundColor = .clear
            label.textColor = .black.withAlphaComponent(0.6)
            label.textAlignment = .left
            label.font = .projectFont(ofSize: 10)
            label.snp.makeConstraints { make in
                make.height.equalTo(14)
                make.trailing.equalToSuperview().offset(-8)
                make.leading.equalToSuperview().offset(8)
            }
        }

        temperatureView.snp.makeConstraints { make in
            make.top.equalToSuperview().offset(4)
        }
        temperatureView.text = temperatureText

        humidityView.snp.makeConstraints { make in
            make.top.equalTo(temperatureView.snp.bottom)
        }
        humidityView.text = humidityText
    }

    func setupControlView() {
        addConstraint(forBottomView: sweepControlView, height: nil)
        sweepControlView.isHidden = true
        sweepControlViewHeightConstraint = NSLayoutConstraint(item: sweepControlView,
                                                             attribute: .height,
                                                             relatedBy: .equal,
                                                             toItem: nil,
                                                             attribute: .notAnAttribute,
                                                             multiplier: 1.0,
                                                             constant: 0)
        sweepControlViewHeightConstraint?.isActive = true

        // button clicked
        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        sweepControlView.parameterButton?.addGestureRecognizer(paramTap)

        let clearTap = UITapGestureRecognizer.init(target: self, action: #selector(clearAreaButtonDidClick))
        sweepControlView.clearAreaButton?.addGestureRecognizer(clearTap)

        let startTap = UITapGestureRecognizer.init(target: self, action: #selector(startButtonDidClick))
        sweepControlView.startButton.addGestureRecognizer(startTap)

        let stopTap = UITapGestureRecognizer.init(target: self, action: #selector(stopButtonDidClick))
        sweepControlView.stopButton.addGestureRecognizer(stopTap)

        let pauseTap = UITapGestureRecognizer.init(target: self, action: #selector(pasueButtonDidClick))
        sweepControlView.pauseButton.addGestureRecognizer(pauseTap)

    }

    func setupUpgradingView() {
        view.addSubview(sweeperBaseUpgradingView)
        sweeperBaseUpgradingView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingUpgradingView = false
    }

    func setupMechanicalOffView() {
        view.addSubview(sweeperMechanicalOffView)
        sweeperMechanicalOffView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingMechanicalView = false
        sweeperMechanicalOffView.delegate = self
    }

    func addConstraint(forBottomView bottomView: UIView?, height: CGFloat?) {
        guard let bottomView = bottomView else {
            return
        }
        bottomView.translatesAutoresizingMaskIntoConstraints = false

        view.addSubview(bottomView)

        // UI中设置的阴影radius为12，此处设置为8，才能与UI的效果一致。
        let shadowRadius: CGFloat = 8
        bottomView.layer.shadowOffset = .init(width: 0, height: 2)
        bottomView.layer.shadowRadius = shadowRadius
        bottomView.layer.shadowColor = UIColor.black.cgColor
        bottomView.layer.shadowOpacity = 0.16

        NSLayoutConstraint(item: bottomView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .width,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        if let height = height {
            NSLayoutConstraint(item: bottomView,
                               attribute: .height,
                               relatedBy: .equal,
                               toItem: nil,
                               attribute: .notAnAttribute,
                               multiplier: 1.0,
                               constant: height).isActive = true
        }

        NSLayoutConstraint(item: bottomView,
                           attribute: .bottom,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .bottom,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        NSLayoutConstraint(item: bottomView,
                           attribute: .centerX,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .centerX,
                           multiplier: 1.0,
                           constant: 0).isActive = true
    }

    func addContraint(for subView: UIView?, trailingToSuperView: CGFloat, topToSuperView: CGFloat? = nil, bottomToSuperView: CGFloat? = nil) {
        guard let subView = subView else {
            return
        }

        view.addSubview(subView)
        subView.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint(item: subView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 44).isActive = true
        NSLayoutConstraint(item: subView,
                           attribute: .height,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 47).isActive = true
        if let topToSuperView = topToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .top,
                               relatedBy: .equal,
                               toItem: view,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: topToSuperView).isActive = true
        }

        if let bottomToSuperView = bottomToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .bottom,
                               relatedBy: .equal,
                               toItem: bottomLayoutGuide,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: bottomToSuperView).isActive = true
        }

        NSLayoutConstraint(item: subView,
                           attribute: .trailing,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .trailing,
                           multiplier: 1.0,
                           constant: trailingToSuperView).isActive = true
    }
}

/// receive bitmap data
extension SweeperMainViewController: SweeperMapMediaPlayerListener {
    func mediaPlayerConnected(connectedSuccess: Bool) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if !connectedSuccess {
            dataLoadingStateChangeAction(loadingState: .failed)
        }
    }

    func dataLoadingStateChanged(loadingState: SweeperDataLoadingState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        dataLoadingStateChangeAction(loadingState: loadingState)
    }

    func mediaPlayerBitmapDataUpdate(dataType: MapMediaPlayerFrameFormat) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        /// 对扫地机地图正处于拖动或缩放时地图的刷新进行限制，避免卡顿的情况。
        guard !mapView.isOperation else {
            return
        }
        if dataType == .map {
            // 第一次收到I帧
            if sweeperControl?.hadFrame == true {
                stopWaveAnimation()
            }
            mapView.sweeperBitmapView.refreshBitmapImage()
            mapView.sweeperAreaView.refreshAreaView()
            if needRefreshMapViewInMediaPlayer {
                needRefreshMapViewInMediaPlayer = false
                mapView.refreshView()
            }
        }

        if sweeperControl?.hadFrame == true && dataType == .path {
            mapView.sweeperRouteView.refreshRouteView()
            // refresh equipment icon and charger pile location.
            mapView.sweeperIconMapView.refreshIconView()
        }
    }

    func mediaPlayerSignalling(mapID: String, type: SweeperConfigUpdateType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if type == .cleaningState {
            updateCleaningStateUI()
        } else if type == .cleaningMode || type == .cleanParam {
            updateCleaningModeUI()
        } else if type == .areaCleaning {
            mapView.updateCustomOrAutoMode()
            mapView.refreshAreaAndLabelView()
        } else if type == .globalCleaningConfig {
            // 修改全局清扫配置
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                cleanMethodMode = mode
                configurationView?.collectionView.reloadData()
            }
        } else {
            mapView.refreshView()
            mapView.refreshAreaAndLabelView()
        }
    }

    func mediaPlayerBasicStateDidChanged(preState: SweeperState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        basicStateChangeAction(showToast: true)
        sweeperAlarmViewController?.showAlarm()
        sweeperAlarmViewController?.showNotify()

        // 当前扫地机清扫结束时，若需要进入地图保存逻辑，则重新进入
        if !preState.cleanFinished && state?.cleanFinished == true && needEntrySaveMapLogicAfterBasicStateChanged {
            currentMapDidChanged(preMap: nil)
            saveMapLogic()
            needEntrySaveMapLogicAfterBasicStateChanged = false
        }
    }

    func mediaPlayerMapIDDidChanged(preMap: SweeperMap) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        currentMapDidChanged(preMap: preMap)

        /// 每次修改current map id 后， 地图的大小都会发生变化，故需要刷新初始地图的大小以适应屏幕
        mapView.restoreInitalMapView()
        mapView.shouldRefreshSize = true
        mapView.refreshView()
        mapView.updateCleanningModeAndSweepingState()
        mapView.updateCustomOrAutoMode()
        mapView.refreshAreaAndLabelView()
    }

    func mediaPlayerAlarm(type: SweeperAlarmType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        let alarm = SweeperAlarm(type: type)

        // 当前alarm需要在主页面显示、当基站升级、开关断开时不展示
        guard alarm.window.contains(.mainPage) && sweeperMechanicalOffView.isHidden && sweeperBaseUpgradingView.isHidden else {
            return
        }

        // 展示Toast
        if alarm.rank.contains(.toast),
           let message = alarm.toastTitle {
            ToastView.showWarningToast(title: message, existTime: nil, centerY: .low)
            return
        }

        // 展示Dialog，不展示只在基站展示的dialog
        if alarm.rank.contains(.dialog),
           !SweeperAlarm.baseDialogTypes.contains(type),
           let title = alarm.toastTitle {
            showAlertWith(title: title, message: alarm.toastContent, messageTextAlignment: .center, defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil, cancelButtonHandler: nil, defaultButtonHandler: nil)
            return
        }
    }
}

extension SweeperMainViewController: SweeperMapViewDataSource {
    func area(_ view: UIView, customCleanConfigurationIn areaID: Int) -> SweeperGlobalCleaningConfiguration? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaCleaningConfiguration
    }

    func area(_ view: UIView, infomationLayerMarkIn areaID: Int) -> String? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaLabel
    }

    func areaIDSet(_ in: UIView) -> [Int]? {
        return sweeperControl?.mapModel?.areaModel.areaIDs
    }

    func areaLabelLocation(_ view: UIView, areaID: Int) -> CGPoint? {
        return sweeperControl?.mapModel?.areaModel.areaLabelLocation[areaID]
    }

    func bitmapImage(_ view: UIView) -> CGImage? {
        return sweeperControl?.mapModel?.bitmapImage()
    }

    func bitmapOffset(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.offset
    }

    func bitmapSize(_ view: UIView) -> CGSize? {
        return sweeperControl?.mapModel?.bitmapSize
    }

    func areaData(_ view: UIView) -> [UInt8]? {
        return sweeperControl?.mapModel?.areaModel.areaData
    }

    func routeAllPointArray(_ view: UIView) -> [RoutePoint]? {
        return sweeperControl?.routeModel?.routePoints
    }

    func virtualWallIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.virtualWallModel?.wallIDs
    }

    func virutalWall(_ view: UIView, wallID: Int, isInEditMap: Bool) -> (CGPoint, CGPoint)? {
        return sweeperControl?.virtualWallModel?.couplePiontDictionary[wallID]
    }

    func forbiddenAreaIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.forbiddenAreaModel?.areaIDs
    }

    func forbiddenArea(_ view: UIView, areaID: Int, isInEditMap: Bool) -> RectangleArea? {
        return sweeperControl?.forbiddenAreaModel?.couplePiontDictionary[areaID]
    }

    func equipmentLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.routeModel?.equipmenLocation
    }

    func equipmentAngle(_ view: UIView) -> CGFloat? {
        return sweeperControl?.routeModel?.equipmenOritention
    }

    func chargePileLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.chargePileLocation
    }

    func barrierIDSet(_ view: UIView) -> [Int]? {
        if let keys = sweeperControl?.barriersModel?.barrierDictionary.keys {
            return Array(keys)
        } else {
            return nil
        }
    }

    func barrier(_ view: UIView, barrierModelIn barrierID: Int) -> SweeperBarrier? {
        return sweeperControl?.barriersModel?.barrierDictionary[barrierID]
    }

    func rectClean(_ view: UIView) -> (leftTopPoint: CGPoint, rightBottomPoint: CGPoint)? {
        if cleaningMode.leftTopPoint != .zero && cleaningMode.rightBottomPoint != .zero {
            return (cleaningMode.leftTopPoint, cleaningMode.rightBottomPoint)
        } else {
            return nil
        }
    }

    func mapScale(_ view: UIView) -> CGFloat? {
        return sweeperControl?.capability?.mapScale
    }
}

extension SweeperMainViewController: SweeperHomeMapViewDelegate {
    func hadMapFrame(_ view: SweeperHomeMapView) -> Bool? {
        return sweeperControl?.hadFrame
    }

    func areaSelected(_ view: SweeperHomeMapView) -> [Int]? {
        if cleaningModeType == .areaClean {
            return selectedLayerID
        } else {
            return nil
        }
    }

    func homeMapViewIsSetPreference(_ view: SweeperHomeMapView) -> Bool {
        return isSetPreference()
    }

    func homeMapViewIsSetSeq(_ view: SweeperHomeMapView) -> Bool {
        return isSetSweepSeq()
    }

    func layer(_ view: SweeperHomeMapView, layerSelectedSequence layerID: Int) -> Int? {
        if cleaningModeType == .areaClean, let orderID = selectedLayerID.firstIndex(of: layerID) {
            return orderID
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, layerCleaningOrder layerID: Int) -> Int? {
        if let order = sweeperControl?.mapModel?.areaModel.areaCleaningOrder,
           let orderID = order.firstIndex(of: layerID) {
            return orderID + 1
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, selectedLayer layerID: Int) {
        if let index = selectedLayerID.firstIndex(of: layerID) {
            selectedLayerID.remove(at: index)
        } else {
            selectedLayerID.append(layerID)
        }
        if cleaningModeType == .areaClean && !selectedLayerID.isEmpty {
            ToastView.showWarningToast(title: "已选择(selectedLayerID.count)个区域", existTime: nil, centerY: .low)
        }
        updateClearingAreaButton()
        mapView.refreshAreaAndLabelView()
    }
}

extension SweeperMainViewController {

    // 物体抓拍气泡展示
    private func captureBubbleViewShow(captureView: UIImageView, titleText: String, iconImage: UIImage, status: CaptureImageLoadingStatus, obstacleID: Int, thumbnail: UIImage? = nil) {
        sweepCaptureView.removeFromSuperview()
        captureBubbleViewLayout(captureView: captureView)
        sweepCaptureView.delegate = self

        // 更新障碍物抓拍气泡的展示
        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: thumbnail, obstacleID: obstacleID)

        // 更新障碍物抓拍是否有缩略图以及缩略图状态
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl?.barrierRecognitionEnabled ?? false, captureImageStatus: status)

        self.view.layoutIfNeeded()
        self.autoSuitPosition()
    }

    private func captureBubbleViewLayout(captureView: UIImageView) {
        self.mapView.addSubview(sweepCaptureView)
        sweepCaptureView.snp.remakeConstraints { make in
            make.centerX.equalTo(captureView.snp.centerX)
            make.bottom.equalTo(captureView.snp.top).offset(-12)
            make.width.equalTo(159)
            if sweeperControl?.barrierRecognitionEnabled ?? false {
                make.height.equalTo(128)
            } else {
                make.height.equalTo(40)
            }
        }
    }

    // 物体抓拍气泡隐藏
    private func captureBubbleViewDismiss() {
        sweepCaptureView.dismiss()
    }

    private func autoSuitPosition() {
        var offsetX: CGFloat = 0
        var offsetY: CGFloat = 0
        let maxXCoordinate = mapView.frame.width - sweepCaptureView.frame.width - 16
        if sweepCaptureView.frame.origin.x < 16 {
            offsetX = 16 - sweepCaptureView.frame.origin.x
        } else if sweepCaptureView.frame.origin.x > maxXCoordinate {
            offsetX = maxXCoordinate - sweepCaptureView.frame.origin.x
        }

        if sweepCaptureView.frame.origin.y < 16 {
            offsetY = 16 - sweepCaptureView.frame.origin.y
        }
        // 不用考虑底部超出边界，因为弹窗从顶部出现

        mapView.moveBy(x: offsetX, y: offsetY)
    }

    /// 刷新当前正在展示的气泡及其内容
    private func refreshBubbleView() {
        guard let sweeperControl = sweeperControl,
              let obstacleID = obstacleID,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              let iconImage = barrier.type.bigImage,
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            captureBubbleViewDismiss()
            return
        }
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
            return
        }

        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: .loading)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { [weak self] (status, image) in
            self?.sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: image, obstacleID: obstacleID)
            self?.sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: status)
        }
    }

}

extension SweeperMainViewController: SweeperMapManagerViewControllerDelegate {
    func mapManagerBeginSweep(_ controller: SweeperMapManagerViewController) {
        // 强制扫地机进入新建地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .autoClean)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    func mapManagerFastMap(_ controller: SweeperMapManagerViewController) {
        // 开始快速建图
        startFastMapAlert()
    }
}

extension SweeperMainViewController: SweeperCaptureBubbleViewDelegate {
    func captureNextButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.titleLabel.textColor = UIColor.black.withAlphaComponent(0.5)
        // 获取全部障碍物的详情页
        let sweepCaptureNextPageViewController = SweeperCaptureNextPageViewController(deviceID: deviceID, listType: listType)
        sweepCaptureNextPageViewController.delegate = self

        // 更新详情页跳转到具体哪个页面
        sweepCaptureNextPageViewController.obstacleID = captureView.obstacleID
        self.navigationController?.pushViewController(sweepCaptureNextPageViewController, animated: true)
    }

    func reloadButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.imageStatus = .loading
        let barrierID = captureView.obstacleID
        guard let fileID = sweeperControl?.barriersModel?.barrierDictionary[barrierID]?.fileID else {
            return captureView.imageStatus = .loadNoImage
        }

        SweeperDownloader.downloadObstacleImage(forDevice: deviceID, listType: listType, fileID: fileID) { status, image in
            captureView.imageStatus = status
            captureView.titleImageView.image = image
        }
    }

    func handleGestures(enable: Bool) {
        mapView.isGestureEnable = enable
    }
}

extension SweeperMainViewController: SweeperMainMapLoadingViewDelegate {
    func reloadButtonDidClick(_ UIView: SweeperMainMapLoadingView) {
        refreshMediaPlayerAndSweeperControl()
    }
}

extension SweeperMainViewController: SweeperIconMapViewDelegate {
    func didTapBaseStation(in view: SweeperIconMapView) {
        baseStationButtonDidClick()
    }

    func iconMap(_ view: SweeperIconMapView, transforToScreenPointFrom realPoint: CGPoint) -> CGPoint? {
        // 之前未调用
        return nil
    }

    func didTapObstacle(in view: UIImageView, obstacleID: Int) {

        guard let sweeperControl = sweeperControl,
              let iconImage = sweeperControl.barriersModel?.barrierDictionary[obstacleID]?.type.bigImage,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            return
        }
        self.obstacleID = obstacleID
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loadNoImage, obstacleID: obstacleID)
            return
        }

        self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loading, obstacleID: obstacleID)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { status, image in
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: status, obstacleID: obstacleID, thumbnail: image)
        }
    }
}

extension SweeperMainViewController: SweeperNewPasswordProtocol {
    func checkUnAuthenticated() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperModule.shared.requiredService?.checkUserInfo(deviceID: deviceID, listType: listType, completion: { [weak self] (success, errorCode) in
            ToastView.dismissLoadingToast()
            guard let self = self else {
                return
            }
            if success {
                self.goToPreview()
                return
            }

            if errorCode == TPSS_ASYNC_EC_TIMEOUT || errorCode == TPSS_COMM_EC_SYSTEM {
                /* 请求超时 */
                ToastView.showWarningToast(warningMessage: "网络错误")
                return
            }

            /* 设备锁定 */
            if errorCode == TPSS_COMM_EC_PREVIEW_LOCKED {
                self.showAlertWith(title: SharedResource.sharedString(key: sweeperPreviewLockedAlertTitle), defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil)
                return
            }

            /* 鉴权失败,弹出密码输入框 */
            self.presentInputPasswordVC(deviceID: self.deviceID, listType: self.listType)

        })
    }
}

extension SweeperMainViewController: SweeperVerifyPasswordProtocol {
    func verifySuccessHandler() {
        goToPreview()
    }
}

extension SweeperMainViewController: SweeperCaptureNextPageViewControllerDelegate {
    func ignoreButtonDidClick(sweeperCaptureNextPageViewController: SweeperCaptureNextPageViewController, barrierID: Int) {
        // 点击障碍物抓拍详情页的“忽略”所对应的障碍物Id
        guard let mapID = map?.currentMapID else {
             return
        }
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestIgnoreBarrier(device: deviceID, channel: channel, listType: listType, barrierID: "(barrierID)", mapID: mapID).always {
            ToastView.dismissLoadingToast()
        }.then { [weak self] (_) in
            ToastView.showWarningToast(warningMessage: "已忽略该物体")
            self?.sweepCaptureView.dismiss()
            self?.goBackToSweeperMainViewController()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperMechanicalOffViewDelegate {
    func refreshButtonDidClick(in: SweeperMechanicalOffView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        sweeperMechanicalOffView.refreshLoadingUI(connectedState: .loading)
        view.bringSubviewToFront(sweeperMechanicalOffView)
        SweeperService.getSweeperState(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType).then { [weak self] (state) in
            guard let state = state else {
                return
            }
            self?.showMechanicalOffView(switchOn: state.mechanicalSwitchOn)
        }
    }

    func showMechanicalOffView(switchOn: Bool) {
        // 若开关关闭
        if !switchOn {
            isShowingMechanicalView = true
            sweeperMechanicalOffView.refreshLoadingUI(connectedState: .off)
        } else {
            isShowingMechanicalView = false
        }
    }
}

extension SweeperMainViewController: SweeperMoreActionViewControllerDelegate {
    func cleanWholeHouse(in vc: SweeperMoreActionViewController) {
        showSweepTipsAlert()
    }
}

extension SweeperMainViewController: SweeperFastMapSheetDelegate {
    func startFastMap(view: SweeperFastMapSheet) {
        startFastMapAlert()
    }
}

extension String {
    func separatedBySemiColon(isAutoFill: Bool = true) -> (String, String?) {
        let seperator = self.contains(":") ? ":" : "："
        let separatedTexts: [String] = self.components(separatedBy: seperator)
        if !isAutoFill && separatedTexts.count == 1 {
            return (separatedTexts[0], nil)
        } else {
            return (separatedTexts.count >= 1 ? separatedTexts[0] : "", separatedTexts.count >= 2 ? separatedTexts[1] : "")
        }
    }
}
//
//  OnlineDeviceListMasterViewController.swift
//  SurveillanceHome
//
//  Created by Li Linfeng on 2019/12/9.
//  Copyright © 2019 tplink. All rights reserved.
//

import UIKit
import SurveillanceHomeBase
import SharedResource
import TPFoundation
import DeviceDetailModule
import NetService

private var pageIndexAssociatedObjectHandle: UInt8 = 0

final class OnlineDeviceListMasterViewController: BaseViewController {
    @IBOutlet private weak var groupCollectionView: UICollectionView!
    @IBOutlet private weak var groupToolbarShadowView: UIView!
    @IBOutlet private weak var groupToolbarContainer: UIView!
    @IBOutlet private weak var groupToolbarDropMenuButton: UIButton!
    @IBOutlet private weak var recentPreviewView: RecentPreviewView!
    @IBOutlet private weak var containerViewBottom2SuperViewBottomConstraint: NSLayoutConstraint!
    @IBOutlet private weak var containerViewTop2TopLayoutGuideBottomConstraint: NSLayoutConstraint!

    override var navigationBarTraits: [NavigationBarTrait] {
        return NavigationBarTrait.noSeparator
    }

    private var deviceGroups: [TPSSDeviceGroup] = []
    private var currentGroupIndex: Int = 0

    private var newCreateGroupName = ""

    private var pageController: UIPageViewController!
    private var deviceListVCCacheDictionary = [TPSSDeviceGroupID: OnlineDeviceListViewController]()
    private var transitionVCForPageController = UIViewController()
    lazy private var loginCacheVC = DeviceListLoginViewController.create()

    private var firstAppear = true
    private var shouldRecreate: Bool = false

    /// for routers' entry
    private var isLoginBefore = false

    var sdCardStatusShowed: SDCardStatusShowed = .none
    var diskStatusShowed: SDCardStatusShowed = .none

    // camera display
    private var shouldShowCameraDisplayNoActiveChannelAlert = false
    private var addChannelCameraDisplay: TPSSDeviceForDeviceList?

    // navigation
    private lazy var moreToolBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(moreToolsButtonClicked(_:)))
    }()

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_add_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(addDeviceButtonClicked(_:)))
    }()

    // MARK: guides and overlays
    private weak var addDeviceGuideView: GuidePresentationView?
    private weak var moreToolsPopoverView: GuidePresentationView?

    private lazy var groupPresenter = GroupListPresentationManager()
    private var presentedGroupList: GroupListViewController? {
        return presentedViewController as? GroupListViewController
    }

    private var currentList: OnlineDeviceListViewController {
        if let viewControllers = pageController.viewControllers, let firstViewController = viewControllers.first as? OnlineDeviceListViewController {
            return firstViewController
        }
        return OnlineDeviceListViewController()
    }

    private var isCloudLogin: Bool {
        return DeviceListModule.shared.requiredService?.isCloudLogin ?? false
    }

    private var isReordering = false                // 是否正在处于排序模式
    private var shouldToggleGroupModeAfterGetList = false   // 是否需要在获取列表结束后切换防护模式，仅在列表还未获取完时触发防护模式切换使用

    private var isShowing: Bool {
        return isShowing(ignorePresentedClasses: [UIAlertController.classForCoder()])
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        setupView()

        NotificationCenter.default.addObserver(self, selector: #selector(handleShowCameraDisplayNoActiveChannelAlertNotification(_:)), name: .ShowCameraDisplayNoActiveChannelAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleShowStorageDetectAlertNotification(_:)), name: .ShowStorageDetectAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListInvalidated), name: .DeviceListInvalidated, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListUpdated), name: .DeviceListUpdated, object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderBegined(_:)),
                                               name: .DeviceListReorderBegined,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderEnded(_:)),
                                               name: .DeviceListReorderEnded,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupAndDeviceList(_:)),
                                               name: .UpdateGroupAndDeviceListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: DeviceListNetworkObserver.localDeviceRefreshed,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupList(_:)),
                                               name: .UpdateGroupListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: .unbindDiscoveryFinished,
                                               object: nil)

        _ = DeviceListModule.shared.requiredService?.addEntrustObserver(observeTypes: [.entrustmentStop, .entrustmentExitByTrustee], { (_, _) in
            DeviceListManager.shared.updateDeviceList(of: DeviceListManager.shared.defaultGroupID).always {
                self.currentList.reload()
            }
        })
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        showGroupAndNavigationButton(true)
        if !isCloudLogin {
            showEmpty()
        } else if firstAppear {
            firstAppear = false
            restore()
        } else if shouldRecreate {
            shouldRecreate = false
            reload()
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        checkUpdateIfNeeded()

        if isCloudLogin {
            showPopoverGuideIfNeeded()
        }

        if shouldShowCameraDisplayNoActiveChannelAlert {
            shouldShowCameraDisplayNoActiveChannelAlert = false
            showCameraDisplayNoActiveChannelAlert()
        }
        updateGroupShadow()
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)

        dismissPresentedViews()
    }

    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let vc = segue.destination as? UIPageViewController {
            pageController = vc
            pageController.dataSource = self
            pageController.delegate = self
        }
    }

    private func refreshAfterGroupUpdated() {
        guard !isReordering else {
            return
        }

        guard isShowing else {
            // 如果分组刷新完，此时页面不是正在显示，则不进行页面刷新，仅记录状态，等回到本页面才统一进行刷新。
            // 需要注意通过记录状态后续回到页面才处理的逻辑，要与本方法后续处理逻辑要保持一致
            shouldRecreate = true
            return
        }

        reload()
    }

    private func showEmpty() {
        deviceGroups = []
        currentGroupIndex = -1

        showGroupAndNavigationButton(false)

        let emptyVC: UIViewController?
        // 有发现出来的/已绑定到局域网的设备时显示带登陆按钮的设备列表；没有则显示普通的登陆提示页
        if DeviceListManager.shared.unbindDetailDeviceList().count > 0 {
            emptyVC = createUnloginPage()
        } else {
            emptyVC = loginCacheVC
        }
        if let emptyVC = emptyVC {
            pageController.setViewControllers([emptyVC], direction: .forward, animated: false, completion: nil)
        }
        groupCollectionView.reloadData()
    }

    private func showGroupAndNavigationButton(_ shouldShow: Bool) {
        if shouldShow {
            navigationItem.leftBarButtonItem = moreToolBarButtonItem
            groupToolbarDropMenuButton.isHidden = false
        } else {
            navigationItem.leftBarButtonItem = nil
            groupToolbarDropMenuButton.isHidden = true
        }
    }

    private func restore() {
        deviceGroups = DeviceListManager.shared.groupList

        loadGroup(with: DeviceListManager.shared.lastSelectedGroupID)
    }

    private func reload(with preferredGroupID: String? = nil) {
        let oldGroupID = preferredGroupID ?? DeviceListManager.shared.lastSelectedGroupID
        deviceGroups = DeviceListManager.shared.groupList
        presentedGroupList?.groups = deviceGroups

        loadGroup(with: oldGroupID)
    }

    private func loadGroup(with groupID: String) {
        let currentGroup = DeviceListManager.shared.group(of: groupID) ?? DeviceListManager.shared.defaultGroup

        guard let groupIndex = deviceGroups.firstIndex(where: { $0.groupID == currentGroup.groupID }) else {
            return
        }

        currentGroupIndex = groupIndex

        presentedGroupList?.currentGroupID = currentGroup.groupID
        presentedGroupList?.reload()

        commonLoad()
    }

    private func commonLoad(animated: Bool = false, recreate: Bool = true) {
        groupCollectionView.reloadData()

        guard currentGroupIndex >= 0 else {
            return
        }

        groupCollectionView.scrollToItem(at: IndexPath(item: currentGroupIndex, section: 0), at: .right, animated: false)
        updateGroupShadow()

        if recreate, let vc = createPage(for: currentGroupIndex) {
            pageController.setViewControllers([vc], direction: .forward, animated: false, completion: nil)
        }

        storeGroupParameter()
    }

    private func updateGroupShadow() {
        groupToolbarShadowView.isHidden = groupCollectionView.bounds.maxX >= (groupCollectionView.contentSize.width - 1)
    }

    private func refreshAllDeviceLists() {
        if let viewController = pageController.viewControllers {
            viewController.forEach {
                if let vc = $0 as? OnlineDeviceListViewController {
                    vc.reload()
                }
            }
        }
    }

    private func createPage(for index: Int) -> OnlineDeviceListViewController? {
        let group = deviceGroups[index]
        guard let vc = createPage(for: group.groupID as TPSSDeviceGroupID) else {
            return nil
        }
        objc_setAssociatedObject(vc, &pageIndexAssociatedObjectHandle, index, .OBJC_ASSOCIATION_COPY_NONATOMIC)
        vc.realGroup = deviceGroups[index]
        return vc
    }

    private func createUnloginPage() -> OnlineDeviceListViewController? {
        return createPage(for: "unlogin page")
    }

    private func createPage(for key: TPSSDeviceGroupID) -> OnlineDeviceListViewController? {
        let vc: OnlineDeviceListViewController?
        if let item = deviceListVCCacheDictionary[key] {
            vc = item
        } else {
            vc = OnlineDeviceListViewController.create()
            deviceListVCCacheDictionary[key] = vc
        }
        return vc
    }
}

extension OnlineDeviceListMasterViewController: DeviceListUnwindDestination {}

// MARK: Popover handler
extension OnlineDeviceListMasterViewController {
    private func updateMenu() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let networkAvailable = NetworkManager.shared.isConnected
        let isInHomeMode = deviceGroups[currentGroupIndex].activeMode != .goOut
        let isBigCardMode = deviceGroups[currentGroupIndex].displayMode != .smallCard
        let homeModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_home_active") : DeviceListModule.image(named: "devicelist_home_disabled")
        let outModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_out_active") : DeviceListModule.image(named: "devicelist_out_disabled")
        DeviceGroupMenuItem.alarmMode.image = (isInHomeMode ? homeModeImage : outModeImage)?.withRenderingMode(.alwaysOriginal)
        DeviceGroupMenuItem.alarmMode.enabled = networkAvailable
        DeviceGroupMenuItem.alarmMode.title = isInHomeMode ? LocalizedString(key: deviceListModeHome) : LocalizedString(key: deviceListModeOut)
        DeviceGroupMenuItem.alarmMode.subtitle = isInHomeMode ? LocalizedString(key: deviceListSwitchModeToOut) : LocalizedString(key: deviceListSwitchModeToHome)
        DeviceGroupMenuItem.viewMode.title = isBigCardMode ? LocalizedString(key: deviceListViewGrid) : LocalizedString(key: deviceListViewList)
        DeviceGroupMenuItem.viewMode.subtitle = isBigCardMode ? LocalizedString(key: deviceListSwitchViewToList) : LocalizedString(key: deviceListSwitchViewToGrid)
        DeviceGroupMenuItem.viewMode.image = isBigCardMode ?  DeviceListModule.image(named: "devicelist_grid")?.withRenderingMode(.alwaysOriginal) : DeviceListModule.image(named: "devicelist_list")?.withRenderingMode(.alwaysOriginal)
    }

    private func handleDeviceGroupMenu(item: DeviceGroupMenuView.Item) {
        switch item {
        case .alarmMode:
            toggleGroupMode()
        case .search:
            navigateToSearch()
        case .viewMode:
            toggleDisplayMode()
        }
    }

    private func toggleGroupMode() {
        dismissPresentedViews()

        let deviceListUpdateStatus = DeviceListManager.shared.deviceListUpdateStatus
        if !deviceListUpdateStatus.cloudUpdateNecessaryInfoFinished {
            // 列表必要信息没获取到，此时若需要改变防护模式，就先请求获取数据并且loading，等所有信息获取完处理，避免数据不完整导致处理出错
            if !deviceListUpdateStatus.isUpdatingList {
                DeviceListManager.shared.updateGroupAndDeviceList()
            }
            shouldToggleGroupModeAfterGetList = true
            ToastView.showLoadingToast(cirleWithMessage: nil)
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.activeMode
        let newMode = group.activeMode == .goOut ? TPSSDeviceGroupMode.atHome : .goOut
        group.activeMode = newMode
        ToastView.showLoadingToast(cirleWithMessage: nil)
        DeviceListManager.shared.changeActiveMode(with: deviceGroups[currentGroupIndex]).then { () in
            self.currentList.reload()
            self.currentList.showToastForActiveMode(newMode)
        }.catch { (_) in
            group.activeMode = originalMode
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func toggleDisplayMode() {
        dismissPresentedViews()

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.displayMode
        let newMode = originalMode == .bigCard ? DeviceUIDisplayType.smallCard : .bigCard

        DeviceListManager.shared.changeDisplayMode(for: group.groupID, with: newMode)

        for section in 0..<currentList.collectionView.numberOfSections {
            for item in 0..<currentList.collectionView.numberOfItems(inSection: section) {
                if newMode == .smallCard {
                    currentList.fold(at: IndexPath(row: item, section: section))
                } else {
                    currentList.unfold(at: IndexPath(row: item, section: section))
                }
            }
        }

        currentList.reload()
    }

    private func navigateToSearch() {
        dismissPresentedViews()
        let allDevices = DeviceListManager.shared.allDetailDevices
        let allGroups = DeviceListManager.shared.groupList
        let vc = RemoteDeviceListSearchViewController(devices: allDevices, groups: allGroups)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }
}

extension OnlineDeviceListMasterViewController {
    // MARK: Popover
    private func showPopoverGuideIfNeeded() {
        // add device popover
        if UserDefaults.standard.object(forKey: deviceListLaunchKey) == nil {
            showAddDevicePopover()
            UserDefaults.standard.set(true, forKey: deviceListLaunchKey)
        }
    }

    private func showAddDevicePopover() {
        if !isShowing() {
            /* 如果界面切换了不要加载 */
            return
        }
        if let source = (navigationItem.rightBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            navigationController?.navigationBar.layoutIfNeeded()
            dismissPresentedViews()
            addDeviceGuideView = presentGuideWith(viewToPresent: TutorialGuideView.addDevice, size: TutorialGuideView.addDevice.frame.size, source: source, clickThrough: true)
            addDeviceGuideView?.delegate = self
        }
    }
}

extension OnlineDeviceListMasterViewController: GuidePresentationViewDelegate {
    func guidePresentationViewDidDismiss(_ view: GuidePresentationView) {
        if view == moreToolsPopoverView {
            navigationItem.leftBarButtonItem?.tintColor = UIColor(white: 0, alpha: 0.8)
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        }
    }
}

// MARK: - util
extension OnlineDeviceListMasterViewController {
    private func storeGroupParameter() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        DeviceListManager.shared.updateLastSelectGroupID(deviceGroups[currentGroupIndex].groupID)
    }
}

extension OnlineDeviceListMasterViewController {

    private func presentUpgradeInfo(appVersionInfo: AppUpgradeModuleBaseUpgradeInfo) {
        let alertViewController = DeviceListUpgradeAlertController(versionInfo: appVersionInfo)
        present(alertViewController, animated: true, completion: nil)
    }

    private func checkUpdateIfNeeded() {
        let requiredService = DeviceListModule.shared.requiredService
        guard requiredService?.shouldShowNewAppVersion() ?? false else {
            return
        }

        // 仅跳转至需要更新的包中（若对应版本的升级包needNotify为false，而另外版本的needNotify为true，会跳转至另一版本）
        if TPAppUtils.isTestFlightBeta() {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, appVersionInfo.needNotify, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        } else {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo, appVersionInfo.needNotify {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        }

    }
}

extension OnlineDeviceListMasterViewController: DeviceListSearchViewControllerDelegate {
    func navigateToGroup(group: TPSSDeviceGroup) {
        navigationController?.popViewController(animated: true)
        DispatchQueue.main.async {
            self.loadGroup(with: group.groupID)
        }
    }

    func navigateToSyncPreviewViewController(device: DeviceDetail) {
        goToSyncPreview(ipc: device, listType: device.listType)
    }

    func navigateToPreviewViewController(device: DeviceDetail, channel: TPSSChannelInfo?) {
        if device.deviceType == .smartLock {
            DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
            return
        }
        goToPreview(device: device, channel: channel)
    }

    func navigateToBatteryDoorbellViewController(device: DeviceDetail, fromNVR nvr: (deviceID: TPSSDeviceIdentifier, channel: UInt)?) {
        DeviceListModule.shared.requiredService?.navigateToBatteryDoorbellViewController(for: device.identifier, group: DeviceListManager.shared.defaultGroupID, listType: device.listType, navigator: navigationController, from: nvr?.deviceID, channelInNVR: nvr?.channel.intValue)
    }

    func navigateToNVRViewController(nvr: DeviceDetail) {
        var groupId = DeviceListManager.shared.defaultGroup.groupID
        if currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex {
            groupId  = deviceGroups[currentGroupIndex].groupID
        }
        goToNVR(nvr: nvr, groupID: groupId)
    }

    func navigateToSolarControllerManagerViewController(device: DeviceDetail) {
        goToSolarController(solarController: device)
    }

    func navigateToRouterManagerViewController(device: DeviceDetail) {
        goToRouter(device: device)
    }

    func navigateToSmartLockViewController(device: DeviceDetail) {
        DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
    }
}

// MARK: Navigation
extension OnlineDeviceListMasterViewController: PreviewControllerEntrance {
    func goToPreview(device: DeviceDetail, channel: TPSSChannelInfo?) {
        goToPreview(deviceID: device.identifier, channelID: channel?.channelId.intValue ?? -1, listType: device.listType)
    }

    func goToNVR(nvr: DeviceDetail, groupID: String? = nil) {
        let vc = NVRTabViewController()
        vc.cloudIdentifier = nvr.cloudDeviceID
        vc.deviceIdentifier = nvr.identifier
        vc.listType = nvr.listType
        vc.groupId = groupID
        navigationController?.pushViewController(vc, animated: true)
    }

    func goToSolarController(solarController: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToSolarControllerManagerViewController(deviceID: solarController.identifier, listType: solarController.listType, navigator: navigationController)
    }

    func goToRouter(device: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToRouterDefault(mac: device.mac, listType: device.listType, isOnline: device.online, navigator: navigationController)
    }
}

// MARK: Actions
extension OnlineDeviceListMasterViewController {
    private func dismissPresentedViews() {
        addDeviceGuideView?.dismiss()
        moreToolsPopoverView?.dismiss()

        presentedGroupList?.dismiss(animated: true, completion: nil)

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }

    @IBAction private func addDeviceButtonClicked(_ sender: Any) {
        guard isCloudLogin else {
            showAlertWith(title: LocalizedString(key: deviceListNotLogin), defaultButtonTitle: LocalizedString(key: deviceListLogin), defaultButtonHandler: { (_) in
                DeviceListModule.shared.requiredService?.navigateToLoginViewController(navigator: self.navigationController)
            })
            return
        }
        dismissPresentedViews()

        DeviceListModule.shared.requiredService?.presentDeviceAddViewController(viewController: self, listType: listType)
    }

    @IBAction private func moreToolsButtonClicked(_ sender: Any) {
        guard isCloudLogin else { return }

        if moreToolsPopoverView != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let size = CGSize(width: 212, height: 16 + DeviceGroupMenuView.Item.allCases.count * 44)
        let menuView = DeviceGroupMenuView(frame: CGRect(origin: .zero, size: size))
        menuView.action = handleDeviceGroupMenu

        dismissPresentedViews()

        updateMenu()

        if let source = (navigationItem.leftBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
            menuView.configurePopoverShadow(cornerRadius: 8)
            moreToolsPopoverView = presentGuideWith(viewToPresent: menuView, size: size, backgroundColor: .clear, source: source, offset: CGPoint(x: -12, y: 4))
            moreToolsPopoverView?.delegate = self
        }
        navigationItem.leftBarButtonItem?.tintColor = .theme1
    }

    @IBAction private func groupMenuToggled(_ sender: UIButton) {
        guard isCloudLogin else { return }

        if presentedViewController != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_up_small_normal"), for: .normal)

        let groups = DeviceListManager.shared.groupList
        guard let vc = GroupListViewController.create() else {
            return
        }
        let height = CGFloat(groups.count) * 52 + 72
        vc.preferredContentSize = CGSize(width: UIScreen.main.bounds.width, height: height)
        vc.modalPresentationStyle = .custom
        vc.transitioningDelegate = groupPresenter
        vc.groups = groups
        vc.currentGroupID = deviceGroups[currentGroupIndex].groupID
        vc.delegate = self
        present(vc, animated: true, completion: nil)
    }

    @IBAction private func recentPreviewClicked(_ sender: Any) {
        // 不会用到此按钮，但暂时保留
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDataSource {
    private func groupInformation(at index: Int) -> (String, Bool) {
        if deviceGroups.isEmpty { return (LocalizedString(key: deviceListMyDevice), true) }
        return (deviceGroups[index].groupName, index == currentGroupIndex)
    }

    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }

    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return max(1, deviceGroups.count)
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        return collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)
    }
}

extension OnlineDeviceListMasterViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        updateGroupShadow()
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDelegate {
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        if deviceGroups.isEmpty { return }
        dismissPresentedViews()
        loadGroup(with: deviceGroups[indexPath.item].groupID)
    }
}

extension OnlineDeviceListMasterViewController: DeviceGroupNameLayoutDelegate {
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, groupForItemAt indexPath: IndexPath) -> (name: String, selected: Bool) {
        return groupInformation(at: indexPath.item)
    }
}

// MARK: Page Management
extension OnlineDeviceListMasterViewController: UIPageViewControllerDataSource {
    func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex > 0 && currentGroupIndex < deviceGroups.count else { return nil }
        return createPage(for: currentGroupIndex - 1)
    }

    func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex >= 0 && currentGroupIndex < deviceGroups.count - 1 else { return nil }
        return createPage(for: currentGroupIndex + 1)
    }
}

extension OnlineDeviceListMasterViewController: UIPageViewControllerDelegate {
    func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
        if completed {
            if let viewControllers = pageViewController.viewControllers, let firtViewController = viewControllers.first {
                if let currentGroupIndex = objc_getAssociatedObject(firtViewController, &pageIndexAssociatedObjectHandle) as? Int {
                    self.currentGroupIndex = currentGroupIndex
                    commonLoad(animated: true, recreate: false)
                }
            }
        }
    }
}

// MARK: Group Management
extension OnlineDeviceListMasterViewController: GroupListViewControllerDelegate {
    func groupListViewController(_ groupListViewController: GroupListViewController, canMoveGroupTo destinationIndex: Int) -> Bool {
        guard deviceGroups.count > destinationIndex else {
            return false
        }
        let group = deviceGroups[destinationIndex]
        return !group.isDefaultGroup
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didMoveGroupAt sourceIndex: Int, to destinationIndex: Int) {
        // check if current group index has changed
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let originalGroup = deviceGroups[currentGroupIndex]
        deviceGroups.swapAt(sourceIndex, destinationIndex)
        if let newIndex = deviceGroups.firstIndex(of: originalGroup), currentGroupIndex != newIndex {
            currentGroupIndex = newIndex
        }
        // always invalidate page controller cache
        pageController.setViewControllers([currentList], direction: .forward, animated: false, completion: nil)
        groupCollectionView.moveItem(at: IndexPath(item: sourceIndex, section: 0), to: IndexPath(item: destinationIndex, section: 0))
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didSelectGroupAt index: Int) {
        dismissPresentedViews()
        loadGroup(with: deviceGroups[index].groupID)
    }

    func groupListViewControllerDidSelectCreatingNewGroup(_ groupListViewController: GroupListViewController) {
        dismissPresentedViews()
        guard let vc = CommonNameInputViewController.create() else {
            return
        }
        vc.navigationTitle = LocalizedString(key: deviceListSetGroupNameTitle)
        vc.doneButtonTitle = LocalizedString(key: commonNextStep)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didRequestEditingGroupAt index: Int) {
        dismissPresentedViews()
        guard let vc = GroupSettingViewController.create() else {
            return
        }
        vc.group = deviceGroups[index]
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewControllerDidDismiss(_ groupListViewController: GroupListViewController) {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
        _ = DeviceListManager.shared.updateGroupOrder(newGroup: deviceGroups)
    }
}

extension OnlineDeviceListMasterViewController: CommonNameInputViewControllerDelegate {
    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didCancelWith text: String) {
        navigationController?.popViewController(animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didFinishWith text: String) {
        guard deviceGroups.count > 0 else {
            navigationController?.popToViewController(self, animated: true)
            return
        }
        newCreateGroupName = text
        let vc = DeviceSelectionViewController(entry: .groupAddIndependent, group: DeviceListManager.shared.defaultGroupID, canProceedWithNoSelection: true)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, errorMessageFor text: String) -> (allowed: Bool, message: String?) {
        let error = TPSSDeviceListValidate.validateDeviceGroupName(text)
        if error != nil {
            return (true, error?.message)
        }

        if DeviceListManager.shared.groupList.contains(where: { $0.groupName == text }) {
            return (true, LocalizedString(key: deviceListNameExists))
        }
        return (true, nil)
    }

    func placeholderForNameInputViewController(_ nameInputViewController: CommonNameInputViewController) -> String? {
        return SharedResource.sharedString(key: shareStringLengthConstraint)
    }
}

extension OnlineDeviceListMasterViewController {
    @objc func handleShowCameraDisplayNoActiveChannelAlertNotification(_ noti: NSNotification) {
        if let (device, listType) = noti.object as? (DeviceDetail, TPSSDeviceListType), listType == .remote {
            shouldShowCameraDisplayNoActiveChannelAlert = true
            addChannelCameraDisplay = DeviceListManager.shared.device(with: device.identifier)
        }
    }

    @objc func handleShowStorageDetectAlertNotification(_ noti: NSNotification) {
        diskStatusShowed = .none
        sdCardStatusShowed = .none
    }

    private func showCameraDisplayNoActiveChannelAlert() {
        showAlertWith(title: LocalizedString(key: deviceAddCameraDisplayNoActiveChannelsTitle), defaultButtonTitle: LocalizedString(key: deviceAddAddNext), cancelButtonTitle: LocalizedString(key: commonNotNow), cancelButtonHandler: nil) { (_) in
            if let cameraDisplay = self.addChannelCameraDisplay {
                DeviceListModule.shared.requiredService?.navigateToCameraDisplayDiscoverViewController(deviceID: cameraDisplay.identifier, discoverType: .cameraDisplay, listType: self.listType, navigator: self.navigationController)
                // 需要在中间插一个ViewController
                let vc = NVRTabViewController()
                vc.cloudIdentifier = cameraDisplay.cloudDeviceId
                vc.deviceIdentifier = cameraDisplay.identifier
                vc.listType = .remote
                vc.hidesBottomBarWhenPushed = true
                if var tmpViewControllers = self.tpNavigationController?.viewControllers {
                    tmpViewControllers.insert(vc, at: tmpViewControllers.count - 1)
                    self.tpNavigationController?.setViewControllers(tmpViewControllers, animated: true)
                }
            }
        }
    }
}

extension OnlineDeviceListMasterViewController: DeviceSDCardStatusChecker {
    var listType: TPSSDeviceListType { return .remote }

    func formatProcessDidFinish() {
        currentList.reload()
    }
}

extension OnlineDeviceListMasterViewController: DeviceSelectionViewControllerDelegate {
    func deviceSelectionViewController(_ deviceSelectionViewController: DeviceSelectionViewController, didPressRightBarButtonItemWithDeviceChannels selectedDeviceChannels: [DeviceDetail: [ChannelId]]) {
        switch deviceSelectionViewController.entryType {
        case .groupAddIndependent:
            ToastView.showLoadingToast(cirleWithMessage: nil)

            let targetDeviceChannels = DeviceSelectionViewController.covertDeviceChannel(selectedDeviceChannels)
            DeviceListManager.shared.createGroup(name: newCreateGroupName, deviceChannelMap: targetDeviceChannels).always {
                ToastView.dismissLoadingToast()
            }.then { (groupID) in
                self.navigationController?.popToViewController(self, animated: true)
                self.reload(with: groupID)
            }.catch { (error) in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }
        default:
            break
        }
    }
}

// MARK: - notification
extension OnlineDeviceListMasterViewController {
    @objc private func handleDeviceListInvalidated() {
        shouldRecreate = true
        deviceListVCCacheDictionary.removeAll()
    }

    @objc private func handleDeviceListUpdated() {
        showUpdateAlertIfAny()
    }

    @objc private func handleReorderBegined(_ notification: Notification) {
        enterReorderMode()
    }

    @objc private func handleReorderEnded(_ notification: Notification) {
        exitReorderMode()
    }

    @objc private func handleUpdateGroupAndDeviceList(_ notification: Notification) {
        if isCloudLogin {
            handleGroupModeToggleAfterGetList(notification)
        } else if isShowing {
            // 处理非登录场景

            // 仅页面正在显示才处理数据获取结果更新页面状态，否则等viewWillAppear再处理。避免正在获取列表
            // 时切换到其它页面，列表获取有结果后触发本逻辑使得子VC触发viewWillAppear，后续真正展示页面时
            // 就不再触发viewWillAppear导致数据异常
            showEmpty()
        }
    }

    @objc private func handleLocalDeviceRefreshed(_ notification: Notification) {
        if !isCloudLogin && isShowing {
            // 非登录且页面正在显示时才需要处理因网络状态变化重新发现完的通知，因为此时可能需要在有/无设备的页面之间切换。
            // 如果页面没有在显示则不需要处理，因为viewWillAppear会触发该逻辑
            showEmpty()
        }
    }

    @objc private func handleUpdateGroupList(_ notification: Notification) {
        if let dic = notification.object as? [String: Any],
           let error = dic[DeviceListManager.notificationKeyError] as? Error {
            ToastView.showWarningToast(title: error.localizedDescription, existTime: nil, centerY: .lowest)
            return
        }
        // 失败也更新，此时显示默认分组
        refreshAfterGroupUpdated()
    }

    private func handleGroupModeToggleAfterGetList(_ notification: Notification) {
        let finishHandler: (() -> Void) = {
            if self.shouldToggleGroupModeAfterGetList {
                ToastView.dismissLoadingToast()
                self.shouldToggleGroupModeAfterGetList = false
                self.toggleGroupMode()
            }
        }

        guard let dic = notification.object as? [String: Any],
              let status = dic[DeviceListManager.notificationKeyListUpdateStatus] as? DeviceListUpdateStatus else {
            finishHandler()
            return
        }

        if status.cloudUpdateNecessaryInfoFinished {
            finishHandler()
        }
    }
}

extension OnlineDeviceListMasterViewController: Storyboarded {
    static var storyboardName: String { return "DeviceList" }
    static var storyboardBundle: Bundle? { return Bundle.deviceListModuelBundle }
}

extension Notification.Name {
    static var DeviceListUpdated: Notification.Name { return Notification.Name("DeviceListUpdated") }
}

// MARK: - setup
extension OnlineDeviceListMasterViewController {
    private func setupView() {
        setupBarButtonItems()
        setupButtons()
    }

    private func setupBarButtonItems() {
        navigationItem.leftBarButtonItem = moreToolBarButtonItem
        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
    }

    private func setupButtons() {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }
}

// MARK: - reorder
extension OnlineDeviceListMasterViewController {
    // 本vc不会主动进入排序模式，而是依赖于OnlineDeviceListViewController的通知
    private func enterReorderMode() {
        isReordering = true
        tabBarController?.tabBar.isUserInteractionEnabled = false
        groupToolbarContainer.isUserInteractionEnabled = false

        pageController.scrollEnable = false

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
    }

    private func showUpdateAlertIfAny() {
        if DeviceListManager.shared.allDetailDevices.contains(where: {(DeviceListModule.shared.requiredService?.onboardingTypeFromQRCode(qrCode: $0.qrCode) ?? 0) == TPSS_EC_GENERAL} ) || DeviceListManager.shared.hasUnsupportedDevice {
            // 二维码获取不支持的设备或者读取设备列表中有不支持的设备时，弹出升级提示
            let lastVersion: (isShow: Bool, versionCode: Int) = DeviceListModule.shared.requiredService?.checkShowUpdateAlert() ?? (false, 0)
            if lastVersion.isShow {
                showAlertWith(title: LocalizedString(key: commonNoticeUpdateAPP), message: nil, messageTextAlignment: nil,
                              defaultButtonTitle: LocalizedString(key: commonUpdateNow), defaultButtonColor: .theme1,
                              cancelButtonTitle: LocalizedString(key: commonIgnoreNotice), cancelButtonColor: .black.withAlphaComponent(0.8),
                              cancelButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.updateUserNoMoreNotify(version: lastVersion.versionCode)
                    self.showDiskAlertIfAny()
                }, defaultButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.jumpAndCheckAppVersion()
                    self.showDiskAlertIfAny()
                })
            } else {
                showDiskAlertIfAny()
            }
        } else {
            showDiskAlertIfAny()
        }
    }

    private func exitReorderMode() {
        tabBarController?.tabBar.isUserInteractionEnabled = true
        groupToolbarContainer.isUserInteractionEnabled = true

        pageController.scrollEnable = true

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }

        isReordering = false
    }
}
//
//  SweeperMainViewController.swift
//  Pods
//
//  Created by 爱迪生 on 2021/8/2.
//

import UIKit
import SurveillanceHomeBase
import Promises
import SwiftyJSON
import SharedResource
import TPFoundation
import SimplePlayer
import DeviceDetailModule
import SnapKit
import NetService
import ThemeTool

enum CaptureImageLoadingStatus: Equatable {
    case loadSuccess
    case failure
    case loading
    case loadNoImage
    case model(SweeperBarrierType)
}

enum MainMapLoadingState {
    case loading
    case failure
    case noMap
    case hasMap
}

class SweeperMainViewController: SweeperGlobalConfigurationViewController {
    var needShowFastMapGuide: Bool = false
    // MARK: subviews
    private var previewButton: SweeperButton?
    weak var inputPasswordVC: UIViewController?
    var inputPassword: String?
    private var editButton: SweeperButton?
    private var baseStationButton: SweeperButton?
    private var moreButton: SweeperButton?
    private var parameterButton = SweeperButton()
    private var navigationTitleView = SweeperTitleBatteryView()
    private var chargeButton = SweeperButton()
    private var createMapContainer: SweeperCreateMapView?
    private var sweepAreaPopView: SweeperClearAreaPopView?
    private var sweeperAlarmViewController: (UIViewController & SweeperAlarmWindowSuitable)?
    private var startCleanAnimationView: SweeperStartCleanAnimationView?
    private var mapView = SweeperHomeMapView(frame: .zero, mapSize: .init(width: 1200, height: 1200))
    private var loadingView = SweeperMainMapLoadingView(frame: .zero)
    private var buttonContainerStackView = UIStackView()
    private var environmentView = UIView(frame: .zero)
    private var temperatureView = UILabel(frame: .zero)
    private var humidityView = UILabel(frame: .zero)
    private var equipmentOfflineView: SweeperRobotOfflineView?

    private var sweepControlView = SweeperControlView()
    private var sweepCaptureView = SweeperCaptureBubbleView()
    private var sweeperBaseUpgradingView = SweeperBaseStationUpgradingView()
    private var sweeperMechanicalOffView = SweeperMechanicalOffView()

    private var sweepControlViewHeightConstraint: NSLayoutConstraint?
    private var heightForControlView: CGFloat {
        switch status {
        case .stop:
            return 88 + bottomSafeAreaInset
        case .fastMap, .fastMapPause:
            return 69 + bottomSafeAreaInset
        case .sweepingPause, .sweeping:
            return 143 + bottomSafeAreaInset
        }
    }

    enum AlarmButtonClickMode {
        case exit
        case more
        case none
    }
    private var alarmButtonClickMode: AlarmButtonClickMode = .exit

    // 快速建图引导view
    private var fastMapImageView: UIImageView?
    private var fastMapGuideView: GuidePresentationView?


    // 地图已自动保存通知
    private var savedMapNoticeView: UIImageView?
    private var saveMapGuideView: GuidePresentationView?
    // 存储设备详细信息
    private var deviceDetail: DeviceDetail?
    private var isSharedDevice: Bool {
        return deviceDetail?.isSharedDevice ?? false
    }

    private var robotOffline = false
    private var hadStartWaveAnimation = false

    /// 首次载入
    /// 第一帧地图帧/路径帧到来时刷新所有界面
    private var needRefreshMapViewInMediaPlayer = true
    private var needEntrySaveMapLogic = true
    private var needShowCleaningLog = true

    /// 该属性用于，当前保存地图弹窗弹出时，扫地机正在清扫。保存该弹出状态，在清扫结束后再进入一遍保存地图逻辑。
    private var needEntrySaveMapLogicAfterBasicStateChanged = false


    /// 在地图变化时，将下列是否需要展示“地图保存”弹窗标识为true
    /// 在dataloading成功时，进行展示
    private var needShowSaveMapMultiFloor = false
    private var needShowSaveMapSingleFloor = false
    private var needShowMapHasSavedTip = false

    /// 基站升级与关机页面展示
    private var isShowingUpgradingView: Bool {
        get {
            return !sweeperBaseUpgradingView.isHidden
        }
        set {
            sweeperBaseUpgradingView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var isShowingMechanicalView: Bool {
        get {
            return !sweeperMechanicalOffView.isHidden
        }
        set {
            sweeperMechanicalOffView.isHidden = !newValue
            sweeperAlarmViewController?.view.isHidden = newValue
        }
    }

    private var shouldShowChargeButton: Bool {
        get {
            guard let state = state else {
                return false
            }
            // 清扫完成并且不在基站上
            return state.cleanFinished && !state.onboard
        }
    }

    private var firstTimeUpdateNavigationTitle: Bool = true

    private var cleaningMode: SweeperCleaningMode {
        get {
            return sweeperControl?.cleaningMode ?? SweeperCleaningMode.init(type: .autoClean)
        }
        set {
            sweeperControl?.cleaningMode = newValue
            updateCleaningModeUI()
        }
    }

    private var cleaningModeType: CleaningModeType {
        get {
            return cleaningMode.type
        }
        set {
            cleaningMode.type = newValue
        }
    }

    override var sweeperCustomOrAutoMode: SweeperCustomOrAutoMode {
        get {
            return (sweeperControl?.customCleanEnabled ?? false) ? .custom : .auto
        }
        set { }
    }

    private var map: SweeperMap? {
        get {
            return sweeperControl?.map
        }
        set {
            let preMap = map
            sweeperControl?.map = newValue
            currentMapDidChanged(preMap: preMap)
        }
    }

    private var status: SweeperProcedure = .stop

    private var state: SweeperState? {
        get {
            return sweeperControl?.basicState
        }

        set {
            sweeperControl?.basicState = newValue
            basicStateChangeAction(showToast: true)
        }
    }

    private var temperatureText: String {
        get {
            var text = "环境温度："
            if let temperature = state?.temperature {
                let temperatureValue = Int(temperature)
                if temperatureValue == 127 || temperatureValue < -40 {
                    text += "--"
                } else {
                    text += "(Int(temperature))℃"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var humidityText: String {
        get {
            var text = "环境湿度："
            if let humidity = state?.humidity {
                let humidityValue = Int(humidity)
                if humidityValue < 0 || humidityValue > 100 {
                    text += "--"
                } else {
                    text += "(Int(humidity))%"
                }
            } else {
                text += "-"
            }
            return text
        }
    }

    private var cleaningState: SweeperCleaningState? {
        get {
            return sweeperControl?.cleaningState
        }

        set {
            sweeperControl?.cleaningState = newValue
            updateCleaningStateUI()
        }
    }

    private var isRecharging: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .recharge
    }

    private var forbiddenRechargeAndClean: Bool {
        guard let state = state else {
            return false
        }
        return state.mainState == .assignLocation || state.mainState == .remoteControl
    }

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = SharedResource.sharedImage(named: "shared_setting_icon_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(settingBarButtonItemDidClick))
    }()

    // selected layerID backup
    private var selectedLayerID = [Int]()

    // 当前展示的障碍物ID
    private var obstacleID: Int?

    override var navigationBarTraits: [NavigationBarTrait] {
        return [.hidden(on: false), .style(style: .default), .translucent(on: false), .barTint(color: .init(hexString: lightGray10Color)), .separatorStyle(color: .clear, height: 0.0), .backgroundImage(image: UIImage())]
    }

    // MARK: - Constants
    private let chargeButtonPadding = 8.0
    private let defaultButtonPadding = 12.0
    private let defaultButtonInterval = 59.0
    private let battreyThreshold = 20
    private let bottomSafeAreaInset = TPUIUtils.safeAreaInsets().bottom

    override init(deviceID: TPSSDeviceIdentifier, listType: TPSSDeviceListType) {
        super.init(deviceID: deviceID, listType: listType)

        SweeperModule.shared.registerControlListener(listener: self, deviceID: deviceID, listType: listType)
        SweeperModule.shared.registerMapListener(mapListener: self)
        NotificationCenter.default.addObserver(self, selector: #selector(willEnterForeground), name: UIApplication.willEnterForegroundNotification, object: nil)
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        view.backgroundColor = .init(hexString: lightGray10Color)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        setupNavigation()
        setupControlView()
        setupMapView()
        setupSweeperAlarmView()
        setupButtons()
        setupOfflineView()
        setupEnvironmentView()
        setupLoadingView()
        setupUpgradingView()
        setupMechanicalOffView()
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        deviceDetail = DeviceDetailManager.detail(for: deviceID, listType: listType)
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true

        // 离开当前页面时，会使动画失效，若正在展示动画，再重新进入时，需要重新开始动画
        if hadStartWaveAnimation {
            startWaveAnimation()
        }

        if let loadingState = sweeperControl?.dataLoadingState {
            dataLoadingStateChangeAction(loadingState: loadingState)
        } else {
            updateViewShowState(state: .failed)
        }
        captureBubbleViewDismiss()
        // 横幅始终展示在最前方
        if let alarmView = sweeperAlarmViewController?.view {
            view.bringSubviewToFront(alarmView)
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        if needShowFastMapGuide {
            showFastMapGuideView()
            needShowFastMapGuide = false
        }
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        savedMapNoticeView?.removeFromSuperview()
    }

    deinit {
        SweeperModule.shared.removeControlListener(listener: self)
        SweeperModule.shared.removeMapListener(mapListener: self)
        NotificationCenter.default.removeObserver(self)
    }

    // 将从后台切换到前台，看作视图willAppear，方法作相同处理
    @objc func willEnterForeground() {
        cleanAllFlag()

        // 若当前的载入状态为loading时，对UI进行loading状态的刷新。
        // 否则等待dataLoadingStateDidChanged方法回调(从 loading -> 其他状态)。
        // 注：dataLoadingStateDidChanged方法在 loading -> loading 时不会被调用。
        if sweeperControl?.dataLoadingState == .loading {
            dataLoadingStateChanged(loadingState: .loading)
        }
    }

    /// 根据载入状态更新主页面View的展示情况
    /// -主页面加载状态 -
    /// 需要管理的控件：创建地图按钮、主页面地图、载入（载入失败）页面、编辑地图按钮、边扫边拖（定制清扫）悬浮按钮
    private func updateViewShowState(state: SweeperDataLoadingState) {
        switch state {
            case .loading:
                loadingView.isHidden = false
                loadingView.isLoadingFailure = false
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
            case .failed:
                loadingView.isLoadingFailure = true
                sweepControlView.isHidden = true
                chargeButton.isHidden = true
                mapView.isHidden = true
                createMapContainer?.isHidden = true
                parameterButton.isHidden = true
                moreButton?.isHidden = true
                editButton?.isHidden = true
                environmentView.isHidden = true
                previewButton?.isHidden = true
                baseStationButton?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = true
                // 若扫地机离线，则展示离线页面，否则展示加载失败页面
                loadingView.isHidden = robotOffline
                equipmentOfflineView?.isHidden = !robotOffline
            case .noMap:
                createMapContainer?.isHidden = false
                loadingView.isHidden = true
                mapView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                parameterButton.isHidden = false
                moreButton?.isHidden = false
                editButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
            case .success:
                loadingView.isHidden = true
                sweepControlView.isHidden = false
                chargeButton.isHidden = false
                mapView.isHidden = false
                createMapContainer?.isHidden = true
                parameterButton.isHidden = false
                editButton?.isHidden = false
                moreButton?.isHidden = false
                environmentView.isHidden = false
                previewButton?.isHidden = false
                baseStationButton?.isHidden = false
                equipmentOfflineView?.isHidden = true
                sweeperAlarmViewController?.view?.isHidden = false
        }
    }

    override func willUpdateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode, showAlert: Bool) -> Bool {
        /// 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            if showAlert {
                showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap)
            }
            return false
        }
        return super.willUpdateSweeperCustomOrAutoMode(newMode: newMode, showAlert: showAlert)
    }

    override func updateSweeperCustomOrAutoMode(newMode: SweeperCustomOrAutoMode) {
        /// 1. 若切换时当前清扫模式与newMode相同，则无需进入后续逻辑
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap,
              let sweeperControl = sweeperControl,
              let mapID = sweeperControl.map?.currentMapID,
              newMode != sweeperCustomOrAutoMode else {
            return
        }

        /// 2. 切换为定制清扫时，且当前地图不存在时，展示弹窗
        if (map?.currentMapID == isCreatingMapID || map?.currentMapID == noMapID) && newMode == .custom {
            let isCreatingMap = map?.currentMapID == isCreatingMapID
            showCanNotCustomCleanAlert(isCreatingMap: isCreatingMap) { [weak self] (_) in
                self?.configurationView?.selectSegment(type: .auto)
            }
            return
        }

        /// 3. 切换为定制清扫时，无设置清扫顺序与清扫偏好，则不向设备发送请求（并在退出弹窗时（configurationFinished）切换回变扫边拖）
        if newMode == .custom && !isSetPreference() && !isSetSweepSeq() {
            return
        }

        /// 4. 发送切换清扫模式的接口，并修改主页面UI
        let customCleanEnabled = newMode == .custom
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestSetCleaningParam(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: mapID, customEnabled: customCleanEnabled).always {
            ToastView.dismissLoadingToast()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }

    override func configurationFinished() {
        /// 若configurationView当前处于定制清扫页面（“1”状态），则判断是否已设置定制清扫，若否切回边扫边拖。
        if !isSetPreference() && !isSetSweepSeq() && !settingButtonDidClickFlag && configurationView?.segmentedControl.selectedSegmentIndex == 1 {
            ToastView.showWarningToast(title: "未设置定制清扫，只能使用普通清扫", existTime: nil, centerY: .low)
            // 0 - means auto cleaning
            configurationView?.selectSegment(type: .auto)
        }
    }

    override func preferenceButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.preferenceButtonClickOperation()
    }

    override func sweepOrderButtonClickOperation() {
        if state?.mainState == .cleaning {
            ToastView.showWarningToast(title: LocalizedString(key: sweeperSettingAfterCleaning), existTime: nil, centerY: .low)
            return
        }
        super.sweepOrderButtonClickOperation()
    }

    private func refreshMediaPlayerAndSweeperControl() {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.refreshSweeperControl()
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
    }

    private func updateConfigurationView() {
        configurationView?.selectSegment(type: sweeperCustomOrAutoMode)
        if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
            cleanMethodMode = mode
        }
    }

    private func updateClearingAreaButton() {
        var text = "全屋"
        var imagePath = "sweep_home"
        var title = text
        switch cleaningModeType {
        case .pointClean:
            text = "选框"
            title = text
            imagePath = "sweep_frame"
        case .areaClean:
            text = "区域"
            title = text
            imagePath = "sweep_region"
        case .autoClean:
            text = "全屋"
            title = text
            imagePath = "sweep_home"
        case .partClean:
            // 仅在sweepControlView的RangeTitle中修改
            updateData(with: .autoClean)
            title = "局部"
        case .fastMap:
            // DO NOTHING
            return
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
        sweepControlView.clearAreaButton?.titleLabel.text = text
        sweepControlView.clearAreaButton?.titleImageView.image = UIImage.image(named: imagePath)
        sweepControlView.rangeTitleLabel.text = title
        sweepControlView.clearAreaButton?.selectedAreaNumber = cleaningModeType == .areaClean ? selectedLayerID.count : 0
    }

    private func updateSweeperHomeMapViewCleanMode() {
        switch cleaningModeType {
        case .pointClean:
            mapView.cleaningModeType = .pointClean
        case .areaClean:
            mapView.cleaningModeType = .areaClean
        case .autoClean:
            mapView.cleaningModeType = .autoClean
        case .partClean:
            mapView.cleaningModeType = .partClean
        case .fastMap:
            mapView.cleaningModeType = .fastMap
        case .pause:
            // DO NOTHING
            return
        case .stop:
            // DO NOTHING
            return
        }
    }

    private func updateSelectedLayerID() {
        if let seq = sweeperControl?.cleaningMode.areaIDs {
            selectedLayerID = seq
        }
    }

    private func updateParamUI() {
        var text = ""
        var imagePath = ""
        switch sweeperCustomOrAutoMode {
        case .auto:
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                switch mode {
                case .sweep:
                    text = LocalizedString(key: sweeperCleanOnlySweep)
                    imagePath = "mode_sweep"
                case .mop:
                    text = LocalizedString(key: sweeperCleanOnlyMop)
                    imagePath = "mode_mop"
                case .both:
                    text = LocalizedString(key: sweeperCleanSweepAndMop)
                    imagePath = "mode_sweep_mop"
                }
            }
        case .custom:
            text = LocalizedString(key: sweeperCustomClean)
            imagePath = "mode_diy"
        }
        let image = UIImage.image(named: imagePath)
        // 控制栏的参数按钮
        sweepControlView.parameterButton?.titleLabel.text = text
        sweepControlView.parameterButton?.titleImageView.image = image

        // 悬浮的参数按钮
        parameterButton.titleLabel.text = text
        parameterButton.titleImageView.image = image
    }

    private func updateSweeperHomeMapViewCustomOrAutoMode() {
        switch sweeperCustomOrAutoMode {
        case .auto:
            mapView.sweeperCustomOrAutoMode = .auto
        case .custom:
            mapView.sweeperCustomOrAutoMode = .custom
        }
    }

    private func dataLoadingStateChangeAction(loadingState: SweeperDataLoadingState) {
        // 1. 判断设备是否离线（deviceDetail.online）
        if loadingState == .failed {
            robotOffline = !(deviceDetail?.online ?? false)
        }

        // 2. 判断基站是否升级，若是，则不展示所有UI（除了导航栏）
        if state?.chargeBaseUpgrading == true {
            isShowingUpgradingView = true
            updateNavigation()
            return
        }

        if let switchOn = state?.mechanicalSwitchOn {
            showMechanicalOffView(switchOn: switchOn)
        }

        // 3. 刷新UI状态(是否hidden)
        updateViewShowState(state: loadingState)

        // 4. 载入成功（success or nomap）按照其他状态展示UI
        if loadingState == .success {
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            mapView.updateCleanningModeAndSweepingState()
            mapView.updateCustomOrAutoMode()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            sweeperAlarmViewController?.showAlarm()
            sweeperAlarmViewController?.showNotify()
            if needShowCleaningLog {
                sweeperAlarmViewController?.showCleaningLog()
                needShowCleaningLog = false
            }
            if needEntrySaveMapLogic {
                currentMapDidChanged(preMap: nil)
                needEntrySaveMapLogic = false
            }
            saveMapLogic()
        } else if loadingState == .noMap {
            // 尽管当前map id 为-2，但当设备发送地图帧过来时，仍然需要展示地图，故仍然需要刷新mapView
            mapView.shouldRefreshSize = true
            mapView.restoreInitalMapView()
            mapView.refreshView()
            sweeperAlarmViewController?.showCleaningLog()
            basicStateChangeAction(showToast: false)
            updateCleaningModeUI()
            updateCleaningStateUI()
            // 用户未进入引导页，且当前不在清扫、建图中，需要进入快速建图引导页
            if UserDefaults.standard.shouldShowGuideForFastMap(for: deviceID) && (state?.cleanFinished ?? true) {
                let vc = SweeperFastMapGuideViewController(deviceID: deviceID, listType: listType)
                navigationController?.pushViewController(vc, animated: true)
            }
        }
    }

    private func saveMapLogic() {
        // 若需要展示弹窗，但当前在清扫中，则将弹窗状态保存起来，待扫地机状态变化时重新进入。
        if state?.cleanFinished == false && (needShowSaveMapSingleFloor || needShowSaveMapMultiFloor) {
            needEntrySaveMapLogicAfterBasicStateChanged = true
            return
        }
        if needShowMapHasSavedTip {
            showMapHasSavedTip()
            needShowMapHasSavedTip = false
        }
        if needShowSaveMapSingleFloor {
            saveMapSingleFloor()
            needShowSaveMapSingleFloor = false
        }
        if needShowSaveMapMultiFloor {
            saveMapMultiFloor()
            needShowSaveMapMultiFloor = false
        }
    }

    private func basicStateChangeAction(showToast: Bool) {
        // 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 展示波纹动画: 1. 当前地图ID为-2；
        //             2. 当前在清扫中；
        //             3. 未展示过动画
        //             4. 无地图帧
        if map?.currentMapID == noMapID
            && state?.cleanFinished == false && !hadStartWaveAnimation && sweeperControl?.hadFrame == false {
            startWaveAnimation()
        }
        if (state?.cleanFinished == true) {
            stopWaveAnimation()
        }
        // 特殊情况处理，当扫地机进入清扫状态时
        // 且当前处于无地图时，需要显示地图（而非等到map更改的信令进行变化）
        // 再次变为非清扫状态，且无地图时，需要展示无地图Image
        if map?.currentMapID == noMapID && state?.cleanFinished == false {
            updateViewShowState(state: .success)
        } else if map?.currentMapID == noMapID && state?.cleanFinished == true {
            updateViewShowState(state: .noMap)
        }

        // 扫地机关机状态更新
        showMechanicalOffView(switchOn: state?.mechanicalSwitchOn ?? false)

        if showToast {
            updateBasicStateToastView()
        }
        // 更新扫地机当前的清扫状态（将扫地机状态分为清扫中、暂停中、未清扫，后续根据该status更新清扫UI）
        updateSweepProduce()

        updateUI()
    }

    /// 使用Clean Finished，fast Map  字段与 basic state字段联合判断当前清扫是否结束
    private func updateSweepProduce() {
        guard let state = state else {
            status = .stop
            return
        }
        if state.cleanFinished && state.mainState != .paused && state.mainState != .cleaning {
            // 若设备清扫完成且设备主状态不在清扫、暂停时
            status = .stop
        } else {
            if state.fastMap {
                // 若为快速建图
                if state.mainState == .cleaning {
                    status = .fastMap
                } else {
                    status = .fastMapPause
                }
            } else {
                // 若不为快速建图，则展示正常清扫UI
                if state.mainState == .cleaning {
                   status = .sweeping
                } else {
                   status = .sweepingPause
                }
            }
        }
    }

    // 根据信令展示ToastView
    private func updateBasicStateToastView() {
        guard let state = state else {
            return
        }
        // 主状态为回充，遥控，清扫时候，主页均需展示loading
        if ((state.mainState == .cleaning || state.mainState == .recharge || state.mainState == .remoteControl) && state.subState == .relocate) {
            ToastView.showLoadingToast(cirleWithMessage: "定位中...", existTime: 60, existMessage: nil)
        } else {
            ToastView.dismissLoadingToast()
        }
    }

    /// 根据status更新：清扫面板、清扫参数、导航栏里扫地机的状态、回充按钮、提示栏的位置；
    /// status:     sweeping：当cleanFinished为false，且mainState为Cleaning，subState为Sweeping；
    ///        pause：当cleanFinished为false，
    private func updateUI() {
        // 只当地图数据载入完成之后，更新信令收到后的UI
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        // 每次收到信令后，获取设备状态，更新设备状态同时更新界面UI

        // 控制面板
        sweepControlView.status = status
        sweepControlViewHeightConstraint?.constant = heightForControlView
        if status == .stop {
            // 清扫参数按钮
            parameterButton.isHidden = true
            // 地图控件
            mapView.isSweeping = false
        } else if status == .fastMap || status == .fastMapPause {
            mapView.isSweeping = true
            parameterButton.isHidden = true
        } else {
            parameterButton.isHidden = false
            mapView.isSweeping = true
        }
        // 导航栏的状态和电量
        updateNavigation()
        // 温度湿度更新
        updateEnvironmentView()
        // 充电按钮
        updateChargeButton()
        refreshBubbleView()
    }

    private func updateCleaningStateUI() {
        guard let state = cleaningState else {
            return
        }
        sweepControlView.areaTitleLabel.text = "(state.cleaningArea)㎡"
        sweepControlView.timeTitleLabel.text = "(state.cleaningTime)min"
    }

    private func updateCleaningModeUI() {
        /// 当载入成功时，才根据BasicState显示UI的变化
        guard sweeperControl?.dataLoadingState == .success || sweeperControl?.dataLoadingState == .noMap else {
            return
        }
        /// 修改设置清扫模式（cleaningMode）按钮的样式
        updateClearingAreaButton()
        /// 修改地图的清扫模式
        updateSweeperHomeMapViewCleanMode()
        /// 根据获取到的cleaningMode中区域清扫的ID，更新地图区域的清扫顺序数组
        updateSelectedLayerID()
        /// 修改定制清扫/边扫边拖属性 - 通过回调去更新该属性更新后主页后续的UI。回调中调用的方法 - updateSweeperCustomOrAutoMode()
        updateConfigurationView()
        /// 修改定制清扫/边扫边拖按钮的样式
        updateParamUI()
        /// 修改定制清扫/边扫边拖地图的样式
        updateSweeperHomeMapViewCustomOrAutoMode()
    }

    private func showAlertWithWholeHouseClean() {
        showAlertWith(title: "进行一次全屋清扫", message: "清扫完成后，将建立家居地图。", messageTextAlignment: .center, defaultButtonTitle: "进行全屋清扫", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonHandler: nil) { [weak self] (_) in
            self?.showSweepTipsAlert()
        }
    }

    private func startFastMap() {
        if sweeperControl?.basicState?.mainState == .remoteControl {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFastMapDuringRemoteControl))
            return
        }
        if sweeperControl?.basicState?.mainState == .assignLocation {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotFAstMapDuringAssignLocation))
            return
        }
        // 强制扫地机进入新建快速地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .fastMap)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: self.deviceID, channel: self.channel, listType: self.listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func startFastMapAlert() {
        let alert = SweeperTipsAlert(type: .fastMap) { [weak self] () in
            guard let self = self else { return }
            self.startFastMap()
        }
        alert.show()
    }

    private func showAlertWithFastMapEnd() {
        showAlertWith(title: "尚未得到完整地图，确定要结束吗？", message: nil, messageTextAlignment: .center, defaultButtonTitle: "结束建图", defaultButtonColor: .theme1, cancelButtonTitle: "继续", cancelButtonHandler: nil) { [weak self] (_) in
            self?.setCleaningMode(type: .stop)
        }
    }

    private func showSweepTipsAlert() {
        let alert = SweeperTipsAlert(type: .clean) { [weak self] () in
            self?.setCleaningMode(type: .sweeping)
        }
        alert.show()
    }

    private func setCleaningMode(type: SweeperProcedure) {
        switch type {
        case .sweeping:
            if sweeperControl?.basicState?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringRemoteControl))
                return
            }
            if sweeperControl?.basicState?.mainState == .assignLocation {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperCannotCleanDuringAssignLocation))
                return
            }
            // 若扫地机当前无地图，则所有“清扫”操作为全屋清扫。
            if map?.currentMapID == noMapID {
                self.cleaningMode = SweeperCleaningMode.init(type: .autoClean)
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: SweeperCleaningMode.init(type: .autoClean)).catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
                return
            }

            if cleaningModeType == .areaClean {
                if selectedLayerID.count == 0 {
                    ToastView.showWarningToast(title: "请选择需要清扫的区域", existTime: nil, centerY: .low)
                    return
                }
                sweeperControl?.cleaningMode.areaIDs = selectedLayerID
            } else if cleaningModeType == .pointClean,
                      let partArea = mapView.getSelectionRect() {
                // 若能够从SelectionRect获取到数据，则修改cleaningMode的PointRect
                sweeperControl?.cleaningMode.leftTopPoint = partArea.leftTopPoint
                sweeperControl?.cleaningMode.rightBottomPoint = partArea.rightBottomPoint
            } else {
                sweeperControl?.cleaningMode = .init(type: .autoClean)
            }

            ToastView.showLoadingToast(cirleWithMessage: nil)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: sweeperControl?.cleaningMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .sweepingPause, .fastMapPause:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .pause)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .stop:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .stop)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        case .fastMap:
            ToastView.showLoadingToast(cirleWithMessage: nil)
            let pendingMode = SweeperCleaningMode.init(type: .fastMap)
            SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingMode).catch { error in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }.always {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func saveMapSingleFloor() {
        let deleteMapID = map?.allMapNames.keys.first(where: { (mapID) -> Bool in
                  return mapID != temporaryMapID
              })
        guard let sweeperControl = sweeperControl,
              let deleteMapID = deleteMapID,
              let deleteMapName = map?.allMapNames[deleteMapID] else {
            return
        }
        showAlert(title: "是否保存新地图?", buttons: [
            .init(style: .default, text: "更新“(deleteMapName)”", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                ToastView.showLoadingToast(cirleWithMessage: "正在更新")
                SweeperService.deleteMap(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, mapID: deleteMapID).then { (_) in
                    ToastView.showWarningToast(title: "更新成功", existTime: nil, centerY: .low)
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }.always {
                    ToastView.dismissLoadingToast()
                }
            }),
            .init(style: .default, text: "另存为新地图", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let alert = SweeperSelectionAlert(title: "相同环境请勿保存多张地图，有可能影响机器人的定位。", message: "我家为多楼层户型") {
                    guard self?.isCurrentMapSaved() == true else {
                        ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                        return
                    }
                    ToastView.showLoadingToast(cirleWithMessage: "正在保存")
                    SweeperService.setMultiFloorEnabled(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType, enabled: true, mapID: nil).always {
                        ToastView.dismissLoadingToast()
                    }.then { _ in
                        ToastView.showWarningToast(title: "保存成功", existTime: nil, centerY: .low)
                    }.catch { (error) in
                        ToastView.showWarningToast(warningMessage: error.localizedDescription)
                    }
                } cancelHandler: { [weak self] () in
                    self?.saveMapSingleFloor()
                }
                alert.show()
            }, isPreferred: true),
            .init(style: .default, text: LocalizedString(key: notSaveMap))
        ])
    }

    private func saveMapMultiFloor() {
        showAlert(title: "地图数量已达上限，是否保存新地图？", message: "如点击“保存”，请选择新地图要覆盖哪张旧地图。", messageTextAlignment: .center, buttons: [
            .init(style: .default, text: LocalizedString(key: notSaveMap), color: .theme1),
            .init(style: .default, text: "保存", color: .theme1, action: { [weak self] (_) in
                guard self?.isCurrentMapSaved() == true else {
                    ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperMapSavedUpdate))
                    return
                }
                let vc = SweeperCoverOldMapController()
                vc.sweeperControl = self?.sweeperControl
                self?.navigationController?.pushViewController(vc, animated: true)
            }, isPreferred: true)
        ])
    }

    private func isCurrentMapSaved() -> Bool {
        return map?.currentMapID == temporaryMapID
    }

    /// preMapID 为 nil，表示为第一次赋值
    private func currentMapDidChanged(preMap: SweeperMap?) {
        guard let map = map else {
            return
        }
        // 展示波纹动画条件： 1. 当前地图id为-2
        //                 2. 当前主状态为清扫中
        //                 3. 第一次进入主页面
        //                 4. 当前无地图I帧
        let needShowRobotWave = map.currentMapID == noMapID && sweeperControl?.basicState?.mainState == .cleaning && (preMap == nil || !hadStartWaveAnimation) && sweeperControl?.hadFrame == false
        if needShowRobotWave {
            startWaveAnimation()
        }
        /// preMapID 从 nil -> 0，未处理后退出主页重新进入
        /// 或 从 “-1” -> 0  表示成功创建，但还未自动保存新地图
        let preMapID = preMap?.currentMapID
        if (preMapID == nil || preMapID == isCreatingMapID) && map.currentMapID == temporaryMapID {
            ///  生成临时地图： 需要判断是多楼层还是单楼层来决定保存方式；
            guard let multiFloorEnabled = sweeperControl?.multiFloorEnabled, let maxMapNumber = sweeperControl?.capability?.maxMapNumber else {
                return
            }
            if multiFloorEnabled {
                if map.mapNumber > maxMapNumber && maxMapNumber > 0 && map.currentMapID == temporaryMapID {
                    // 地图已达上限且能力集中多楼层地图上限不为0，且当前地图是临时地图时，展示多楼层地图上限弹窗
                    needShowSaveMapMultiFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            } else {
                if map.mapNumber > 1 && map.currentMapID == temporaryMapID {
                    // 已经有一张地图且当前地图时临时地图时，展示单楼层地图上限弹窗。
                    needShowSaveMapSingleFloor = true
                } else {
                    // 自动保存地图
                    needShowMapHasSavedTip = true
                }
            }
            return
        }

        /// 成功创建，mapID 从 “-1” -> 大于0
        if preMapID == isCreatingMapID && map.currentMapID != noMapID && map.currentMapID != temporaryMapID && map.allMapNames.count == (preMap?.allMapNames.count ?? 0) + 1 {
            ///  生成完整地图：直接进入“已自动保存逻辑”
            needShowMapHasSavedTip = true
        }
    }

    private func showMapNotCompletedAlert(alertMessage: String, cancelHandler: ((UIAlertAction) -> Void)? = nil, defaultHandler: (() -> Void)? = nil) {
        showAlertWith(title: alertMessage, message: nil, messageTextAlignment: nil, defaultButtonTitle: "查看帮助", defaultButtonColor: .theme1, cancelButtonTitle: "关闭", cancelButtonColor: .theme1, cancelButtonHandler: cancelHandler, defaultButtonHandler: { [weak self] (_) in
            let vc = SweeperMapHelpViewController(type: .incomplete)
            self?.navigationController?.pushViewController(vc, animated: true)
            defaultHandler?()
        })
    }

    private func showCanNotCustomCleanAlert(isCreatingMap: Bool, defaultButtonhandler: ((UIAlertAction) -> Void)? = nil) {
        if isCreatingMap {
            showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持定制清扫", defaultHandler: { [weak self] () in
                self?.configurationView?.dismiss()
            })
        } else {
            showAlertWith(title: "请创建地图后再设置定制清扫", defaultButtonTitle: SharedResource.sharedFormatString(key: commonSure), defaultButtonColor: UIColor.black, cancelButtonTitle: nil, defaultButtonHandler: defaultButtonhandler)
        }
    }

    func showFastMapGuideView() {
        if fastMapImageView == nil {
            fastMapImageView = UIImageView()
            fastMapImageView?.image = UIImage.image(named: "quick_build_map")
            fastMapImageView?.sizeToFit()
        }
        guard let imageView = fastMapImageView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            fastMapGuideView?.dismiss()
            var offset: CGFloat = defaultButtonInterval
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            fastMapGuideView = presentGuideWith(viewToPresent: imageView, size: imageView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    func showMapHasSavedTip() {
        if savedMapNoticeView == nil {
            savedMapNoticeView = UIImageView()
            savedMapNoticeView?.image = UIImage.image(named: "edit_map")
            savedMapNoticeView?.sizeToFit()
        }
        guard let noticeView = savedMapNoticeView else {
            return
        }
        if let source = editButton {
            // guide view的展示基于editbutton的位置，需要明确navigationBar的位置以确保guide位置正确。
            navigationController?.navigationBar.layoutIfNeeded()
            saveMapGuideView?.dismiss()
            var offset: CGFloat = 0
            if previewButton == nil || previewButton?.isHidden == true {
                offset = defaultButtonInterval
            }
            saveMapGuideView = presentGuideWith(viewToPresent: noticeView, size: noticeView.frame.size, source: source, clickThrough: true, offset: CGPoint(x: -20, y: 7.5 - offset))
        }
    }

    override func collectionViewCell(_ cell: SweeperGlobalCleaningConfigurationCollectionViewCell, didSelectItemAt indexPath: IndexPath) {
        super.collectionViewCell(cell, didSelectItemAt: indexPath)

        let itemIndex = indexPath.section
        let row = indexPath.row
        let parameter = settingItems[itemIndex].paramters[row].type
        if parameter == .suctionForce(.none) {
            showAlertWith(title: "静音模式下吸尘能力将暂时降低，仅本次清扫任务生效。", message: nil, messageTextAlignment: nil, defaultButtonTitle: "确定", defaultButtonColor: .theme1, cancelButtonTitle: "取消", cancelButtonColor: .black, cancelButtonHandler: nil) { [weak self] (_) in
                self?.setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
            }
        } else {
            setGlobalConfig(parameter: parameter, itemIndex: itemIndex)
        }
    }

    func setGlobalConfig(parameter: SweeperGlobalConfigurationType, itemIndex: Int) {
        var pendingConfig = sweeperControl?.globalCleaningConfig

        switch parameter {
        case .suctionForce(_):
            pendingConfig?.suction = parameter
        case .waterYield(_):
            pendingConfig?.waterYield = parameter
        case .sweepTimes(_):
            pendingConfig?.cleanTimes = parameter
        case .cleanMethod(_):
            pendingConfig?.cleanMethod = parameter
        case .mopMode(_):
            pendingConfig?.mopMode = parameter
        }


        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setGlobalCleaningConfig(device: deviceID, channel: channel, listType: listType, config: pendingConfig).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.then { [weak self] (_) in
            self?.sweeperControl?.globalCleaningConfig = pendingConfig
            self?.configurationView?.collectionView.reloadData()
            self?.updateParamUI()
        }
    }

    func startWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        let animationView = SweeperStartCleanAnimationView(frame: .zero)
        view.addSubview(animationView)

        animationView.snp.makeConstraints { make in
            make.centerX.equalToSuperview().offset(28)
            make.centerY.equalToSuperview().multipliedBy(0.764).offset(28)
            make.width.height.equalTo(56)
        }
        self.startCleanAnimationView = animationView
        animationView.startAnimation()
        hadStartWaveAnimation = true
    }

    func stopWaveAnimation() {
        startCleanAnimationView?.removeFromSuperview()
        startCleanAnimationView = nil
        hadStartWaveAnimation = false
    }

    private func cleanAllFlag() {
        needEntrySaveMapLogic = true
        firstTimeUpdateNavigationTitle = true
        needRefreshMapViewInMediaPlayer = true
        needShowMapHasSavedTip = false
        needShowSaveMapMultiFloor = false
        needShowSaveMapSingleFloor = false
        needEntrySaveMapLogicAfterBasicStateChanged = false
    }
}

// MARK: Button Action
private extension SweeperMainViewController {
    @objc func paramterButtonDidClick() {
        configurationView?.isSetSeq = isSetSweepSeq()
        configurationView?.isSetPreference = isSetPreference()
        configurationView?.show(view: self.navigationController?.view)
    }

    @objc func clearAreaButtonDidClick() {
        sweepAreaPopView = SweeperClearAreaPopView(type: cleaningModeType)
        sweepAreaPopView?.delegate = self
        sweepAreaPopView?.show()
    }

    @objc func startButtonDidClick() {
        guard (map?.currentMapID) != nil  else {
            return
        }
        if sweeperControl?.dataLoadingState == .success {
            setCleaningMode(type: .sweeping)
        } else {
            showAlertWithWholeHouseClean()
        }
    }

    @objc func stopButtonDidClick() {
        if status == .fastMapPause || status == .fastMap {
            showAlertWithFastMapEnd()
        } else {
            setCleaningMode(type: .stop)
        }
    }

    @objc func pasueButtonDidClick() {
        if status == .sweepingPause {
            setCleaningMode(type: .sweeping)
        } else if status == .fastMapPause {
            setCleaningMode(type: .fastMap)
        } else {
            setCleaningMode(type: .sweepingPause)
        }
    }

    @objc func previewButtonDidClick() {
        guard let mediaState = sweeperControl?.mediaState, checkEntryCondition() else {
            return
        }
        checkMediaStateAndJump(state: mediaState)
    }

    func checkMediaStateAndJump(state: SweeperMediaState) {
        // 若为被分享端，则不判断，直接进入人工驾驶页面
        if isSharedDevice {
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            vc.needShowSettingButton = false
            navigationController?.pushViewController(vc, animated: true)
            return
        }

        switch state {
        case .closed, .open:
            let vc = SweeperSettingManualDriveController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        case .openWithPermission:
            if sweeperControl?.mediaEncryptEnabled == true {
                // 视频加密开启，直接验证密码
                checkUnAuthenticated()
                return
            }
            // 视频加密关闭，需要检测设备空密码
            ToastView.showLoadingToast(cirleWithMessage: nil)
            requestCheckEmptyPassword {
                ToastView.dismissLoadingToast()
            }
        }
    }

    private func checkEntryCondition() -> Bool {
        if state?.collectDust == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterCollectionDust))
            return false
        }
        if state?.mopWashState == .started {
            ToastView.showWarningToast(warningMessage: LocalizedString(key: baseStationAfterWashingMop))
            return false
        }
        return true
    }

    @objc func baseStationButtonDidClick() {
        if sweeperControl?.basicState?.cleanSinkState != .stop {
            let vc = SweeperBaseStationCleanSinkViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        } else {
            let vc = SweeperBaseStationMainViewController(deviceID: deviceID, listType: listType)
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func moreButtonDidClick() {
        let vc = SweeperMoreActionViewController(deviceID: deviceID, listType: listType)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    @objc func editButtonDidClick() {
        // 大于0的地图数量为0时(无已保存地图)并且没有地图，不允许进入，若mapID为“-1”允许进入
        if sweeperControl?.mapWithoutZero?.count == 0 && sweeperControl?.map?.currentMapID == noMapID {
            // 若扫地机在清扫、建图时，展示暂无地图
            if (state?.cleanFinished ?? true) {
                let fastMapGuideSheet = SweeperFastMapSheet()
                fastMapGuideSheet.delegate = self
                fastMapGuideSheet.show()
            } else {
                ToastView.showWarningToast(title: "暂无地图", existTime: nil, centerY: .low)
            }
            return
        }

        let alertActionSheet = TPActionSheet.init(title: nil)
        let setRigionAction = TPActionSheetAction.init(title: "设置禁区/虚拟墙", detail: "设置不允许扫地机器人进入的区域", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }

            // 清扫过程中进入编辑禁区页面需要暂停扫地机
            if self.status == .sweeping || self.status == .fastMap {
                self.setCleaningMode(type: .sweepingPause)
            }
            // 回充过程中进入编辑进去页面需要设置为待机
            if self.state?.mainState == .recharge {
                ToastView.showLoadingToast(cirleWithMessage: nil)
                SweeperService.setStandBy(deviceID: self.deviceID, listType: self.listType).always {
                    ToastView.dismissLoadingToast()
                }.catch { error in
                    ToastView.showWarningToast(warningMessage: error.localizedDescription)
                }
            }
            // 指哪到哪和遥控时不允许进入禁区页面
            if self.state?.mainState == .assignLocation || self.state?.mainState == .remoteControl {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterMission))
                return
            }
            let vc = SweeperForbiddenAreaVirtualWallViewController(sweeperControl: self.sweeperControl)
            self.navigationController?.pushViewController(vc, animated: true)
        }

        let editMapAreaAction = TPActionSheetAction.init(title: "编辑地图区域", detail: "划分地图区域并进行标记", style: .detail) { [weak self] (_) in
            guard let self = self else {
                return
            }
            /// 清扫、快速建图中不允许进入编辑区域页面
            if self.status != .stop {
                ToastView.showWarningToast(warningMessage: LocalizedString(key: sweeperSettingAfterCleaning))
                return
            }
            /// 正在创建地图中不允许进入编辑区域页面
            guard self.map?.currentMapID != isCreatingMapID else {
                self.showMapNotCompletedAlert(alertMessage: LocalizedString(key: sweeperMapIsNotCompleteForEditingArea))
                return
            }
            let vc = SweeperEditMapAreaViewController(sweeperControl: self.sweeperControl)
            vc.isSetPreferenceOrOrder = self.isSetPreference() || self.isSetSweepSeq()
            self.navigationController?.pushViewController(vc, animated: true)
        }


        let manageMapAction = TPActionSheetAction.init(title: "管理地图", style: .leftTitle) { [weak self] (_) in
            guard let self = self else {
                return
            }
            let vc = SweeperMapManagerViewController()
            vc.delegate = self
            vc.deviceID = self.deviceID
            vc.listType = self.listType
            self.navigationController?.pushViewController(vc, animated: true)
        }

        var editActionArray: [TPActionSheetAction] = []
        editActionArray = map?.currentMapID == noMapID ? [manageMapAction] : [setRigionAction, editMapAreaAction, manageMapAction]

        editActionArray.forEach { (action) in
            action.font = .projectFont(ofSize: 16)
            action.detailFont = .projectFont(ofSize: 12)
            alertActionSheet.addAction(action)
        }
        alertActionSheet.separatorColor = .cellSeparatorGray

        alertActionSheet.show()
    }

    @objc func settingBarButtonItemDidClick() {
        if let vc = SweeperSettingViewController.create() {
            vc.deviceID = deviceID
            vc.listType = listType
            navigationController?.pushViewController(vc, animated: true)
        }
    }

    @objc func rechargeButtonDidClick() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.setRechargeState(device: deviceID, channel: channel, listType: listType, enabled: !isRecharging).always {
            ToastView.dismissLoadingToast()
        }.catch { (error) in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperRobotOfflineViewDelegate {
    func offlineHelpButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.requiredService?.goToOfflineHelp(deviceID: sweeperControl.deviceID, cloudID: sweeperControl.cloudID, listType: sweeperControl.listType, navigator: self.navigationController)
    }

    func offlineRefreshButtonDidClick(_ view: SweeperRobotOfflineView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        SweeperModule.shared.rebootMapMediaConnection(sweeperControl: sweeperControl)
        SweeperModule.shared.refreshSweeperControl()
    }
}

extension SweeperMainViewController: SweeperClearAreaPopViewDelegate {
    func updateData(with type: CleaningModeType) {
        if map?.currentMapID == isCreatingMapID {
            switch type {
            case .areaClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持区域清扫")
            case .pointClean:
                showMapNotCompletedAlert(alertMessage: "地图不完整，暂不支持选框清扫")
            case .autoClean:
                // DO NOTHING
                break
            case .partClean:
                // DO NOTHING
                break
            case .pause:
                // DO NOTHING
                break
            case .stop:
                // DO NOTHING
                break
            case .fastMap:
                // DO NOTHING
                break
            }
            sweepAreaPopView?.dismiss()
            return
        } else {
            if type == .areaClean {
                if map?.currentMapID != noMapID {
                    ToastView.showWarningToast(title: "请选择区域", existTime: nil, centerY: .low)
                }
            }
        }
        self.cleaningModeType = type
        sweepAreaPopView?.dismiss()
    }
}

// MARK: setup UI
private extension SweeperMainViewController {
    func setupNavigation() {

        navigationItem.title = deviceDetail?.alias ?? "扫地机器人"

        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
        addCustomNavigationLeftBarButtonItem(title: nil, image: SharedResource.sharedImage(named: "common_light_back_nor"))
    }

    func setupButtons() {
        var title: String
        var imageName: String
        if isSharedDevice {
            title = "遥控"
            imageName = "ptz"
        } else {
            title = "视频遥控"
            imageName = "preview_light_nor"
        }
        previewButton = SweeperButton(title: title, fontSize: 9, image: UIImage.image(named: imageName))
        let previewTap = UITapGestureRecognizer.init(target: self, action: #selector(previewButtonDidClick))
        previewButton?.addGestureRecognizer(previewTap)
        if let button = previewButton {
            self.view.bringSubviewToFront(button)
        }
        if let previewButton = previewButton {
            buttonContainerStackView.addArrangedSubview(previewButton)
        }

        editButton = SweeperButton(title: "编辑地图", fontSize: 9, image: UIImage.image(named: "map_black_nor"))

        let editTap = UITapGestureRecognizer.init(target: self, action: #selector(editButtonDidClick))
        editButton?.addGestureRecognizer(editTap)
        if let editButton = editButton {
            buttonContainerStackView.addArrangedSubview(editButton)
        }

        baseStationButton = SweeperButton(title: "基站", fontSize: 9, image: UIImage.image(named: "sweeper_home"))

        let stationTap = UITapGestureRecognizer.init(target: self, action: #selector(baseStationButtonDidClick))
        baseStationButton?.addGestureRecognizer(stationTap)
        if let baseStationButton = baseStationButton {
            buttonContainerStackView.addArrangedSubview(baseStationButton)
        }

        moreButton = SweeperButton(title: "更多", fontSize: 9, image: UIImage.image(named: "star"))

        let moreButtonTap = UITapGestureRecognizer.init(target: self, action: #selector(moreButtonDidClick))
        moreButton?.addGestureRecognizer(moreButtonTap)
        if let moreButton = moreButton {
            buttonContainerStackView.addArrangedSubview(moreButton)
        }

        [previewButton, editButton, baseStationButton, moreButton].forEach { button in
            button?.snp.makeConstraints { make in
                make.width.equalTo(44)
                make.height.equalTo(47)
            }
        }

        /* buttonContainerStackView */
        view.addSubview(buttonContainerStackView)
        buttonContainerStackView.axis = .vertical
        buttonContainerStackView.alignment = .center
        buttonContainerStackView.spacing = 12
        buttonContainerStackView.snp.makeConstraints { make in
            make.width.equalTo(44)
            make.top.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }

        /* createMapButton */
        createMapContainer = SweeperCreateMapView()
        if let createMapContainer = createMapContainer {
            view.addSubview(createMapContainer)

            let goldenRatio: CGFloat = 0.382
            createMapContainer.snp.makeConstraints { make in
                make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2).offset(-(88 * goldenRatio))
                make.centerX.equalToSuperview()
                make.width.equalTo(230)
            }
        }
        createMapContainer?.isHidden = true

        /* chargeButton */
        chargeButton = SweeperButton(title: "返回基站", fontSize: 9, image: UIImage.image(named: "robot_charger"), offsetToTop: 5)
        addContraint(for: chargeButton, trailingToSuperView: -defaultButtonPadding)
        chargeButton.isHidden = true
        chargeButton.snp.makeConstraints { make in
            if let sweeperAlarmView = sweeperAlarmViewController {
                make.bottom.equalTo(sweeperAlarmView.view.snp.top).offset(-defaultButtonPadding / 2)
            } else {
                make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding)
            }
        }
        let chargeTap = UITapGestureRecognizer.init(target: self, action: #selector(rechargeButtonDidClick))
        chargeButton.addGestureRecognizer(chargeTap)

        parameterButton = SweeperButton(title: LocalizedString(key: sweeperCleanSweepAndMop), fontSize: 9, image: UIImage.image(named: "mode_general"), offsetToTop: 5)
        addContraint(for: parameterButton, trailingToSuperView: -defaultButtonPadding, bottomToSuperView: nil)
        parameterButton.snp.makeConstraints { (make) in
            make.bottom.equalTo(chargeButton.snp.bottom)
        }

        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        parameterButton.addGestureRecognizer(paramTap)

    }

    func setupOfflineView() {
        let offlineView = SweeperRobotOfflineView(frame: .zero)
        offlineView.delegate = self
        self.view.addSubview(offlineView)

        let goldenRatio: CGFloat = 0.382
        offlineView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(goldenRatio * 2)
        }
        equipmentOfflineView = offlineView
        equipmentOfflineView?.isHidden = true
    }

    func updateNavigation() {
        if firstTimeUpdateNavigationTitle {
            navigationTitleView = SweeperTitleBatteryView(title: deviceDetail?.alias ?? "扫地机器人", stateText: "", power: 0, charge: false)
            navigationTitleView.snp.remakeConstraints { make in
                make.height.equalTo(44)
                make.width.equalTo(screenWidth - 150)
            }
            navigationItem.titleView = navigationTitleView
            firstTimeUpdateNavigationTitle = false
        }

        let stateText = state?.stateDescription ?? "故障中"
        let battery = state?.battery ?? 0
        let isCharging = state?.mainState == .charging
        navigationTitleView.setState(stateText: stateText, power: battery, charge: isCharging)
    }

    func updateEnvironmentView() {
        temperatureView.text = temperatureText
        humidityView.text = humidityText
    }

    func updateChargeButton() {
        chargeButton.isHidden = !shouldShowChargeButton
        if isRecharging {
            chargeButton.setTitle(title: "停止回充", buttonImage: UIImage.image(named: "robot_charge_stop"))
        } else {
            chargeButton.setTitle(title: "返回基站", buttonImage: UIImage.image(named: "robot_charger"))
        }
        if forbiddenRechargeAndClean {
            chargeButton.titleLabel.textColor = .lightGray3Color.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = false
        } else {
            chargeButton.titleLabel.textColor = .black.withAlphaComponent(0.8)
            chargeButton.isUserInteractionEnabled = true
        }
    }

    func setupLoadingView() {
        view.addSubview(loadingView)
        loadingView.delegate = self
        loadingView.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().multipliedBy(0.764)
        }
    }

    func setupMapView() {
        let mapSize = sweeperControl?.mapSize ?? CGSize(width: defaultMapWidth, height: defaultMapHeight)
        mapView = SweeperHomeMapView(frame: .zero, mapSize: mapSize)
        mapView.backgroundColor = UIColor.clear
        view.addSubview(mapView)
        mapView.delegate = self
        mapView.sweeperIconMapView.delegate = self
        mapView.datasource = self
        mapView.isHidden = true

        mapView.snp.makeConstraints { make in
            make.top.trailing.leading.equalToSuperview()
            make.bottom.equalTo(sweepControlView.snp.top)
        }
        setupTapGesture()
    }

    func setupTapGesture() {
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(didTaped(recognizer:)))
        self.mapView.addGestureRecognizer(tapGesture)
    }

    func setupSweeperAlarmView() {
        let sweeperAlarmViewController = SweeperAlarmBannerViewController()
        sweeperAlarmViewController.window(from: .mainPage)
        sweeperAlarmViewController.sweeperControl = self.sweeperControl

        self.addChild(sweeperAlarmViewController)
        view.addSubview(sweeperAlarmViewController.view)
        sweeperAlarmViewController.view.snp.makeConstraints { make in
            make.bottom.equalTo(sweepControlView.snp.top).offset(-defaultButtonPadding / 2)
            make.leading.equalToSuperview().offset(defaultButtonPadding)
            make.trailing.equalToSuperview().offset(-defaultButtonPadding)
        }
        self.sweeperAlarmViewController = sweeperAlarmViewController
    }

    @objc func didTaped(recognizer: UITapGestureRecognizer) {
        captureBubbleViewDismiss()
    }

    func setupEnvironmentView() {
        view.addSubview(environmentView)

        environmentView.snp.makeConstraints { make in
            make.height.equalTo(36)
            make.leading.top.equalToSuperview().offset(12)
        }
        environmentView.backgroundColor = .lightGray3Color.withAlphaComponent(0.1964)
        environmentView.layer.cornerRadius = 5

        [temperatureView, humidityView].forEach { label in
            environmentView.addSubview(label)

            label.backgroundColor = .clear
            label.textColor = .black.withAlphaComponent(0.6)
            label.textAlignment = .left
            label.font = .projectFont(ofSize: 10)
            label.snp.makeConstraints { make in
                make.height.equalTo(14)
                make.trailing.equalToSuperview().offset(-8)
                make.leading.equalToSuperview().offset(8)
            }
        }

        temperatureView.snp.makeConstraints { make in
            make.top.equalToSuperview().offset(4)
        }
        temperatureView.text = temperatureText

        humidityView.snp.makeConstraints { make in
            make.top.equalTo(temperatureView.snp.bottom)
        }
        humidityView.text = humidityText
    }

    func setupControlView() {
        addConstraint(forBottomView: sweepControlView, height: nil)
        sweepControlView.isHidden = true
        sweepControlViewHeightConstraint = NSLayoutConstraint(item: sweepControlView,
                                                             attribute: .height,
                                                             relatedBy: .equal,
                                                             toItem: nil,
                                                             attribute: .notAnAttribute,
                                                             multiplier: 1.0,
                                                             constant: 0)
        sweepControlViewHeightConstraint?.isActive = true

        // button clicked
        let paramTap = UITapGestureRecognizer.init(target: self, action: #selector(paramterButtonDidClick))
        sweepControlView.parameterButton?.addGestureRecognizer(paramTap)

        let clearTap = UITapGestureRecognizer.init(target: self, action: #selector(clearAreaButtonDidClick))
        sweepControlView.clearAreaButton?.addGestureRecognizer(clearTap)

        let startTap = UITapGestureRecognizer.init(target: self, action: #selector(startButtonDidClick))
        sweepControlView.startButton.addGestureRecognizer(startTap)

        let stopTap = UITapGestureRecognizer.init(target: self, action: #selector(stopButtonDidClick))
        sweepControlView.stopButton.addGestureRecognizer(stopTap)

        let pauseTap = UITapGestureRecognizer.init(target: self, action: #selector(pasueButtonDidClick))
        sweepControlView.pauseButton.addGestureRecognizer(pauseTap)

    }

    func setupUpgradingView() {
        view.addSubview(sweeperBaseUpgradingView)
        sweeperBaseUpgradingView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingUpgradingView = false
    }

    func setupMechanicalOffView() {
        view.addSubview(sweeperMechanicalOffView)
        sweeperMechanicalOffView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        isShowingMechanicalView = false
        sweeperMechanicalOffView.delegate = self
    }

    func addConstraint(forBottomView bottomView: UIView?, height: CGFloat?) {
        guard let bottomView = bottomView else {
            return
        }
        bottomView.translatesAutoresizingMaskIntoConstraints = false

        view.addSubview(bottomView)

        // UI中设置的阴影radius为12，此处设置为8，才能与UI的效果一致。
        let shadowRadius: CGFloat = 8
        bottomView.layer.shadowOffset = .init(width: 0, height: 2)
        bottomView.layer.shadowRadius = shadowRadius
        bottomView.layer.shadowColor = UIColor.black.cgColor
        bottomView.layer.shadowOpacity = 0.16

        NSLayoutConstraint(item: bottomView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .width,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        if let height = height {
            NSLayoutConstraint(item: bottomView,
                               attribute: .height,
                               relatedBy: .equal,
                               toItem: nil,
                               attribute: .notAnAttribute,
                               multiplier: 1.0,
                               constant: height).isActive = true
        }

        NSLayoutConstraint(item: bottomView,
                           attribute: .bottom,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .bottom,
                           multiplier: 1.0,
                           constant: 0).isActive = true

        NSLayoutConstraint(item: bottomView,
                           attribute: .centerX,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .centerX,
                           multiplier: 1.0,
                           constant: 0).isActive = true
    }

    func addContraint(for subView: UIView?, trailingToSuperView: CGFloat, topToSuperView: CGFloat? = nil, bottomToSuperView: CGFloat? = nil) {
        guard let subView = subView else {
            return
        }

        view.addSubview(subView)
        subView.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint(item: subView,
                           attribute: .width,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 44).isActive = true
        NSLayoutConstraint(item: subView,
                           attribute: .height,
                           relatedBy: .equal,
                           toItem: nil,
                           attribute: .notAnAttribute,
                           multiplier: 1.0,
                           constant: 47).isActive = true
        if let topToSuperView = topToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .top,
                               relatedBy: .equal,
                               toItem: view,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: topToSuperView).isActive = true
        }

        if let bottomToSuperView = bottomToSuperView {
            NSLayoutConstraint(item: subView,
                               attribute: .bottom,
                               relatedBy: .equal,
                               toItem: bottomLayoutGuide,
                               attribute: .top,
                               multiplier: 1.0,
                               constant: bottomToSuperView).isActive = true
        }

        NSLayoutConstraint(item: subView,
                           attribute: .trailing,
                           relatedBy: .equal,
                           toItem: view,
                           attribute: .trailing,
                           multiplier: 1.0,
                           constant: trailingToSuperView).isActive = true
    }
}

/// receive bitmap data
extension SweeperMainViewController: SweeperMapMediaPlayerListener {
    func mediaPlayerConnected(connectedSuccess: Bool) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if !connectedSuccess {
            dataLoadingStateChangeAction(loadingState: .failed)
        }
    }

    func dataLoadingStateChanged(loadingState: SweeperDataLoadingState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        dataLoadingStateChangeAction(loadingState: loadingState)
    }

    func mediaPlayerBitmapDataUpdate(dataType: MapMediaPlayerFrameFormat) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        /// 对扫地机地图正处于拖动或缩放时地图的刷新进行限制，避免卡顿的情况。
        guard !mapView.isOperation else {
            return
        }
        if dataType == .map {
            // 第一次收到I帧
            if sweeperControl?.hadFrame == true {
                stopWaveAnimation()
            }
            mapView.sweeperBitmapView.refreshBitmapImage()
            mapView.sweeperAreaView.refreshAreaView()
            if needRefreshMapViewInMediaPlayer {
                needRefreshMapViewInMediaPlayer = false
                mapView.refreshView()
            }
        }

        if sweeperControl?.hadFrame == true && dataType == .path {
            mapView.sweeperRouteView.refreshRouteView()
            // refresh equipment icon and charger pile location.
            mapView.sweeperIconMapView.refreshIconView()
        }
    }

    func mediaPlayerSignalling(mapID: String, type: SweeperConfigUpdateType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        if type == .cleaningState {
            updateCleaningStateUI()
        } else if type == .cleaningMode || type == .cleanParam {
            updateCleaningModeUI()
        } else if type == .areaCleaning {
            mapView.updateCustomOrAutoMode()
            mapView.refreshAreaAndLabelView()
        } else if type == .globalCleaningConfig {
            // 修改全局清扫配置
            if case let .cleanMethod(mode) = sweeperControl?.globalCleaningConfig?.cleanMethod {
                cleanMethodMode = mode
                configurationView?.collectionView.reloadData()
            }
        } else {
            mapView.refreshView()
            mapView.refreshAreaAndLabelView()
        }
    }

    func mediaPlayerBasicStateDidChanged(preState: SweeperState) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        basicStateChangeAction(showToast: true)
        sweeperAlarmViewController?.showAlarm()
        sweeperAlarmViewController?.showNotify()

        // 当前扫地机清扫结束时，若需要进入地图保存逻辑，则重新进入
        if !preState.cleanFinished && state?.cleanFinished == true && needEntrySaveMapLogicAfterBasicStateChanged {
            currentMapDidChanged(preMap: nil)
            saveMapLogic()
            needEntrySaveMapLogicAfterBasicStateChanged = false
        }
    }

    func mediaPlayerMapIDDidChanged(preMap: SweeperMap) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        currentMapDidChanged(preMap: preMap)

        /// 每次修改current map id 后， 地图的大小都会发生变化，故需要刷新初始地图的大小以适应屏幕
        mapView.restoreInitalMapView()
        mapView.shouldRefreshSize = true
        mapView.refreshView()
        mapView.updateCleanningModeAndSweepingState()
        mapView.updateCustomOrAutoMode()
        mapView.refreshAreaAndLabelView()
    }

    func mediaPlayerAlarm(type: SweeperAlarmType) {
        guard isShowing(ignorePresentedClasses: [UIAlertController.self, ActionSheetViewController<SweeperAlarmActionSheetCell>.self]) else {
            return
        }
        let alarm = SweeperAlarm(type: type)

        // 当前alarm需要在主页面显示、当基站升级、开关断开时不展示
        guard alarm.window.contains(.mainPage) && sweeperMechanicalOffView.isHidden && sweeperBaseUpgradingView.isHidden else {
            return
        }

        // 展示Toast
        if alarm.rank.contains(.toast),
           let message = alarm.toastTitle {
            ToastView.showWarningToast(title: message, existTime: nil, centerY: .low)
            return
        }

        // 展示Dialog，不展示只在基站展示的dialog
        if alarm.rank.contains(.dialog),
           !SweeperAlarm.baseDialogTypes.contains(type),
           let title = alarm.toastTitle {
            showAlertWith(title: title, message: alarm.toastContent, messageTextAlignment: .center, defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil, cancelButtonHandler: nil, defaultButtonHandler: nil)
            return
        }
    }
}

extension SweeperMainViewController: SweeperMapViewDataSource {
    func area(_ view: UIView, customCleanConfigurationIn areaID: Int) -> SweeperGlobalCleaningConfiguration? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaCleaningConfiguration
    }

    func area(_ view: UIView, infomationLayerMarkIn areaID: Int) -> String? {
        return sweeperControl?.mapModel?.areaModel.areaDictionary[areaID]?.areaLabel
    }

    func areaIDSet(_ in: UIView) -> [Int]? {
        return sweeperControl?.mapModel?.areaModel.areaIDs
    }

    func areaLabelLocation(_ view: UIView, areaID: Int) -> CGPoint? {
        return sweeperControl?.mapModel?.areaModel.areaLabelLocation[areaID]
    }

    func bitmapImage(_ view: UIView) -> CGImage? {
        return sweeperControl?.mapModel?.bitmapImage()
    }

    func bitmapOffset(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.offset
    }

    func bitmapSize(_ view: UIView) -> CGSize? {
        return sweeperControl?.mapModel?.bitmapSize
    }

    func areaData(_ view: UIView) -> [UInt8]? {
        return sweeperControl?.mapModel?.areaModel.areaData
    }

    func routeAllPointArray(_ view: UIView) -> [RoutePoint]? {
        return sweeperControl?.routeModel?.routePoints
    }

    func virtualWallIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.virtualWallModel?.wallIDs
    }

    func virutalWall(_ view: UIView, wallID: Int, isInEditMap: Bool) -> (CGPoint, CGPoint)? {
        return sweeperControl?.virtualWallModel?.couplePiontDictionary[wallID]
    }

    func forbiddenAreaIDSet(_ in: UIView, isInEditMap: Bool) -> [Int]? {
        return sweeperControl?.forbiddenAreaModel?.areaIDs
    }

    func forbiddenArea(_ view: UIView, areaID: Int, isInEditMap: Bool) -> RectangleArea? {
        return sweeperControl?.forbiddenAreaModel?.couplePiontDictionary[areaID]
    }

    func equipmentLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.routeModel?.equipmenLocation
    }

    func equipmentAngle(_ view: UIView) -> CGFloat? {
        return sweeperControl?.routeModel?.equipmenOritention
    }

    func chargePileLocation(_ view: UIView) -> CGPoint? {
        return sweeperControl?.mapModel?.chargePileLocation
    }

    func barrierIDSet(_ view: UIView) -> [Int]? {
        if let keys = sweeperControl?.barriersModel?.barrierDictionary.keys {
            return Array(keys)
        } else {
            return nil
        }
    }

    func barrier(_ view: UIView, barrierModelIn barrierID: Int) -> SweeperBarrier? {
        return sweeperControl?.barriersModel?.barrierDictionary[barrierID]
    }

    func rectClean(_ view: UIView) -> (leftTopPoint: CGPoint, rightBottomPoint: CGPoint)? {
        if cleaningMode.leftTopPoint != .zero && cleaningMode.rightBottomPoint != .zero {
            return (cleaningMode.leftTopPoint, cleaningMode.rightBottomPoint)
        } else {
            return nil
        }
    }

    func mapScale(_ view: UIView) -> CGFloat? {
        return sweeperControl?.capability?.mapScale
    }
}

extension SweeperMainViewController: SweeperHomeMapViewDelegate {
    func hadMapFrame(_ view: SweeperHomeMapView) -> Bool? {
        return sweeperControl?.hadFrame
    }

    func areaSelected(_ view: SweeperHomeMapView) -> [Int]? {
        if cleaningModeType == .areaClean {
            return selectedLayerID
        } else {
            return nil
        }
    }

    func homeMapViewIsSetPreference(_ view: SweeperHomeMapView) -> Bool {
        return isSetPreference()
    }

    func homeMapViewIsSetSeq(_ view: SweeperHomeMapView) -> Bool {
        return isSetSweepSeq()
    }

    func layer(_ view: SweeperHomeMapView, layerSelectedSequence layerID: Int) -> Int? {
        if cleaningModeType == .areaClean, let orderID = selectedLayerID.firstIndex(of: layerID) {
            return orderID
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, layerCleaningOrder layerID: Int) -> Int? {
        if let order = sweeperControl?.mapModel?.areaModel.areaCleaningOrder,
           let orderID = order.firstIndex(of: layerID) {
            return orderID + 1
        } else {
            return nil
        }
    }

    func layer(_ view: SweeperHomeMapView, selectedLayer layerID: Int) {
        if let index = selectedLayerID.firstIndex(of: layerID) {
            selectedLayerID.remove(at: index)
        } else {
            selectedLayerID.append(layerID)
        }
        if cleaningModeType == .areaClean && !selectedLayerID.isEmpty {
            ToastView.showWarningToast(title: "已选择(selectedLayerID.count)个区域", existTime: nil, centerY: .low)
        }
        updateClearingAreaButton()
        mapView.refreshAreaAndLabelView()
    }
}

extension SweeperMainViewController {

    // 物体抓拍气泡展示
    private func captureBubbleViewShow(captureView: UIImageView, titleText: String, iconImage: UIImage, status: CaptureImageLoadingStatus, obstacleID: Int, thumbnail: UIImage? = nil) {
        sweepCaptureView.removeFromSuperview()
        captureBubbleViewLayout(captureView: captureView)
        sweepCaptureView.delegate = self

        // 更新障碍物抓拍气泡的展示
        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: thumbnail, obstacleID: obstacleID)

        // 更新障碍物抓拍是否有缩略图以及缩略图状态
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl?.barrierRecognitionEnabled ?? false, captureImageStatus: status)

        self.view.layoutIfNeeded()
        self.autoSuitPosition()
    }

    private func captureBubbleViewLayout(captureView: UIImageView) {
        self.mapView.addSubview(sweepCaptureView)
        sweepCaptureView.snp.remakeConstraints { make in
            make.centerX.equalTo(captureView.snp.centerX)
            make.bottom.equalTo(captureView.snp.top).offset(-12)
            make.width.equalTo(159)
            if sweeperControl?.barrierRecognitionEnabled ?? false {
                make.height.equalTo(128)
            } else {
                make.height.equalTo(40)
            }
        }
    }

    // 物体抓拍气泡隐藏
    private func captureBubbleViewDismiss() {
        sweepCaptureView.dismiss()
    }

    private func autoSuitPosition() {
        var offsetX: CGFloat = 0
        var offsetY: CGFloat = 0
        let maxXCoordinate = mapView.frame.width - sweepCaptureView.frame.width - 16
        if sweepCaptureView.frame.origin.x < 16 {
            offsetX = 16 - sweepCaptureView.frame.origin.x
        } else if sweepCaptureView.frame.origin.x > maxXCoordinate {
            offsetX = maxXCoordinate - sweepCaptureView.frame.origin.x
        }

        if sweepCaptureView.frame.origin.y < 16 {
            offsetY = 16 - sweepCaptureView.frame.origin.y
        }
        // 不用考虑底部超出边界，因为弹窗从顶部出现

        mapView.moveBy(x: offsetX, y: offsetY)
    }

    /// 刷新当前正在展示的气泡及其内容
    private func refreshBubbleView() {
        guard let sweeperControl = sweeperControl,
              let obstacleID = obstacleID,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              let iconImage = barrier.type.bigImage,
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            captureBubbleViewDismiss()
            return
        }
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
            return
        }

        sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: nil, obstacleID: obstacleID)
        sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: .loading)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { [weak self] (status, image) in
            self?.sweepCaptureView.updateCaptureInformation(titleText: titleText, iconImage: iconImage, thumbnail: image, obstacleID: obstacleID)
            self?.sweepCaptureView.updateImageStatus(hasCaptureImage: sweeperControl.barrierRecognitionEnabled, captureImageStatus: status)
        }
    }

}

extension SweeperMainViewController: SweeperMapManagerViewControllerDelegate {
    func mapManagerBeginSweep(_ controller: SweeperMapManagerViewController) {
        // 强制扫地机进入新建地图模式
        ToastView.showLoadingToast(cirleWithMessage: nil)
        var pendingCleaningMode = SweeperCleaningMode.init(type: .autoClean)
        pendingCleaningMode.newMap = true
        SweeperService.setCleaningMode(device: deviceID, channel: channel, listType: listType, cleaningMode: pendingCleaningMode).catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    func mapManagerFastMap(_ controller: SweeperMapManagerViewController) {
        // 开始快速建图
        startFastMapAlert()
    }
}

extension SweeperMainViewController: SweeperCaptureBubbleViewDelegate {
    func captureNextButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.titleLabel.textColor = UIColor.black.withAlphaComponent(0.5)
        // 获取全部障碍物的详情页
        let sweepCaptureNextPageViewController = SweeperCaptureNextPageViewController(deviceID: deviceID, listType: listType)
        sweepCaptureNextPageViewController.delegate = self

        // 更新详情页跳转到具体哪个页面
        sweepCaptureNextPageViewController.obstacleID = captureView.obstacleID
        self.navigationController?.pushViewController(sweepCaptureNextPageViewController, animated: true)
    }

    func reloadButtonDidClick(_ captureView: SweeperSubViewInCaptureBubbleView) {
        captureView.imageStatus = .loading
        let barrierID = captureView.obstacleID
        guard let fileID = sweeperControl?.barriersModel?.barrierDictionary[barrierID]?.fileID else {
            return captureView.imageStatus = .loadNoImage
        }

        SweeperDownloader.downloadObstacleImage(forDevice: deviceID, listType: listType, fileID: fileID) { status, image in
            captureView.imageStatus = status
            captureView.titleImageView.image = image
        }
    }

    func handleGestures(enable: Bool) {
        mapView.isGestureEnable = enable
    }
}

extension SweeperMainViewController: SweeperMainMapLoadingViewDelegate {
    func reloadButtonDidClick(_ UIView: SweeperMainMapLoadingView) {
        refreshMediaPlayerAndSweeperControl()
    }
}

extension SweeperMainViewController: SweeperIconMapViewDelegate {
    func didTapBaseStation(in view: SweeperIconMapView) {
        baseStationButtonDidClick()
    }

    func iconMap(_ view: SweeperIconMapView, transforToScreenPointFrom realPoint: CGPoint) -> CGPoint? {
        // 之前未调用
        return nil
    }

    func didTapObstacle(in view: UIImageView, obstacleID: Int) {

        guard let sweeperControl = sweeperControl,
              let iconImage = sweeperControl.barriersModel?.barrierDictionary[obstacleID]?.type.bigImage,
              let barrier = sweeperControl.barriersModel?.barrierDictionary[obstacleID],
              var titleText = sweeperControl.barriersModel?.typeAndConfidenceLabelString(ofBarrier: obstacleID) else {
            return
        }
        self.obstacleID = obstacleID
        let confidence = barrier.confidence
        if confidence == barrierConfidenceMax {
            titleText = barrier.type.name
        }

        guard let fileID = barrier.fileID else {
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loadNoImage, obstacleID: obstacleID)
            return
        }

        self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: .loading, obstacleID: obstacleID)

        SweeperDownloader.downloadObstacleImage(forDevice: sweeperControl.deviceID,
                                                listType: sweeperControl.listType,
                                                fileID: fileID) { status, image in
            self.captureBubbleViewShow(captureView: view, titleText: titleText, iconImage: iconImage, status: status, obstacleID: obstacleID, thumbnail: image)
        }
    }
}

extension SweeperMainViewController: SweeperNewPasswordProtocol {
    func checkUnAuthenticated() {
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperModule.shared.requiredService?.checkUserInfo(deviceID: deviceID, listType: listType, completion: { [weak self] (success, errorCode) in
            ToastView.dismissLoadingToast()
            guard let self = self else {
                return
            }
            if success {
                self.goToPreview()
                return
            }

            if errorCode == TPSS_ASYNC_EC_TIMEOUT || errorCode == TPSS_COMM_EC_SYSTEM {
                /* 请求超时 */
                ToastView.showWarningToast(warningMessage: "网络错误")
                return
            }

            /* 设备锁定 */
            if errorCode == TPSS_COMM_EC_PREVIEW_LOCKED {
                self.showAlertWith(title: SharedResource.sharedString(key: sweeperPreviewLockedAlertTitle), defaultButtonTitle: SharedResource.sharedString(key: commonKnown), cancelButtonTitle: nil)
                return
            }

            /* 鉴权失败,弹出密码输入框 */
            self.presentInputPasswordVC(deviceID: self.deviceID, listType: self.listType)

        })
    }
}

extension SweeperMainViewController: SweeperVerifyPasswordProtocol {
    func verifySuccessHandler() {
        goToPreview()
    }
}

extension SweeperMainViewController: SweeperCaptureNextPageViewControllerDelegate {
    func ignoreButtonDidClick(sweeperCaptureNextPageViewController: SweeperCaptureNextPageViewController, barrierID: Int) {
        // 点击障碍物抓拍详情页的“忽略”所对应的障碍物Id
        guard let mapID = map?.currentMapID else {
             return
        }
        ToastView.showLoadingToast(cirleWithMessage: nil)
        SweeperService.requestIgnoreBarrier(device: deviceID, channel: channel, listType: listType, barrierID: "(barrierID)", mapID: mapID).always {
            ToastView.dismissLoadingToast()
        }.then { [weak self] (_) in
            ToastView.showWarningToast(warningMessage: "已忽略该物体")
            self?.sweepCaptureView.dismiss()
            self?.goBackToSweeperMainViewController()
        }.catch { error in
            ToastView.showWarningToast(warningMessage: error.localizedDescription)
        }
    }
}

extension SweeperMainViewController: SweeperMechanicalOffViewDelegate {
    func refreshButtonDidClick(in: SweeperMechanicalOffView) {
        guard let sweeperControl = sweeperControl else {
            return
        }
        sweeperMechanicalOffView.refreshLoadingUI(connectedState: .loading)
        view.bringSubviewToFront(sweeperMechanicalOffView)
        SweeperService.getSweeperState(device: sweeperControl.deviceID, channel: sweeperControl.channelID, listType: sweeperControl.listType).then { [weak self] (state) in
            guard let state = state else {
                return
            }
            self?.showMechanicalOffView(switchOn: state.mechanicalSwitchOn)
        }
    }

    func showMechanicalOffView(switchOn: Bool) {
        // 若开关关闭
        if !switchOn {
            isShowingMechanicalView = true
            sweeperMechanicalOffView.refreshLoadingUI(connectedState: .off)
        } else {
            isShowingMechanicalView = false
        }
    }
}

extension SweeperMainViewController: SweeperMoreActionViewControllerDelegate {
    func cleanWholeHouse(in vc: SweeperMoreActionViewController) {
        showSweepTipsAlert()
    }
}

extension SweeperMainViewController: SweeperFastMapSheetDelegate {
    func startFastMap(view: SweeperFastMapSheet) {
        startFastMapAlert()
    }
}

extension String {
    func separatedBySemiColon(isAutoFill: Bool = true) -> (String, String?) {
        let seperator = self.contains(":") ? ":" : "："
        let separatedTexts: [String] = self.components(separatedBy: seperator)
        if !isAutoFill && separatedTexts.count == 1 {
            return (separatedTexts[0], nil)
        } else {
            return (separatedTexts.count >= 1 ? separatedTexts[0] : "", separatedTexts.count >= 2 ? separatedTexts[1] : "")
        }
    }
}
//
//  OnlineDeviceListMasterViewController.swift
//  SurveillanceHome
//
//  Created by Li Linfeng on 2019/12/9.
//  Copyright © 2019 tplink. All rights reserved.
//

import UIKit
import SurveillanceHomeBase
import SharedResource
import TPFoundation
import DeviceDetailModule
import NetService

private var pageIndexAssociatedObjectHandle: UInt8 = 0

final class OnlineDeviceListMasterViewController: BaseViewController {
    @IBOutlet private weak var groupCollectionView: UICollectionView!
    @IBOutlet private weak var groupToolbarShadowView: UIView!
    @IBOutlet private weak var groupToolbarContainer: UIView!
    @IBOutlet private weak var groupToolbarDropMenuButton: UIButton!
    @IBOutlet private weak var recentPreviewView: RecentPreviewView!
    @IBOutlet private weak var containerViewBottom2SuperViewBottomConstraint: NSLayoutConstraint!
    @IBOutlet private weak var containerViewTop2TopLayoutGuideBottomConstraint: NSLayoutConstraint!

    override var navigationBarTraits: [NavigationBarTrait] {
        return NavigationBarTrait.noSeparator
    }

    private var deviceGroups: [TPSSDeviceGroup] = []
    private var currentGroupIndex: Int = 0

    private var newCreateGroupName = ""

    private var pageController: UIPageViewController!
    private var deviceListVCCacheDictionary = [TPSSDeviceGroupID: OnlineDeviceListViewController]()
    private var transitionVCForPageController = UIViewController()
    lazy private var loginCacheVC = DeviceListLoginViewController.create()

    private var firstAppear = true
    private var shouldRecreate: Bool = false

    /// for routers' entry
    private var isLoginBefore = false

    var sdCardStatusShowed: SDCardStatusShowed = .none
    var diskStatusShowed: SDCardStatusShowed = .none

    // camera display
    private var shouldShowCameraDisplayNoActiveChannelAlert = false
    private var addChannelCameraDisplay: TPSSDeviceForDeviceList?

    // navigation
    private lazy var moreToolBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(moreToolsButtonClicked(_:)))
    }()

    private lazy var addDeviceBarButtonItem: UIBarButtonItem = {
        let image = DeviceListModule.image(named: "devicelist_add_nor")?.withRenderingMode(.alwaysOriginal)
        return UIBarButtonItem(image: image, style: .plain, target: self, action: #selector(addDeviceButtonClicked(_:)))
    }()

    // MARK: guides and overlays
    private weak var addDeviceGuideView: GuidePresentationView?
    private weak var moreToolsPopoverView: GuidePresentationView?

    private lazy var groupPresenter = GroupListPresentationManager()
    private var presentedGroupList: GroupListViewController? {
        return presentedViewController as? GroupListViewController
    }

    private var currentList: OnlineDeviceListViewController {
        if let viewControllers = pageController.viewControllers, let firstViewController = viewControllers.first as? OnlineDeviceListViewController {
            return firstViewController
        }
        return OnlineDeviceListViewController()
    }

    private var isCloudLogin: Bool {
        return DeviceListModule.shared.requiredService?.isCloudLogin ?? false
    }

    private var isReordering = false                // 是否正在处于排序模式
    private var shouldToggleGroupModeAfterGetList = false   // 是否需要在获取列表结束后切换防护模式，仅在列表还未获取完时触发防护模式切换使用

    private var isShowing: Bool {
        return isShowing(ignorePresentedClasses: [UIAlertController.classForCoder()])
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        setupView()

        NotificationCenter.default.addObserver(self, selector: #selector(handleShowCameraDisplayNoActiveChannelAlertNotification(_:)), name: .ShowCameraDisplayNoActiveChannelAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleShowStorageDetectAlertNotification(_:)), name: .ShowStorageDetectAlert, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListInvalidated), name: .DeviceListInvalidated, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceListUpdated), name: .DeviceListUpdated, object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderBegined(_:)),
                                               name: .DeviceListReorderBegined,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleReorderEnded(_:)),
                                               name: .DeviceListReorderEnded,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupAndDeviceList(_:)),
                                               name: .UpdateGroupAndDeviceListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: DeviceListNetworkObserver.localDeviceRefreshed,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleUpdateGroupList(_:)),
                                               name: .UpdateGroupListFinished,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleLocalDeviceRefreshed(_:)),
                                               name: .unbindDiscoveryFinished,
                                               object: nil)

        _ = DeviceListModule.shared.requiredService?.addEntrustObserver(observeTypes: [.entrustmentStop, .entrustmentExitByTrustee], { (_, _) in
            DeviceListManager.shared.updateDeviceList(of: DeviceListManager.shared.defaultGroupID).always {
                self.currentList.reload()
            }
        })
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        showGroupAndNavigationButton(true)
        if !isCloudLogin {
            showEmpty()
        } else if firstAppear {
            firstAppear = false
            restore()
        } else if shouldRecreate {
            shouldRecreate = false
            reload()
        }
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        checkUpdateIfNeeded()

        if isCloudLogin {
            showPopoverGuideIfNeeded()
        }

        if shouldShowCameraDisplayNoActiveChannelAlert {
            shouldShowCameraDisplayNoActiveChannelAlert = false
            showCameraDisplayNoActiveChannelAlert()
        }
        updateGroupShadow()
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)

        dismissPresentedViews()
    }

    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let vc = segue.destination as? UIPageViewController {
            pageController = vc
            pageController.dataSource = self
            pageController.delegate = self
        }
    }

    private func refreshAfterGroupUpdated() {
        guard !isReordering else {
            return
        }

        guard isShowing else {
            // 如果分组刷新完，此时页面不是正在显示，则不进行页面刷新，仅记录状态，等回到本页面才统一进行刷新。
            // 需要注意通过记录状态后续回到页面才处理的逻辑，要与本方法后续处理逻辑要保持一致
            shouldRecreate = true
            return
        }

        reload()
    }

    private func showEmpty() {
        deviceGroups = []
        currentGroupIndex = -1

        showGroupAndNavigationButton(false)

        let emptyVC: UIViewController?
        // 有发现出来的/已绑定到局域网的设备时显示带登陆按钮的设备列表；没有则显示普通的登陆提示页
        if DeviceListManager.shared.unbindDetailDeviceList().count > 0 {
            emptyVC = createUnloginPage()
        } else {
            emptyVC = loginCacheVC
        }
        if let emptyVC = emptyVC {
            pageController.setViewControllers([emptyVC], direction: .forward, animated: false, completion: nil)
        }
        groupCollectionView.reloadData()
    }

    private func showGroupAndNavigationButton(_ shouldShow: Bool) {
        if shouldShow {
            navigationItem.leftBarButtonItem = moreToolBarButtonItem
            groupToolbarDropMenuButton.isHidden = false
        } else {
            navigationItem.leftBarButtonItem = nil
            groupToolbarDropMenuButton.isHidden = true
        }
    }

    private func restore() {
        deviceGroups = DeviceListManager.shared.groupList

        loadGroup(with: DeviceListManager.shared.lastSelectedGroupID)
    }

    private func reload(with preferredGroupID: String? = nil) {
        let oldGroupID = preferredGroupID ?? DeviceListManager.shared.lastSelectedGroupID
        deviceGroups = DeviceListManager.shared.groupList
        presentedGroupList?.groups = deviceGroups

        loadGroup(with: oldGroupID)
    }

    private func loadGroup(with groupID: String) {
        let currentGroup = DeviceListManager.shared.group(of: groupID) ?? DeviceListManager.shared.defaultGroup

        guard let groupIndex = deviceGroups.firstIndex(where: { $0.groupID == currentGroup.groupID }) else {
            return
        }

        currentGroupIndex = groupIndex

        presentedGroupList?.currentGroupID = currentGroup.groupID
        presentedGroupList?.reload()

        commonLoad()
    }

    private func commonLoad(animated: Bool = false, recreate: Bool = true) {
        groupCollectionView.reloadData()

        guard currentGroupIndex >= 0 else {
            return
        }

        groupCollectionView.scrollToItem(at: IndexPath(item: currentGroupIndex, section: 0), at: .right, animated: false)
        updateGroupShadow()

        if recreate, let vc = createPage(for: currentGroupIndex) {
            pageController.setViewControllers([vc], direction: .forward, animated: false, completion: nil)
        }

        storeGroupParameter()
    }

    private func updateGroupShadow() {
        groupToolbarShadowView.isHidden = groupCollectionView.bounds.maxX >= (groupCollectionView.contentSize.width - 1)
    }

    private func refreshAllDeviceLists() {
        if let viewController = pageController.viewControllers {
            viewController.forEach {
                if let vc = $0 as? OnlineDeviceListViewController {
                    vc.reload()
                }
            }
        }
    }

    private func createPage(for index: Int) -> OnlineDeviceListViewController? {
        let group = deviceGroups[index]
        guard let vc = createPage(for: group.groupID as TPSSDeviceGroupID) else {
            return nil
        }
        objc_setAssociatedObject(vc, &pageIndexAssociatedObjectHandle, index, .OBJC_ASSOCIATION_COPY_NONATOMIC)
        vc.realGroup = deviceGroups[index]
        return vc
    }

    private func createUnloginPage() -> OnlineDeviceListViewController? {
        return createPage(for: "unlogin page")
    }

    private func createPage(for key: TPSSDeviceGroupID) -> OnlineDeviceListViewController? {
        let vc: OnlineDeviceListViewController?
        if let item = deviceListVCCacheDictionary[key] {
            vc = item
        } else {
            vc = OnlineDeviceListViewController.create()
            deviceListVCCacheDictionary[key] = vc
        }
        return vc
    }
}

extension OnlineDeviceListMasterViewController: DeviceListUnwindDestination {}

// MARK: Popover handler
extension OnlineDeviceListMasterViewController {
    private func updateMenu() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let networkAvailable = NetworkManager.shared.isConnected
        let isInHomeMode = deviceGroups[currentGroupIndex].activeMode != .goOut
        let isBigCardMode = deviceGroups[currentGroupIndex].displayMode != .smallCard
        let homeModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_home_active") : DeviceListModule.image(named: "devicelist_home_disabled")
        let outModeImage = networkAvailable ? DeviceListModule.image(named: "devicelist_out_active") : DeviceListModule.image(named: "devicelist_out_disabled")
        DeviceGroupMenuItem.alarmMode.image = (isInHomeMode ? homeModeImage : outModeImage)?.withRenderingMode(.alwaysOriginal)
        DeviceGroupMenuItem.alarmMode.enabled = networkAvailable
        DeviceGroupMenuItem.alarmMode.title = isInHomeMode ? LocalizedString(key: deviceListModeHome) : LocalizedString(key: deviceListModeOut)
        DeviceGroupMenuItem.alarmMode.subtitle = isInHomeMode ? LocalizedString(key: deviceListSwitchModeToOut) : LocalizedString(key: deviceListSwitchModeToHome)
        DeviceGroupMenuItem.viewMode.title = isBigCardMode ? LocalizedString(key: deviceListViewGrid) : LocalizedString(key: deviceListViewList)
        DeviceGroupMenuItem.viewMode.subtitle = isBigCardMode ? LocalizedString(key: deviceListSwitchViewToList) : LocalizedString(key: deviceListSwitchViewToGrid)
        DeviceGroupMenuItem.viewMode.image = isBigCardMode ?  DeviceListModule.image(named: "devicelist_grid")?.withRenderingMode(.alwaysOriginal) : DeviceListModule.image(named: "devicelist_list")?.withRenderingMode(.alwaysOriginal)
    }

    private func handleDeviceGroupMenu(item: DeviceGroupMenuView.Item) {
        switch item {
        case .alarmMode:
            toggleGroupMode()
        case .search:
            navigateToSearch()
        case .viewMode:
            toggleDisplayMode()
        }
    }

    private func toggleGroupMode() {
        dismissPresentedViews()

        let deviceListUpdateStatus = DeviceListManager.shared.deviceListUpdateStatus
        if !deviceListUpdateStatus.cloudUpdateNecessaryInfoFinished {
            // 列表必要信息没获取到，此时若需要改变防护模式，就先请求获取数据并且loading，等所有信息获取完处理，避免数据不完整导致处理出错
            if !deviceListUpdateStatus.isUpdatingList {
                DeviceListManager.shared.updateGroupAndDeviceList()
            }
            shouldToggleGroupModeAfterGetList = true
            ToastView.showLoadingToast(cirleWithMessage: nil)
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.activeMode
        let newMode = group.activeMode == .goOut ? TPSSDeviceGroupMode.atHome : .goOut
        group.activeMode = newMode
        ToastView.showLoadingToast(cirleWithMessage: nil)
        DeviceListManager.shared.changeActiveMode(with: deviceGroups[currentGroupIndex]).then { () in
            self.currentList.reload()
            self.currentList.showToastForActiveMode(newMode)
        }.catch { (_) in
            group.activeMode = originalMode
        }.always {
            ToastView.dismissLoadingToast()
        }
    }

    private func toggleDisplayMode() {
        dismissPresentedViews()

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let group = deviceGroups[currentGroupIndex]
        let originalMode = group.displayMode
        let newMode = originalMode == .bigCard ? DeviceUIDisplayType.smallCard : .bigCard

        DeviceListManager.shared.changeDisplayMode(for: group.groupID, with: newMode)

        for section in 0..<currentList.collectionView.numberOfSections {
            for item in 0..<currentList.collectionView.numberOfItems(inSection: section) {
                if newMode == .smallCard {
                    currentList.fold(at: IndexPath(row: item, section: section))
                } else {
                    currentList.unfold(at: IndexPath(row: item, section: section))
                }
            }
        }

        currentList.reload()
    }

    private func navigateToSearch() {
        dismissPresentedViews()
        let allDevices = DeviceListManager.shared.allDetailDevices
        let allGroups = DeviceListManager.shared.groupList
        let vc = RemoteDeviceListSearchViewController(devices: allDevices, groups: allGroups)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }
}

extension OnlineDeviceListMasterViewController {
    // MARK: Popover
    private func showPopoverGuideIfNeeded() {
        // add device popover
        if UserDefaults.standard.object(forKey: deviceListLaunchKey) == nil {
            showAddDevicePopover()
            UserDefaults.standard.set(true, forKey: deviceListLaunchKey)
        }
    }

    private func showAddDevicePopover() {
        if !isShowing() {
            /* 如果界面切换了不要加载 */
            return
        }
        if let source = (navigationItem.rightBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            navigationController?.navigationBar.layoutIfNeeded()
            dismissPresentedViews()
            addDeviceGuideView = presentGuideWith(viewToPresent: TutorialGuideView.addDevice, size: TutorialGuideView.addDevice.frame.size, source: source, clickThrough: true)
            addDeviceGuideView?.delegate = self
        }
    }
}

extension OnlineDeviceListMasterViewController: GuidePresentationViewDelegate {
    func guidePresentationViewDidDismiss(_ view: GuidePresentationView) {
        if view == moreToolsPopoverView {
            navigationItem.leftBarButtonItem?.tintColor = UIColor(white: 0, alpha: 0.8)
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
        }
    }
}

// MARK: - util
extension OnlineDeviceListMasterViewController {
    private func storeGroupParameter() {
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        DeviceListManager.shared.updateLastSelectGroupID(deviceGroups[currentGroupIndex].groupID)
    }
}

extension OnlineDeviceListMasterViewController {

    private func presentUpgradeInfo(appVersionInfo: AppUpgradeModuleBaseUpgradeInfo) {
        let alertViewController = DeviceListUpgradeAlertController(versionInfo: appVersionInfo)
        present(alertViewController, animated: true, completion: nil)
    }

    private func checkUpdateIfNeeded() {
        let requiredService = DeviceListModule.shared.requiredService
        guard requiredService?.shouldShowNewAppVersion() ?? false else {
            return
        }

        // 仅跳转至需要更新的包中（若对应版本的升级包needNotify为false，而另外版本的needNotify为true，会跳转至另一版本）
        if TPAppUtils.isTestFlightBeta() {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, appVersionInfo.needNotify, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        } else {
            if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appFormalUpgradeInfo, appVersionInfo.needNotify {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            } else if let appVersionInfo = requiredService?.latestAppVersionInfo()?.appBetaUpgradeInfo, let url = URL.init(string: "itms-beta://"), UIApplication.shared.canOpenURL(url) {
                presentUpgradeInfo(appVersionInfo: appVersionInfo)
            }
        }

    }
}

extension OnlineDeviceListMasterViewController: DeviceListSearchViewControllerDelegate {
    func navigateToGroup(group: TPSSDeviceGroup) {
        navigationController?.popViewController(animated: true)
        DispatchQueue.main.async {
            self.loadGroup(with: group.groupID)
        }
    }

    func navigateToSyncPreviewViewController(device: DeviceDetail) {
        goToSyncPreview(ipc: device, listType: device.listType)
    }

    func navigateToPreviewViewController(device: DeviceDetail, channel: TPSSChannelInfo?) {
        if device.deviceType == .smartLock {
            DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
            return
        }
        goToPreview(device: device, channel: channel)
    }

    func navigateToBatteryDoorbellViewController(device: DeviceDetail, fromNVR nvr: (deviceID: TPSSDeviceIdentifier, channel: UInt)?) {
        DeviceListModule.shared.requiredService?.navigateToBatteryDoorbellViewController(for: device.identifier, group: DeviceListManager.shared.defaultGroupID, listType: device.listType, navigator: navigationController, from: nvr?.deviceID, channelInNVR: nvr?.channel.intValue)
    }

    func navigateToNVRViewController(nvr: DeviceDetail) {
        var groupId = DeviceListManager.shared.defaultGroup.groupID
        if currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex {
            groupId  = deviceGroups[currentGroupIndex].groupID
        }
        goToNVR(nvr: nvr, groupID: groupId)
    }

    func navigateToSolarControllerManagerViewController(device: DeviceDetail) {
        goToSolarController(solarController: device)
    }

    func navigateToRouterManagerViewController(device: DeviceDetail) {
        goToRouter(device: device)
    }

    func navigateToSmartLockViewController(device: DeviceDetail) {
        DeviceListModule.shared.requiredService?.gotoSmartLock(mac: device.mac, from: navigationController)
    }
}

// MARK: Navigation
extension OnlineDeviceListMasterViewController: PreviewControllerEntrance {
    func goToPreview(device: DeviceDetail, channel: TPSSChannelInfo?) {
        goToPreview(deviceID: device.identifier, channelID: channel?.channelId.intValue ?? -1, listType: device.listType)
    }

    func goToNVR(nvr: DeviceDetail, groupID: String? = nil) {
        let vc = NVRTabViewController()
        vc.cloudIdentifier = nvr.cloudDeviceID
        vc.deviceIdentifier = nvr.identifier
        vc.listType = nvr.listType
        vc.groupId = groupID
        navigationController?.pushViewController(vc, animated: true)
    }

    func goToSolarController(solarController: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToSolarControllerManagerViewController(deviceID: solarController.identifier, listType: solarController.listType, navigator: navigationController)
    }

    func goToRouter(device: DeviceDetail, groupID: String? = nil) {
        DeviceListModule.shared.requiredService?.navigateToRouterDefault(mac: device.mac, listType: device.listType, isOnline: device.online, navigator: navigationController)
    }
}

// MARK: Actions
extension OnlineDeviceListMasterViewController {
    private func dismissPresentedViews() {
        addDeviceGuideView?.dismiss()
        moreToolsPopoverView?.dismiss()

        presentedGroupList?.dismiss(animated: true, completion: nil)

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }

    @IBAction private func addDeviceButtonClicked(_ sender: Any) {
        guard isCloudLogin else {
            showAlertWith(title: LocalizedString(key: deviceListNotLogin), defaultButtonTitle: LocalizedString(key: deviceListLogin), defaultButtonHandler: { (_) in
                DeviceListModule.shared.requiredService?.navigateToLoginViewController(navigator: self.navigationController)
            })
            return
        }
        dismissPresentedViews()

        DeviceListModule.shared.requiredService?.presentDeviceAddViewController(viewController: self, listType: listType)
    }

    @IBAction private func moreToolsButtonClicked(_ sender: Any) {
        guard isCloudLogin else { return }

        if moreToolsPopoverView != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let size = CGSize(width: 212, height: 16 + DeviceGroupMenuView.Item.allCases.count * 44)
        let menuView = DeviceGroupMenuView(frame: CGRect(origin: .zero, size: size))
        menuView.action = handleDeviceGroupMenu

        dismissPresentedViews()

        updateMenu()

        if let source = (navigationItem.leftBarButtonItem?.value(forKey: "view") as? UIView)?.subviews.first {
            moreToolBarButtonItem.image = DeviceListModule.image(named: "devicelist_more_tools")?.withRenderingMode(.alwaysOriginal)
            menuView.configurePopoverShadow(cornerRadius: 8)
            moreToolsPopoverView = presentGuideWith(viewToPresent: menuView, size: size, backgroundColor: .clear, source: source, offset: CGPoint(x: -12, y: 4))
            moreToolsPopoverView?.delegate = self
        }
        navigationItem.leftBarButtonItem?.tintColor = .theme1
    }

    @IBAction private func groupMenuToggled(_ sender: UIButton) {
        guard isCloudLogin else { return }

        if presentedViewController != nil {
            dismissPresentedViews()
            return
        }

        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_up_small_normal"), for: .normal)

        let groups = DeviceListManager.shared.groupList
        guard let vc = GroupListViewController.create() else {
            return
        }
        let height = CGFloat(groups.count) * 52 + 72
        vc.preferredContentSize = CGSize(width: UIScreen.main.bounds.width, height: height)
        vc.modalPresentationStyle = .custom
        vc.transitioningDelegate = groupPresenter
        vc.groups = groups
        vc.currentGroupID = deviceGroups[currentGroupIndex].groupID
        vc.delegate = self
        present(vc, animated: true, completion: nil)
    }

    @IBAction private func recentPreviewClicked(_ sender: Any) {
        // 不会用到此按钮，但暂时保留
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDataSource {
    private func groupInformation(at index: Int) -> (String, Bool) {
        if deviceGroups.isEmpty { return (LocalizedString(key: deviceListMyDevice), true) }
        return (deviceGroups[index].groupName, index == currentGroupIndex)
    }

    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }

    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return max(1, deviceGroups.count)
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        return collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)
    }
}

extension OnlineDeviceListMasterViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        updateGroupShadow()
    }
}

extension OnlineDeviceListMasterViewController: UICollectionViewDelegate {
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        if deviceGroups.isEmpty { return }
        dismissPresentedViews()
        loadGroup(with: deviceGroups[indexPath.item].groupID)
    }
}

extension OnlineDeviceListMasterViewController: DeviceGroupNameLayoutDelegate {
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, groupForItemAt indexPath: IndexPath) -> (name: String, selected: Bool) {
        return groupInformation(at: indexPath.item)
    }
}

// MARK: Page Management
extension OnlineDeviceListMasterViewController: UIPageViewControllerDataSource {
    func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex > 0 && currentGroupIndex < deviceGroups.count else { return nil }
        return createPage(for: currentGroupIndex - 1)
    }

    func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
        guard currentGroupIndex >= 0 && currentGroupIndex < deviceGroups.count - 1 else { return nil }
        return createPage(for: currentGroupIndex + 1)
    }
}

extension OnlineDeviceListMasterViewController: UIPageViewControllerDelegate {
    func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
        if completed {
            if let viewControllers = pageViewController.viewControllers, let firtViewController = viewControllers.first {
                if let currentGroupIndex = objc_getAssociatedObject(firtViewController, &pageIndexAssociatedObjectHandle) as? Int {
                    self.currentGroupIndex = currentGroupIndex
                    commonLoad(animated: true, recreate: false)
                }
            }
        }
    }
}

// MARK: Group Management
extension OnlineDeviceListMasterViewController: GroupListViewControllerDelegate {
    func groupListViewController(_ groupListViewController: GroupListViewController, canMoveGroupTo destinationIndex: Int) -> Bool {
        guard deviceGroups.count > destinationIndex else {
            return false
        }
        let group = deviceGroups[destinationIndex]
        return !group.isDefaultGroup
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didMoveGroupAt sourceIndex: Int, to destinationIndex: Int) {
        // check if current group index has changed
        guard currentGroupIndex >= 0 && deviceGroups.count > currentGroupIndex else {
            return
        }

        let originalGroup = deviceGroups[currentGroupIndex]
        deviceGroups.swapAt(sourceIndex, destinationIndex)
        if let newIndex = deviceGroups.firstIndex(of: originalGroup), currentGroupIndex != newIndex {
            currentGroupIndex = newIndex
        }
        // always invalidate page controller cache
        pageController.setViewControllers([currentList], direction: .forward, animated: false, completion: nil)
        groupCollectionView.moveItem(at: IndexPath(item: sourceIndex, section: 0), to: IndexPath(item: destinationIndex, section: 0))
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didSelectGroupAt index: Int) {
        dismissPresentedViews()
        loadGroup(with: deviceGroups[index].groupID)
    }

    func groupListViewControllerDidSelectCreatingNewGroup(_ groupListViewController: GroupListViewController) {
        dismissPresentedViews()
        guard let vc = CommonNameInputViewController.create() else {
            return
        }
        vc.navigationTitle = LocalizedString(key: deviceListSetGroupNameTitle)
        vc.doneButtonTitle = LocalizedString(key: commonNextStep)
        vc.delegate = self
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewController(_ groupListViewController: GroupListViewController, didRequestEditingGroupAt index: Int) {
        dismissPresentedViews()
        guard let vc = GroupSettingViewController.create() else {
            return
        }
        vc.group = deviceGroups[index]
        navigationController?.pushViewController(vc, animated: true)
    }

    func groupListViewControllerDidDismiss(_ groupListViewController: GroupListViewController) {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
        _ = DeviceListManager.shared.updateGroupOrder(newGroup: deviceGroups)
    }
}

extension OnlineDeviceListMasterViewController: CommonNameInputViewControllerDelegate {
    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didCancelWith text: String) {
        navigationController?.popViewController(animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, didFinishWith text: String) {
        guard deviceGroups.count > 0 else {
            navigationController?.popToViewController(self, animated: true)
            return
        }
        newCreateGroupName = text
        let vc = DeviceSelectionViewController(entry: .groupAddIndependent, group: DeviceListManager.shared.defaultGroupID, canProceedWithNoSelection: true)
        vc.delegate = self
        vc.hidesBottomBarWhenPushed = true
        navigationController?.pushViewController(vc, animated: true)
    }

    func nameInputViewController(_ nameInputViewController: CommonNameInputViewController, errorMessageFor text: String) -> (allowed: Bool, message: String?) {
        let error = TPSSDeviceListValidate.validateDeviceGroupName(text)
        if error != nil {
            return (true, error?.message)
        }

        if DeviceListManager.shared.groupList.contains(where: { $0.groupName == text }) {
            return (true, LocalizedString(key: deviceListNameExists))
        }
        return (true, nil)
    }

    func placeholderForNameInputViewController(_ nameInputViewController: CommonNameInputViewController) -> String? {
        return SharedResource.sharedString(key: shareStringLengthConstraint)
    }
}

extension OnlineDeviceListMasterViewController {
    @objc func handleShowCameraDisplayNoActiveChannelAlertNotification(_ noti: NSNotification) {
        if let (device, listType) = noti.object as? (DeviceDetail, TPSSDeviceListType), listType == .remote {
            shouldShowCameraDisplayNoActiveChannelAlert = true
            addChannelCameraDisplay = DeviceListManager.shared.device(with: device.identifier)
        }
    }

    @objc func handleShowStorageDetectAlertNotification(_ noti: NSNotification) {
        diskStatusShowed = .none
        sdCardStatusShowed = .none
    }

    private func showCameraDisplayNoActiveChannelAlert() {
        showAlertWith(title: LocalizedString(key: deviceAddCameraDisplayNoActiveChannelsTitle), defaultButtonTitle: LocalizedString(key: deviceAddAddNext), cancelButtonTitle: LocalizedString(key: commonNotNow), cancelButtonHandler: nil) { (_) in
            if let cameraDisplay = self.addChannelCameraDisplay {
                DeviceListModule.shared.requiredService?.navigateToCameraDisplayDiscoverViewController(deviceID: cameraDisplay.identifier, discoverType: .cameraDisplay, listType: self.listType, navigator: self.navigationController)
                // 需要在中间插一个ViewController
                let vc = NVRTabViewController()
                vc.cloudIdentifier = cameraDisplay.cloudDeviceId
                vc.deviceIdentifier = cameraDisplay.identifier
                vc.listType = .remote
                vc.hidesBottomBarWhenPushed = true
                if var tmpViewControllers = self.tpNavigationController?.viewControllers {
                    tmpViewControllers.insert(vc, at: tmpViewControllers.count - 1)
                    self.tpNavigationController?.setViewControllers(tmpViewControllers, animated: true)
                }
            }
        }
    }
}

extension OnlineDeviceListMasterViewController: DeviceSDCardStatusChecker {
    var listType: TPSSDeviceListType { return .remote }

    func formatProcessDidFinish() {
        currentList.reload()
    }
}

extension OnlineDeviceListMasterViewController: DeviceSelectionViewControllerDelegate {
    func deviceSelectionViewController(_ deviceSelectionViewController: DeviceSelectionViewController, didPressRightBarButtonItemWithDeviceChannels selectedDeviceChannels: [DeviceDetail: [ChannelId]]) {
        switch deviceSelectionViewController.entryType {
        case .groupAddIndependent:
            ToastView.showLoadingToast(cirleWithMessage: nil)

            let targetDeviceChannels = DeviceSelectionViewController.covertDeviceChannel(selectedDeviceChannels)
            DeviceListManager.shared.createGroup(name: newCreateGroupName, deviceChannelMap: targetDeviceChannels).always {
                ToastView.dismissLoadingToast()
            }.then { (groupID) in
                self.navigationController?.popToViewController(self, animated: true)
                self.reload(with: groupID)
            }.catch { (error) in
                ToastView.showWarningToast(warningMessage: error.localizedDescription)
            }
        default:
            break
        }
    }
}

// MARK: - notification
extension OnlineDeviceListMasterViewController {
    @objc private func handleDeviceListInvalidated() {
        shouldRecreate = true
        deviceListVCCacheDictionary.removeAll()
    }

    @objc private func handleDeviceListUpdated() {
        showUpdateAlertIfAny()
    }

    @objc private func handleReorderBegined(_ notification: Notification) {
        enterReorderMode()
    }

    @objc private func handleReorderEnded(_ notification: Notification) {
        exitReorderMode()
    }

    @objc private func handleUpdateGroupAndDeviceList(_ notification: Notification) {
        if isCloudLogin {
            handleGroupModeToggleAfterGetList(notification)
        } else if isShowing {
            // 处理非登录场景

            // 仅页面正在显示才处理数据获取结果更新页面状态，否则等viewWillAppear再处理。避免正在获取列表
            // 时切换到其它页面，列表获取有结果后触发本逻辑使得子VC触发viewWillAppear，后续真正展示页面时
            // 就不再触发viewWillAppear导致数据异常
            showEmpty()
        }
    }

    @objc private func handleLocalDeviceRefreshed(_ notification: Notification) {
        if !isCloudLogin && isShowing {
            // 非登录且页面正在显示时才需要处理因网络状态变化重新发现完的通知，因为此时可能需要在有/无设备的页面之间切换。
            // 如果页面没有在显示则不需要处理，因为viewWillAppear会触发该逻辑
            showEmpty()
        }
    }

    @objc private func handleUpdateGroupList(_ notification: Notification) {
        if let dic = notification.object as? [String: Any],
           let error = dic[DeviceListManager.notificationKeyError] as? Error {
            ToastView.showWarningToast(title: error.localizedDescription, existTime: nil, centerY: .lowest)
            return
        }
        // 失败也更新，此时显示默认分组
        refreshAfterGroupUpdated()
    }

    private func handleGroupModeToggleAfterGetList(_ notification: Notification) {
        let finishHandler: (() -> Void) = {
            if self.shouldToggleGroupModeAfterGetList {
                ToastView.dismissLoadingToast()
                self.shouldToggleGroupModeAfterGetList = false
                self.toggleGroupMode()
            }
        }

        guard let dic = notification.object as? [String: Any],
              let status = dic[DeviceListManager.notificationKeyListUpdateStatus] as? DeviceListUpdateStatus else {
            finishHandler()
            return
        }

        if status.cloudUpdateNecessaryInfoFinished {
            finishHandler()
        }
    }
}

extension OnlineDeviceListMasterViewController: Storyboarded {
    static var storyboardName: String { return "DeviceList" }
    static var storyboardBundle: Bundle? { return Bundle.deviceListModuelBundle }
}

extension Notification.Name {
    static var DeviceListUpdated: Notification.Name { return Notification.Name("DeviceListUpdated") }
}

// MARK: - setup
extension OnlineDeviceListMasterViewController {
    private func setupView() {
        setupBarButtonItems()
        setupButtons()
    }

    private func setupBarButtonItems() {
        navigationItem.leftBarButtonItem = moreToolBarButtonItem
        navigationItem.rightBarButtonItem = addDeviceBarButtonItem
    }

    private func setupButtons() {
        groupToolbarDropMenuButton.setImage(SharedResource.sharedImage(named: "shared_arrow_down_small_normal"), for: .normal)
    }
}

// MARK: - reorder
extension OnlineDeviceListMasterViewController {
    // 本vc不会主动进入排序模式，而是依赖于OnlineDeviceListViewController的通知
    private func enterReorderMode() {
        isReordering = true
        tabBarController?.tabBar.isUserInteractionEnabled = false
        groupToolbarContainer.isUserInteractionEnabled = false

        pageController.scrollEnable = false

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = false
        }
    }

    private func showUpdateAlertIfAny() {
        if DeviceListManager.shared.allDetailDevices.contains(where: {(DeviceListModule.shared.requiredService?.onboardingTypeFromQRCode(qrCode: $0.qrCode) ?? 0) == TPSS_EC_GENERAL} ) || DeviceListManager.shared.hasUnsupportedDevice {
            // 二维码获取不支持的设备或者读取设备列表中有不支持的设备时，弹出升级提示
            let lastVersion: (isShow: Bool, versionCode: Int) = DeviceListModule.shared.requiredService?.checkShowUpdateAlert() ?? (false, 0)
            if lastVersion.isShow {
                showAlertWith(title: LocalizedString(key: commonNoticeUpdateAPP), message: nil, messageTextAlignment: nil,
                              defaultButtonTitle: LocalizedString(key: commonUpdateNow), defaultButtonColor: .theme1,
                              cancelButtonTitle: LocalizedString(key: commonIgnoreNotice), cancelButtonColor: .black.withAlphaComponent(0.8),
                              cancelButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.updateUserNoMoreNotify(version: lastVersion.versionCode)
                    self.showDiskAlertIfAny()
                }, defaultButtonHandler: { (_) in
                    DeviceListModule.shared.requiredService?.jumpAndCheckAppVersion()
                    self.showDiskAlertIfAny()
                })
            } else {
                showDiskAlertIfAny()
            }
        } else {
            showDiskAlertIfAny()
        }
    }

    private func exitReorderMode() {
        tabBarController?.tabBar.isUserInteractionEnabled = true
        groupToolbarContainer.isUserInteractionEnabled = true

        pageController.scrollEnable = true

        navigationItem.leftBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }
        navigationItem.rightBarButtonItems?.forEach { (item) in
            item.isEnabled = true
        }

        isReordering = false
    }
}


"""
